Compiler arguments:
  -log=verbose: compile_log.txt,w|xml|stderr -target=me -version=2.0 -platform=linux64 -out=. -modelicapath=/home/avpreetsingh/programfiles/jModelica/ThirdParty/MSL ../../../HPF HPF.Test.Multiphase_Transformer 
Current working directory:
  /media/avpreetsingh/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/HPF/Test/Multiphase_Transformer.pyjmi
Compiler version: r12669
Java version: 11.0.3
OS name: Linux
OS architecture: amd64
MODELICAPATH    = 
JAVA_HOME       = /usr/lib/jvm/java-11-openjdk-amd64
JMODELICA_HOME  = /home/avpreetsingh/programfiles/jModelica/
======= Compiling model =======
Parsing ../../../HPF/package.mo...
Checking for errors...
MODELICAPATH = /home/avpreetsingh/programfiles/jModelica/ThirdParty/MSL
extra_lib_dirs = 
Reading file: ../../../HPF/package.mo
Reading file: ../../../HPF/Test/package.mo
Reading file: ../../../HPF/Test/Multiphase_Transformer.mo
Reading file: /home/avpreetsingh/programfiles/jModelica/ThirdParty/MSL/Modelica/package.mo
Reading file: /home/avpreetsingh/programfiles/jModelica/ThirdParty/MSL/Modelica/Icons.mo
Reading file: ../../../HPF/SystemDef.mo
Reading file: ../../../HPF/Machines/package.mo
Reading file: ../../../HPF/Machines/Transformers_iPh/package.mo
Reading file: ../../../HPF/Machines/Transformers_iPh/Test_DY.mo
Reading file: ../../../HPF/SinglePhase/package.mo
Reading file: ../../../HPF/SinglePhase/Sources/package.mo
Reading file: ../../../HPF/SinglePhase/Sources/VoltageSource.mo
Reading file: ../../../HPF/SinglePhase/Interface.mo
Reading file: ../../../HPF/SinglePhase/Components/package.mo
Reading file: ../../../HPF/SinglePhase/Components/Ground.mo
Reading file: ../../../HPF/SinglePhase/Components/Resistor.mo
Reading file: ../../../HPF/SinglePhase/Components/Impedance.mo
Reading file: ../../../HPF/SinglePhase/Components/IdealTransformer.mo
Reading file: /home/avpreetsingh/programfiles/jModelica/ThirdParty/MSL/Complex.mo
Reading file: ../../../HPF/Types.mo
Reading file: /home/avpreetsingh/programfiles/jModelica/ThirdParty/MSL/Modelica/SIunits.mo
Reading file: /home/avpreetsingh/programfiles/jModelica/ThirdParty/MSL/Modelica/Constants.mo
Reading file: /home/avpreetsingh/programfiles/jModelica/ThirdParty/MSL/Modelica/Math/package.mo
Reading file: /home/avpreetsingh/programfiles/jModelica/ThirdParty/MSL/Modelica/ComplexMath.mo
Flattening model...
Raw flattened model:
fclass HPF.Test.Multiphase_Transformer
 parameter Integer systemDef.hrms[3] = {1, 3, 5} "Harmonics to simulate" /* { 1, 3, 5 } */;
 structural parameter Integer systemDef.numHrm = 3 "Number of harmonics. (Automatically generated from hrms. Do not alter)" /* 3 */;
 parameter Integer systemDef.numHigherHrm = 3 - 1 /* 2 */;
 parameter Integer systemDef.numPh = 3 "Number of phases" /* 3 */;
 parameter Real systemDef.fFund = 60 "Fundamental frequency" /* 60 */;
 discrete Boolean systemDef.modeSelect(start = true);
 discrete Boolean systemDef.event1(start = false);
 discrete Boolean systemDef.event2(start = false);
 parameter Integer test_DY1.N = 4 "Turns ration" /* 4 */;
 parameter Real test_DY1.idealTransformer1.N = test_DY1.N "Turns ratio N1:N2 = N:1 (Subject to review!)";
 Complex test_DY1.idealTransformer1.vPrim[3] "Complex voltage primary winding";
 Complex test_DY1.idealTransformer1.iPrim[3] "Complex current primary winding";
 Complex test_DY1.idealTransformer1.vSec[3] "Complex voltage secondary winding";
 Complex test_DY1.idealTransformer1.iSec[3] "Complex current secondary winding";
 HPF.Types.Reference test_DY1.idealTransformer1.pinP_Prim.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer1.pinP_Prim.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer1.pinP_Prim.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer1.pinP_Prim.iIm[3];
 Real test_DY1.idealTransformer1.pinP_Prim.iRe[3];
 HPF.Types.Reference test_DY1.idealTransformer1.pinN_Prim.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer1.pinN_Prim.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer1.pinN_Prim.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer1.pinN_Prim.iIm[3];
 Real test_DY1.idealTransformer1.pinN_Prim.iRe[3];
 HPF.Types.Reference test_DY1.idealTransformer1.pinP_Sec.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer1.pinP_Sec.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer1.pinP_Sec.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer1.pinP_Sec.iIm[3];
 Real test_DY1.idealTransformer1.pinP_Sec.iRe[3];
 HPF.Types.Reference test_DY1.idealTransformer1.pinN_Sec.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer1.pinN_Sec.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer1.pinN_Sec.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer1.pinN_Sec.iIm[3];
 Real test_DY1.idealTransformer1.pinN_Sec.iRe[3];
 parameter Real test_DY1.idealTransformer2.N = test_DY1.N "Turns ratio N1:N2 = N:1 (Subject to review!)";
 Complex test_DY1.idealTransformer2.vPrim[3] "Complex voltage primary winding";
 Complex test_DY1.idealTransformer2.iPrim[3] "Complex current primary winding";
 Complex test_DY1.idealTransformer2.vSec[3] "Complex voltage secondary winding";
 Complex test_DY1.idealTransformer2.iSec[3] "Complex current secondary winding";
 HPF.Types.Reference test_DY1.idealTransformer2.pinP_Prim.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer2.pinP_Prim.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer2.pinP_Prim.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer2.pinP_Prim.iIm[3];
 Real test_DY1.idealTransformer2.pinP_Prim.iRe[3];
 HPF.Types.Reference test_DY1.idealTransformer2.pinN_Prim.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer2.pinN_Prim.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer2.pinN_Prim.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer2.pinN_Prim.iIm[3];
 Real test_DY1.idealTransformer2.pinN_Prim.iRe[3];
 HPF.Types.Reference test_DY1.idealTransformer2.pinP_Sec.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer2.pinP_Sec.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer2.pinP_Sec.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer2.pinP_Sec.iIm[3];
 Real test_DY1.idealTransformer2.pinP_Sec.iRe[3];
 HPF.Types.Reference test_DY1.idealTransformer2.pinN_Sec.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer2.pinN_Sec.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer2.pinN_Sec.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer2.pinN_Sec.iIm[3];
 Real test_DY1.idealTransformer2.pinN_Sec.iRe[3];
 parameter Real test_DY1.idealTransformer3.N = test_DY1.N "Turns ratio N1:N2 = N:1 (Subject to review!)";
 Complex test_DY1.idealTransformer3.vPrim[3] "Complex voltage primary winding";
 Complex test_DY1.idealTransformer3.iPrim[3] "Complex current primary winding";
 Complex test_DY1.idealTransformer3.vSec[3] "Complex voltage secondary winding";
 Complex test_DY1.idealTransformer3.iSec[3] "Complex current secondary winding";
 HPF.Types.Reference test_DY1.idealTransformer3.pinP_Prim.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer3.pinP_Prim.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer3.pinP_Prim.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer3.pinP_Prim.iIm[3];
 Real test_DY1.idealTransformer3.pinP_Prim.iRe[3];
 HPF.Types.Reference test_DY1.idealTransformer3.pinN_Prim.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer3.pinN_Prim.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer3.pinN_Prim.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer3.pinN_Prim.iIm[3];
 Real test_DY1.idealTransformer3.pinN_Prim.iRe[3];
 HPF.Types.Reference test_DY1.idealTransformer3.pinP_Sec.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer3.pinP_Sec.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer3.pinP_Sec.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer3.pinP_Sec.iIm[3];
 Real test_DY1.idealTransformer3.pinP_Sec.iRe[3];
 HPF.Types.Reference test_DY1.idealTransformer3.pinN_Sec.reference "Reference";
 structural parameter Integer test_DY1.idealTransformer3.pinN_Sec.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.idealTransformer3.pinN_Sec.v[3] "Complex potential at the node";
 Real test_DY1.idealTransformer3.pinN_Sec.iIm[3];
 Real test_DY1.idealTransformer3.pinN_Sec.iRe[3];
 HPF.Types.Reference test_DY1.pinPrim_A.reference "Reference";
 structural parameter Integer test_DY1.pinPrim_A.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.pinPrim_A.v[3] "Complex potential at the node";
 Real test_DY1.pinPrim_A.iIm[3];
 Real test_DY1.pinPrim_A.iRe[3];
 HPF.Types.Reference test_DY1.pinPrim_B.reference "Reference";
 structural parameter Integer test_DY1.pinPrim_B.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.pinPrim_B.v[3] "Complex potential at the node";
 Real test_DY1.pinPrim_B.iIm[3];
 Real test_DY1.pinPrim_B.iRe[3];
 HPF.Types.Reference test_DY1.pinPrim_C.reference "Reference";
 structural parameter Integer test_DY1.pinPrim_C.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.pinPrim_C.v[3] "Complex potential at the node";
 Real test_DY1.pinPrim_C.iIm[3];
 Real test_DY1.pinPrim_C.iRe[3];
 HPF.Types.Reference test_DY1.hPin_P1.reference "Reference";
 structural parameter Integer test_DY1.hPin_P1.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.hPin_P1.v[3] "Complex potential at the node";
 Real test_DY1.hPin_P1.iIm[3];
 Real test_DY1.hPin_P1.iRe[3];
 HPF.Types.Reference test_DY1.hPin_P2.reference "Reference";
 structural parameter Integer test_DY1.hPin_P2.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.hPin_P2.v[3] "Complex potential at the node";
 Real test_DY1.hPin_P2.iIm[3];
 Real test_DY1.hPin_P2.iRe[3];
 HPF.Types.Reference test_DY1.hPin_P3.reference "Reference";
 structural parameter Integer test_DY1.hPin_P3.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.hPin_P3.v[3] "Complex potential at the node";
 Real test_DY1.hPin_P3.iIm[3];
 Real test_DY1.hPin_P3.iRe[3];
 HPF.Types.Reference test_DY1.hPin_N.reference "Reference";
 structural parameter Integer test_DY1.hPin_N.h = 3 "Numbder of harmonics" /* 3 */;
 Complex test_DY1.hPin_N.v[3] "Complex potential at the node";
 Real test_DY1.hPin_N.iIm[3];
 Real test_DY1.hPin_N.iRe[3];
 parameter Real PhA.vMag[3] = {392, 10, 3} "Voltage Magnitude" /* { 392, 10, 3 } */;
 parameter Real PhA.vArg[3] = {0, 0.5, 2.3} "Voltage angle" /* { 0, 0.5, 2.3 } */;
 Modelica.SIunits.Angle PhA.theta(start = 0) = PhA.pin_p.reference.theta;
 Complex PhA.v[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex voltage";
 Complex PhA.i[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex current";
 Real PhA.omega;
 HPF.Types.Reference PhA.pin_p.reference "Reference";
 structural parameter Integer PhA.pin_p.h = 3 "Numbder of harmonics" /* 3 */;
 Complex PhA.pin_p.v[3] "Complex potential at the node";
 Real PhA.pin_p.iIm[3];
 Real PhA.pin_p.iRe[3];
 HPF.Types.Reference PhA.pin_n.reference "Reference";
 structural parameter Integer PhA.pin_n.h = 3 "Numbder of harmonics" /* 3 */;
 Complex PhA.pin_n.v[3] "Complex potential at the node";
 Real PhA.pin_n.iIm[3];
 Real PhA.pin_n.iRe[3];
 parameter Real PhB.vMag[3] = {392, 11, 2.6} "Voltage Magnitude" /* { 392, 11, 2.6 } */;
 parameter Real PhB.vArg[3] = {Modelica.SIunits.Conversions.from_deg(-120), 0, 1.2} "Voltage angle" /* { -2.0943951023931953, 0, 1.2 } */;
 Modelica.SIunits.Angle PhB.theta(start = 0) = PhB.pin_p.reference.theta;
 Complex PhB.v[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex voltage";
 Complex PhB.i[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex current";
 Real PhB.omega;
 HPF.Types.Reference PhB.pin_p.reference "Reference";
 structural parameter Integer PhB.pin_p.h = 3 "Numbder of harmonics" /* 3 */;
 Complex PhB.pin_p.v[3] "Complex potential at the node";
 Real PhB.pin_p.iIm[3];
 Real PhB.pin_p.iRe[3];
 HPF.Types.Reference PhB.pin_n.reference "Reference";
 structural parameter Integer PhB.pin_n.h = 3 "Numbder of harmonics" /* 3 */;
 Complex PhB.pin_n.v[3] "Complex potential at the node";
 Real PhB.pin_n.iIm[3];
 Real PhB.pin_n.iRe[3];
 parameter Real PhC.vMag[3] = {392, 10, 3} "Voltage Magnitude" /* { 392, 10, 3 } */;
 parameter Real PhC.vArg[3] = {Modelica.SIunits.Conversions.from_deg(120), 0.6, 2.1} "Voltage angle" /* { 2.0943951023931953, 0.6, 2.1 } */;
 Modelica.SIunits.Angle PhC.theta(start = 0) = PhC.pin_p.reference.theta;
 Complex PhC.v[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex voltage";
 Complex PhC.i[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex current";
 Real PhC.omega;
 HPF.Types.Reference PhC.pin_p.reference "Reference";
 structural parameter Integer PhC.pin_p.h = 3 "Numbder of harmonics" /* 3 */;
 Complex PhC.pin_p.v[3] "Complex potential at the node";
 Real PhC.pin_p.iIm[3];
 Real PhC.pin_p.iRe[3];
 HPF.Types.Reference PhC.pin_n.reference "Reference";
 structural parameter Integer PhC.pin_n.h = 3 "Numbder of harmonics" /* 3 */;
 Complex PhC.pin_n.v[3] "Complex potential at the node";
 Real PhC.pin_n.iIm[3];
 Real PhC.pin_n.iRe[3];
 HPF.Types.Reference ground.pin.reference "Reference";
 structural parameter Integer ground.pin.h = 3 "Numbder of harmonics" /* 3 */;
 Complex ground.pin.v[3] "Complex potential at the node";
 Real ground.pin.iIm[3];
 Real ground.pin.iRe[3];
 HPF.Types.Reference ground1.pin.reference "Reference";
 structural parameter Integer ground1.pin.h = 3 "Numbder of harmonics" /* 3 */;
 Complex ground1.pin.v[3] "Complex potential at the node";
 Real ground1.pin.iIm[3];
 Real ground1.pin.iRe[3];
 parameter Real r1.r(start = 1) = 500 "Resistance (ohm)" /* 500 */;
 Real r1.vFundAbs = Modelica.ComplexMath.'abs'(r1.v[1]);
 Real r1.vFundArg = Modelica.ComplexMath.arg(r1.v[1], 0);
 Real r1.iFundAbs = Modelica.ComplexMath.'abs'(r1.i[1]);
 Real r1.iFundArg = Modelica.ComplexMath.arg(r1.i[1], 0);
 Complex r1.v[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex voltage";
 Complex r1.i[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex current";
 Real r1.omega;
 HPF.Types.Reference r1.pin_p.reference "Reference";
 structural parameter Integer r1.pin_p.h = 3 "Numbder of harmonics" /* 3 */;
 Complex r1.pin_p.v[3] "Complex potential at the node";
 Real r1.pin_p.iIm[3];
 Real r1.pin_p.iRe[3];
 HPF.Types.Reference r1.pin_n.reference "Reference";
 structural parameter Integer r1.pin_n.h = 3 "Numbder of harmonics" /* 3 */;
 Complex r1.pin_n.v[3] "Complex potential at the node";
 Real r1.pin_n.iIm[3];
 Real r1.pin_n.iRe[3];
 parameter Real r2.r(start = 1) = 500 "Resistance (ohm)" /* 500 */;
 Real r2.vFundAbs = Modelica.ComplexMath.'abs'(r2.v[1]);
 Real r2.vFundArg = Modelica.ComplexMath.arg(r2.v[1], 0);
 Real r2.iFundAbs = Modelica.ComplexMath.'abs'(r2.i[1]);
 Real r2.iFundArg = Modelica.ComplexMath.arg(r2.i[1], 0);
 Complex r2.v[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex voltage";
 Complex r2.i[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex current";
 Real r2.omega;
 HPF.Types.Reference r2.pin_p.reference "Reference";
 structural parameter Integer r2.pin_p.h = 3 "Numbder of harmonics" /* 3 */;
 Complex r2.pin_p.v[3] "Complex potential at the node";
 Real r2.pin_p.iIm[3];
 Real r2.pin_p.iRe[3];
 HPF.Types.Reference r2.pin_n.reference "Reference";
 structural parameter Integer r2.pin_n.h = 3 "Numbder of harmonics" /* 3 */;
 Complex r2.pin_n.v[3] "Complex potential at the node";
 Real r2.pin_n.iIm[3];
 Real r2.pin_n.iRe[3];
 parameter Complex z.z(re(start = 1),im(start = 0)) = Complex.'constructor'.fromReal(500, 20) "Impedance, R + jX";
 Real z.vFundAbs = Modelica.ComplexMath.'abs'(z.v[1]);
 Real z.vFundArg = Modelica.ComplexMath.arg(z.v[1], 0);
 Real z.iFundAbs = Modelica.ComplexMath.'abs'(z.i[1]);
 Real z.iFundArg = Modelica.ComplexMath.arg(z.i[1], 0);
 Complex z.v[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex voltage";
 Complex z.i[3](each re(start = 0,nominal = 1),each im(start = 0,nominal = 1)) "Complex current";
 Real z.omega;
 HPF.Types.Reference z.pin_p.reference "Reference";
 structural parameter Integer z.pin_p.h = 3 "Numbder of harmonics" /* 3 */;
 Complex z.pin_p.v[3] "Complex potential at the node";
 Real z.pin_p.iIm[3];
 Real z.pin_p.iRe[3];
 HPF.Types.Reference z.pin_n.reference "Reference";
 structural parameter Integer z.pin_n.h = 3 "Numbder of harmonics" /* 3 */;
 Complex z.pin_n.v[3] "Complex potential at the node";
 Real z.pin_n.iIm[3];
 Real z.pin_n.iRe[3];
initial equation
 algorithm
  systemDef.modeSelect := false;
;
algorithm
 when time > 0.5 then
  systemDef.modeSelect := true;
 end when;
 when time > 0.25 then
  systemDef.event1 := true;
 end when;
 when time > 0.4 then
  systemDef.event2 := true;
 end when;
equation
 test_DY1.idealTransformer1.vSec[1:3] = {Complex.'*'.multiply(Complex.'constructor'.fromReal(1 / test_DY1.idealTransformer1.N, 0), test_DY1.idealTransformer1.vPrim[1]), Complex.'*'.multiply(Complex.'constructor'.fromReal(1 / test_DY1.idealTransformer1.N, 0), test_DY1.idealTransformer1.vPrim[2]), Complex.'*'.multiply(Complex.'constructor'.fromReal(1 / test_DY1.idealTransformer1.N, 0), test_DY1.idealTransformer1.vPrim[3])};
 test_DY1.idealTransformer1.iSec[1:3] = {Complex.'*'.multiply(Complex.'constructor'.fromReal(test_DY1.idealTransformer1.N, 0), test_DY1.idealTransformer1.iPrim[1]), Complex.'*'.multiply(Complex.'constructor'.fromReal(test_DY1.idealTransformer1.N, 0), test_DY1.idealTransformer1.iPrim[2]), Complex.'*'.multiply(Complex.'constructor'.fromReal(test_DY1.idealTransformer1.N, 0), test_DY1.idealTransformer1.iPrim[3])};
 test_DY1.idealTransformer1.pinP_Prim.reference.theta = test_DY1.idealTransformer1.pinN_Prim.reference.theta;
 test_DY1.idealTransformer1.pinP_Prim.reference.theta = test_DY1.idealTransformer1.pinP_Sec.reference.theta;
 test_DY1.idealTransformer1.pinN_Prim.reference.theta = test_DY1.idealTransformer1.pinN_Sec.reference.theta;
 test_DY1.idealTransformer1.vPrim[1:3] = {Complex.'-'.subtract(test_DY1.idealTransformer1.pinP_Prim.v[1], test_DY1.idealTransformer1.pinN_Prim.v[1]), Complex.'-'.subtract(test_DY1.idealTransformer1.pinP_Prim.v[2], test_DY1.idealTransformer1.pinN_Prim.v[2]), Complex.'-'.subtract(test_DY1.idealTransformer1.pinP_Prim.v[3], test_DY1.idealTransformer1.pinN_Prim.v[3])};
 test_DY1.idealTransformer1.vSec[1:3] = {Complex.'-'.subtract(test_DY1.idealTransformer1.pinP_Sec.v[1], test_DY1.idealTransformer1.pinN_Sec.v[1]), Complex.'-'.subtract(test_DY1.idealTransformer1.pinP_Sec.v[2], test_DY1.idealTransformer1.pinN_Sec.v[2]), Complex.'-'.subtract(test_DY1.idealTransformer1.pinP_Sec.v[3], test_DY1.idealTransformer1.pinN_Sec.v[3])};
 test_DY1.idealTransformer1.iPrim[1:3].re = test_DY1.idealTransformer1.pinP_Prim.iRe[1:3];
 test_DY1.idealTransformer1.iPrim[1:3].im = test_DY1.idealTransformer1.pinP_Prim.iIm[1:3];
 test_DY1.idealTransformer1.iSec[1:3].re = test_DY1.idealTransformer1.pinP_Sec.iRe[1:3];
 test_DY1.idealTransformer1.iSec[1:3].im = test_DY1.idealTransformer1.pinP_Sec.iIm[1:3];
 test_DY1.idealTransformer1.pinP_Prim.iRe[1:3] + test_DY1.idealTransformer1.pinN_Prim.iRe[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer1.pinP_Prim.iIm[1:3] + test_DY1.idealTransformer1.pinN_Prim.iIm[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer1.pinP_Sec.iRe[1:3] + test_DY1.idealTransformer1.pinN_Sec.iRe[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer1.pinP_Sec.iIm[1:3] + test_DY1.idealTransformer1.pinN_Sec.iIm[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer2.vSec[1:3] = {Complex.'*'.multiply(Complex.'constructor'.fromReal(1 / test_DY1.idealTransformer2.N, 0), test_DY1.idealTransformer2.vPrim[1]), Complex.'*'.multiply(Complex.'constructor'.fromReal(1 / test_DY1.idealTransformer2.N, 0), test_DY1.idealTransformer2.vPrim[2]), Complex.'*'.multiply(Complex.'constructor'.fromReal(1 / test_DY1.idealTransformer2.N, 0), test_DY1.idealTransformer2.vPrim[3])};
 test_DY1.idealTransformer2.iSec[1:3] = {Complex.'*'.multiply(Complex.'constructor'.fromReal(test_DY1.idealTransformer2.N, 0), test_DY1.idealTransformer2.iPrim[1]), Complex.'*'.multiply(Complex.'constructor'.fromReal(test_DY1.idealTransformer2.N, 0), test_DY1.idealTransformer2.iPrim[2]), Complex.'*'.multiply(Complex.'constructor'.fromReal(test_DY1.idealTransformer2.N, 0), test_DY1.idealTransformer2.iPrim[3])};
 test_DY1.idealTransformer2.pinP_Prim.reference.theta = test_DY1.idealTransformer2.pinN_Prim.reference.theta;
 test_DY1.idealTransformer2.pinP_Prim.reference.theta = test_DY1.idealTransformer2.pinP_Sec.reference.theta;
 test_DY1.idealTransformer2.pinN_Prim.reference.theta = test_DY1.idealTransformer2.pinN_Sec.reference.theta;
 test_DY1.idealTransformer2.vPrim[1:3] = {Complex.'-'.subtract(test_DY1.idealTransformer2.pinP_Prim.v[1], test_DY1.idealTransformer2.pinN_Prim.v[1]), Complex.'-'.subtract(test_DY1.idealTransformer2.pinP_Prim.v[2], test_DY1.idealTransformer2.pinN_Prim.v[2]), Complex.'-'.subtract(test_DY1.idealTransformer2.pinP_Prim.v[3], test_DY1.idealTransformer2.pinN_Prim.v[3])};
 test_DY1.idealTransformer2.vSec[1:3] = {Complex.'-'.subtract(test_DY1.idealTransformer2.pinP_Sec.v[1], test_DY1.idealTransformer2.pinN_Sec.v[1]), Complex.'-'.subtract(test_DY1.idealTransformer2.pinP_Sec.v[2], test_DY1.idealTransformer2.pinN_Sec.v[2]), Complex.'-'.subtract(test_DY1.idealTransformer2.pinP_Sec.v[3], test_DY1.idealTransformer2.pinN_Sec.v[3])};
 test_DY1.idealTransformer2.iPrim[1:3].re = test_DY1.idealTransformer2.pinP_Prim.iRe[1:3];
 test_DY1.idealTransformer2.iPrim[1:3].im = test_DY1.idealTransformer2.pinP_Prim.iIm[1:3];
 test_DY1.idealTransformer2.iSec[1:3].re = test_DY1.idealTransformer2.pinP_Sec.iRe[1:3];
 test_DY1.idealTransformer2.iSec[1:3].im = test_DY1.idealTransformer2.pinP_Sec.iIm[1:3];
 test_DY1.idealTransformer2.pinP_Prim.iRe[1:3] + test_DY1.idealTransformer2.pinN_Prim.iRe[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer2.pinP_Prim.iIm[1:3] + test_DY1.idealTransformer2.pinN_Prim.iIm[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer2.pinP_Sec.iRe[1:3] + test_DY1.idealTransformer2.pinN_Sec.iRe[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer2.pinP_Sec.iIm[1:3] + test_DY1.idealTransformer2.pinN_Sec.iIm[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer3.vSec[1:3] = {Complex.'*'.multiply(Complex.'constructor'.fromReal(1 / test_DY1.idealTransformer3.N, 0), test_DY1.idealTransformer3.vPrim[1]), Complex.'*'.multiply(Complex.'constructor'.fromReal(1 / test_DY1.idealTransformer3.N, 0), test_DY1.idealTransformer3.vPrim[2]), Complex.'*'.multiply(Complex.'constructor'.fromReal(1 / test_DY1.idealTransformer3.N, 0), test_DY1.idealTransformer3.vPrim[3])};
 test_DY1.idealTransformer3.iSec[1:3] = {Complex.'*'.multiply(Complex.'constructor'.fromReal(test_DY1.idealTransformer3.N, 0), test_DY1.idealTransformer3.iPrim[1]), Complex.'*'.multiply(Complex.'constructor'.fromReal(test_DY1.idealTransformer3.N, 0), test_DY1.idealTransformer3.iPrim[2]), Complex.'*'.multiply(Complex.'constructor'.fromReal(test_DY1.idealTransformer3.N, 0), test_DY1.idealTransformer3.iPrim[3])};
 test_DY1.idealTransformer3.pinP_Prim.reference.theta = test_DY1.idealTransformer3.pinN_Prim.reference.theta;
 test_DY1.idealTransformer3.pinP_Prim.reference.theta = test_DY1.idealTransformer3.pinP_Sec.reference.theta;
 test_DY1.idealTransformer3.pinN_Prim.reference.theta = test_DY1.idealTransformer3.pinN_Sec.reference.theta;
 test_DY1.idealTransformer3.vPrim[1:3] = {Complex.'-'.subtract(test_DY1.idealTransformer3.pinP_Prim.v[1], test_DY1.idealTransformer3.pinN_Prim.v[1]), Complex.'-'.subtract(test_DY1.idealTransformer3.pinP_Prim.v[2], test_DY1.idealTransformer3.pinN_Prim.v[2]), Complex.'-'.subtract(test_DY1.idealTransformer3.pinP_Prim.v[3], test_DY1.idealTransformer3.pinN_Prim.v[3])};
 test_DY1.idealTransformer3.vSec[1:3] = {Complex.'-'.subtract(test_DY1.idealTransformer3.pinP_Sec.v[1], test_DY1.idealTransformer3.pinN_Sec.v[1]), Complex.'-'.subtract(test_DY1.idealTransformer3.pinP_Sec.v[2], test_DY1.idealTransformer3.pinN_Sec.v[2]), Complex.'-'.subtract(test_DY1.idealTransformer3.pinP_Sec.v[3], test_DY1.idealTransformer3.pinN_Sec.v[3])};
 test_DY1.idealTransformer3.iPrim[1:3].re = test_DY1.idealTransformer3.pinP_Prim.iRe[1:3];
 test_DY1.idealTransformer3.iPrim[1:3].im = test_DY1.idealTransformer3.pinP_Prim.iIm[1:3];
 test_DY1.idealTransformer3.iSec[1:3].re = test_DY1.idealTransformer3.pinP_Sec.iRe[1:3];
 test_DY1.idealTransformer3.iSec[1:3].im = test_DY1.idealTransformer3.pinP_Sec.iIm[1:3];
 test_DY1.idealTransformer3.pinP_Prim.iRe[1:3] + test_DY1.idealTransformer3.pinN_Prim.iRe[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer3.pinP_Prim.iIm[1:3] + test_DY1.idealTransformer3.pinN_Prim.iIm[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer3.pinP_Sec.iRe[1:3] + test_DY1.idealTransformer3.pinN_Sec.iRe[1:3] = {0.0, 0.0, 0.0};
 test_DY1.idealTransformer3.pinP_Sec.iIm[1:3] + test_DY1.idealTransformer3.pinN_Sec.iIm[1:3] = {0.0, 0.0, 0.0};
 PhA.omega = 2 * 3.141592653589793 * systemDef.fFund;
 PhA.v[1:3].re = PhA.vMag[1:3] .* cos(PhA.vArg[1:3]);
 PhA.v[1:3].im = PhA.vMag[1:3] .* sin(PhA.vArg[1:3]);
 PhA.pin_p.reference.theta = PhA.pin_n.reference.theta;
 PhA.omega = der(PhA.pin_p.reference.theta);
 PhA.v[1:3] = {Complex.'-'.subtract(PhA.pin_p.v[1], PhA.pin_n.v[1]), Complex.'-'.subtract(PhA.pin_p.v[2], PhA.pin_n.v[2]), Complex.'-'.subtract(PhA.pin_p.v[3], PhA.pin_n.v[3])};
 PhA.i[1:3].re = PhA.pin_p.iRe[1:3];
 PhA.i[1:3].im = PhA.pin_p.iIm[1:3];
 PhA.pin_p.iRe[1:3] + PhA.pin_n.iRe[1:3] = {0.0, 0.0, 0.0};
 PhA.pin_p.iIm[1:3] + PhA.pin_n.iIm[1:3] = {0.0, 0.0, 0.0};
 PhB.omega = 2 * 3.141592653589793 * systemDef.fFund;
 PhB.v[1:3].re = PhB.vMag[1:3] .* cos(PhB.vArg[1:3]);
 PhB.v[1:3].im = PhB.vMag[1:3] .* sin(PhB.vArg[1:3]);
 PhB.pin_p.reference.theta = PhB.pin_n.reference.theta;
 PhB.omega = der(PhB.pin_p.reference.theta);
 PhB.v[1:3] = {Complex.'-'.subtract(PhB.pin_p.v[1], PhB.pin_n.v[1]), Complex.'-'.subtract(PhB.pin_p.v[2], PhB.pin_n.v[2]), Complex.'-'.subtract(PhB.pin_p.v[3], PhB.pin_n.v[3])};
 PhB.i[1:3].re = PhB.pin_p.iRe[1:3];
 PhB.i[1:3].im = PhB.pin_p.iIm[1:3];
 PhB.pin_p.iRe[1:3] + PhB.pin_n.iRe[1:3] = {0.0, 0.0, 0.0};
 PhB.pin_p.iIm[1:3] + PhB.pin_n.iIm[1:3] = {0.0, 0.0, 0.0};
 PhC.omega = 2 * 3.141592653589793 * systemDef.fFund;
 PhC.v[1:3].re = PhC.vMag[1:3] .* cos(PhC.vArg[1:3]);
 PhC.v[1:3].im = PhC.vMag[1:3] .* sin(PhC.vArg[1:3]);
 PhC.pin_p.reference.theta = PhC.pin_n.reference.theta;
 PhC.omega = der(PhC.pin_p.reference.theta);
 PhC.v[1:3] = {Complex.'-'.subtract(PhC.pin_p.v[1], PhC.pin_n.v[1]), Complex.'-'.subtract(PhC.pin_p.v[2], PhC.pin_n.v[2]), Complex.'-'.subtract(PhC.pin_p.v[3], PhC.pin_n.v[3])};
 PhC.i[1:3].re = PhC.pin_p.iRe[1:3];
 PhC.i[1:3].im = PhC.pin_p.iIm[1:3];
 PhC.pin_p.iRe[1:3] + PhC.pin_n.iRe[1:3] = {0.0, 0.0, 0.0};
 PhC.pin_p.iIm[1:3] + PhC.pin_n.iIm[1:3] = {0.0, 0.0, 0.0};
 if Connections.isRoot(ground.pin.reference) then
  ground.pin.reference.theta = 0;
 end if;
 ground.pin.v[1:3] = {Complex.'constructor'.fromReal(0.0, 0), Complex.'constructor'.fromReal(0.0, 0), Complex.'constructor'.fromReal(0.0, 0)};
 if Connections.isRoot(ground1.pin.reference) then
  ground1.pin.reference.theta = 0;
 end if;
 ground1.pin.v[1:3] = {Complex.'constructor'.fromReal(0.0, 0), Complex.'constructor'.fromReal(0.0, 0), Complex.'constructor'.fromReal(0.0, 0)};
 r1.v[1:3].re = r1.r .* r1.i[1:3].re;
 r1.v[1:3].im = r1.r .* r1.i[1:3].im;
 r1.pin_p.reference.theta = r1.pin_n.reference.theta;
 r1.omega = der(r1.pin_p.reference.theta);
 r1.v[1:3] = {Complex.'-'.subtract(r1.pin_p.v[1], r1.pin_n.v[1]), Complex.'-'.subtract(r1.pin_p.v[2], r1.pin_n.v[2]), Complex.'-'.subtract(r1.pin_p.v[3], r1.pin_n.v[3])};
 r1.i[1:3].re = r1.pin_p.iRe[1:3];
 r1.i[1:3].im = r1.pin_p.iIm[1:3];
 r1.pin_p.iRe[1:3] + r1.pin_n.iRe[1:3] = {0.0, 0.0, 0.0};
 r1.pin_p.iIm[1:3] + r1.pin_n.iIm[1:3] = {0.0, 0.0, 0.0};
 r2.v[1:3].re = r2.r .* r2.i[1:3].re;
 r2.v[1:3].im = r2.r .* r2.i[1:3].im;
 r2.pin_p.reference.theta = r2.pin_n.reference.theta;
 r2.omega = der(r2.pin_p.reference.theta);
 r2.v[1:3] = {Complex.'-'.subtract(r2.pin_p.v[1], r2.pin_n.v[1]), Complex.'-'.subtract(r2.pin_p.v[2], r2.pin_n.v[2]), Complex.'-'.subtract(r2.pin_p.v[3], r2.pin_n.v[3])};
 r2.i[1:3].re = r2.pin_p.iRe[1:3];
 r2.i[1:3].im = r2.pin_p.iIm[1:3];
 r2.pin_p.iRe[1:3] + r2.pin_n.iRe[1:3] = {0.0, 0.0, 0.0};
 r2.pin_p.iIm[1:3] + r2.pin_n.iIm[1:3] = {0.0, 0.0, 0.0};
 z.v[1:3].re = z.z.re .* z.i[1:3].re - z.z.im .* systemDef.hrms[1:3] .* z.i[1:3].im;
 z.v[1:3].im = z.z.re .* z.i[1:3].im + z.z.im .* systemDef.hrms[1:3] .* z.i[1:3].re;
 z.pin_p.reference.theta = z.pin_n.reference.theta;
 z.omega = der(z.pin_p.reference.theta);
 z.v[1:3] = {Complex.'-'.subtract(z.pin_p.v[1], z.pin_n.v[1]), Complex.'-'.subtract(z.pin_p.v[2], z.pin_n.v[2]), Complex.'-'.subtract(z.pin_p.v[3], z.pin_n.v[3])};
 z.i[1:3].re = z.pin_p.iRe[1:3];
 z.i[1:3].im = z.pin_p.iIm[1:3];
 z.pin_p.iRe[1:3] + z.pin_n.iRe[1:3] = {0.0, 0.0, 0.0};
 z.pin_p.iIm[1:3] + z.pin_n.iIm[1:3] = {0.0, 0.0, 0.0};
 ground1.pin.iIm[1:3] + r1.pin_n.iIm[1:3] + r2.pin_n.iIm[1:3] + test_DY1.hPin_N.iIm[1:3] + z.pin_n.iIm[1:3] = zeros(3);
 ground1.pin.iRe[1:3] + r1.pin_n.iRe[1:3] + r2.pin_n.iRe[1:3] + test_DY1.hPin_N.iRe[1:3] + z.pin_n.iRe[1:3] = zeros(3);
 ground1.pin.v[1].im = r1.pin_n.v[1].im;
 r1.pin_n.v[1].im = r2.pin_n.v[1].im;
 r2.pin_n.v[1].im = test_DY1.hPin_N.v[1].im;
 test_DY1.hPin_N.v[1].im = z.pin_n.v[1].im;
 ground1.pin.v[1].re = r1.pin_n.v[1].re;
 r1.pin_n.v[1].re = r2.pin_n.v[1].re;
 r2.pin_n.v[1].re = test_DY1.hPin_N.v[1].re;
 test_DY1.hPin_N.v[1].re = z.pin_n.v[1].re;
 ground1.pin.v[2].im = r1.pin_n.v[2].im;
 r1.pin_n.v[2].im = r2.pin_n.v[2].im;
 r2.pin_n.v[2].im = test_DY1.hPin_N.v[2].im;
 test_DY1.hPin_N.v[2].im = z.pin_n.v[2].im;
 ground1.pin.v[2].re = r1.pin_n.v[2].re;
 r1.pin_n.v[2].re = r2.pin_n.v[2].re;
 r2.pin_n.v[2].re = test_DY1.hPin_N.v[2].re;
 test_DY1.hPin_N.v[2].re = z.pin_n.v[2].re;
 ground1.pin.v[3].im = r1.pin_n.v[3].im;
 r1.pin_n.v[3].im = r2.pin_n.v[3].im;
 r2.pin_n.v[3].im = test_DY1.hPin_N.v[3].im;
 test_DY1.hPin_N.v[3].im = z.pin_n.v[3].im;
 ground1.pin.v[3].re = r1.pin_n.v[3].re;
 r1.pin_n.v[3].re = r2.pin_n.v[3].re;
 r2.pin_n.v[3].re = test_DY1.hPin_N.v[3].re;
 test_DY1.hPin_N.v[3].re = z.pin_n.v[3].re;
 PhA.pin_p.iIm[1:3] + test_DY1.pinPrim_A.iIm[1:3] = zeros(3);
 PhA.pin_p.iRe[1:3] + test_DY1.pinPrim_A.iRe[1:3] = zeros(3);
 PhA.pin_p.v[1].im = test_DY1.pinPrim_A.v[1].im;
 PhA.pin_p.v[1].re = test_DY1.pinPrim_A.v[1].re;
 PhA.pin_p.v[2].im = test_DY1.pinPrim_A.v[2].im;
 PhA.pin_p.v[2].re = test_DY1.pinPrim_A.v[2].re;
 PhA.pin_p.v[3].im = test_DY1.pinPrim_A.v[3].im;
 PhA.pin_p.v[3].re = test_DY1.pinPrim_A.v[3].re;
 PhB.pin_p.iIm[1:3] + test_DY1.pinPrim_B.iIm[1:3] = zeros(3);
 PhB.pin_p.iRe[1:3] + test_DY1.pinPrim_B.iRe[1:3] = zeros(3);
 PhB.pin_p.v[1].im = test_DY1.pinPrim_B.v[1].im;
 PhB.pin_p.v[1].re = test_DY1.pinPrim_B.v[1].re;
 PhB.pin_p.v[2].im = test_DY1.pinPrim_B.v[2].im;
 PhB.pin_p.v[2].re = test_DY1.pinPrim_B.v[2].re;
 PhB.pin_p.v[3].im = test_DY1.pinPrim_B.v[3].im;
 PhB.pin_p.v[3].re = test_DY1.pinPrim_B.v[3].re;
 PhC.pin_p.iIm[1:3] + test_DY1.pinPrim_C.iIm[1:3] = zeros(3);
 PhC.pin_p.iRe[1:3] + test_DY1.pinPrim_C.iRe[1:3] = zeros(3);
 PhC.pin_p.v[1].im = test_DY1.pinPrim_C.v[1].im;
 PhC.pin_p.v[1].re = test_DY1.pinPrim_C.v[1].re;
 PhC.pin_p.v[2].im = test_DY1.pinPrim_C.v[2].im;
 PhC.pin_p.v[2].re = test_DY1.pinPrim_C.v[2].re;
 PhC.pin_p.v[3].im = test_DY1.pinPrim_C.v[3].im;
 PhC.pin_p.v[3].re = test_DY1.pinPrim_C.v[3].re;
 PhA.pin_n.iIm[1:3] + PhB.pin_n.iIm[1:3] + PhC.pin_n.iIm[1:3] + ground.pin.iIm[1:3] = zeros(3);
 PhA.pin_n.iRe[1:3] + PhB.pin_n.iRe[1:3] + PhC.pin_n.iRe[1:3] + ground.pin.iRe[1:3] = zeros(3);
 PhA.pin_n.v[1].im = PhB.pin_n.v[1].im;
 PhB.pin_n.v[1].im = PhC.pin_n.v[1].im;
 PhC.pin_n.v[1].im = ground.pin.v[1].im;
 PhA.pin_n.v[1].re = PhB.pin_n.v[1].re;
 PhB.pin_n.v[1].re = PhC.pin_n.v[1].re;
 PhC.pin_n.v[1].re = ground.pin.v[1].re;
 PhA.pin_n.v[2].im = PhB.pin_n.v[2].im;
 PhB.pin_n.v[2].im = PhC.pin_n.v[2].im;
 PhC.pin_n.v[2].im = ground.pin.v[2].im;
 PhA.pin_n.v[2].re = PhB.pin_n.v[2].re;
 PhB.pin_n.v[2].re = PhC.pin_n.v[2].re;
 PhC.pin_n.v[2].re = ground.pin.v[2].re;
 PhA.pin_n.v[3].im = PhB.pin_n.v[3].im;
 PhB.pin_n.v[3].im = PhC.pin_n.v[3].im;
 PhC.pin_n.v[3].im = ground.pin.v[3].im;
 PhA.pin_n.v[3].re = PhB.pin_n.v[3].re;
 PhB.pin_n.v[3].re = PhC.pin_n.v[3].re;
 PhC.pin_n.v[3].re = ground.pin.v[3].re;
 r1.pin_p.iIm[1:3] + test_DY1.hPin_P2.iIm[1:3] = zeros(3);
 r1.pin_p.iRe[1:3] + test_DY1.hPin_P2.iRe[1:3] = zeros(3);
 r1.pin_p.v[1].im = test_DY1.hPin_P2.v[1].im;
 r1.pin_p.v[1].re = test_DY1.hPin_P2.v[1].re;
 r1.pin_p.v[2].im = test_DY1.hPin_P2.v[2].im;
 r1.pin_p.v[2].re = test_DY1.hPin_P2.v[2].re;
 r1.pin_p.v[3].im = test_DY1.hPin_P2.v[3].im;
 r1.pin_p.v[3].re = test_DY1.hPin_P2.v[3].re;
 r2.pin_p.iIm[1:3] + test_DY1.hPin_P3.iIm[1:3] = zeros(3);
 r2.pin_p.iRe[1:3] + test_DY1.hPin_P3.iRe[1:3] = zeros(3);
 r2.pin_p.v[1].im = test_DY1.hPin_P3.v[1].im;
 r2.pin_p.v[1].re = test_DY1.hPin_P3.v[1].re;
 r2.pin_p.v[2].im = test_DY1.hPin_P3.v[2].im;
 r2.pin_p.v[2].re = test_DY1.hPin_P3.v[2].re;
 r2.pin_p.v[3].im = test_DY1.hPin_P3.v[3].im;
 r2.pin_p.v[3].re = test_DY1.hPin_P3.v[3].re;
 test_DY1.hPin_P1.iIm[1:3] + z.pin_p.iIm[1:3] = zeros(3);
 test_DY1.hPin_P1.iRe[1:3] + z.pin_p.iRe[1:3] = zeros(3);
 test_DY1.hPin_P1.v[1].im = z.pin_p.v[1].im;
 test_DY1.hPin_P1.v[1].re = z.pin_p.v[1].re;
 test_DY1.hPin_P1.v[2].im = z.pin_p.v[2].im;
 test_DY1.hPin_P1.v[2].re = z.pin_p.v[2].re;
 test_DY1.hPin_P1.v[3].im = z.pin_p.v[3].im;
 test_DY1.hPin_P1.v[3].re = z.pin_p.v[3].re;
 test_DY1.idealTransformer1.pinP_Prim.iIm[1:3] + test_DY1.idealTransformer2.pinN_Prim.iIm[1:3] - test_DY1.pinPrim_A.iIm[1:3] = zeros(3);
 test_DY1.idealTransformer1.pinP_Prim.iRe[1:3] + test_DY1.idealTransformer2.pinN_Prim.iRe[1:3] - test_DY1.pinPrim_A.iRe[1:3] = zeros(3);
 test_DY1.idealTransformer1.pinP_Prim.v[1].im = test_DY1.idealTransformer2.pinN_Prim.v[1].im;
 test_DY1.idealTransformer2.pinN_Prim.v[1].im = test_DY1.pinPrim_A.v[1].im;
 test_DY1.idealTransformer1.pinP_Prim.v[1].re = test_DY1.idealTransformer2.pinN_Prim.v[1].re;
 test_DY1.idealTransformer2.pinN_Prim.v[1].re = test_DY1.pinPrim_A.v[1].re;
 test_DY1.idealTransformer1.pinP_Prim.v[2].im = test_DY1.idealTransformer2.pinN_Prim.v[2].im;
 test_DY1.idealTransformer2.pinN_Prim.v[2].im = test_DY1.pinPrim_A.v[2].im;
 test_DY1.idealTransformer1.pinP_Prim.v[2].re = test_DY1.idealTransformer2.pinN_Prim.v[2].re;
 test_DY1.idealTransformer2.pinN_Prim.v[2].re = test_DY1.pinPrim_A.v[2].re;
 test_DY1.idealTransformer1.pinP_Prim.v[3].im = test_DY1.idealTransformer2.pinN_Prim.v[3].im;
 test_DY1.idealTransformer2.pinN_Prim.v[3].im = test_DY1.pinPrim_A.v[3].im;
 test_DY1.idealTransformer1.pinP_Prim.v[3].re = test_DY1.idealTransformer2.pinN_Prim.v[3].re;
 test_DY1.idealTransformer2.pinN_Prim.v[3].re = test_DY1.pinPrim_A.v[3].re;
 test_DY1.idealTransformer1.pinN_Prim.iIm[1:3] + test_DY1.idealTransformer3.pinP_Prim.iIm[1:3] - test_DY1.pinPrim_C.iIm[1:3] = zeros(3);
 test_DY1.idealTransformer1.pinN_Prim.iRe[1:3] + test_DY1.idealTransformer3.pinP_Prim.iRe[1:3] - test_DY1.pinPrim_C.iRe[1:3] = zeros(3);
 test_DY1.idealTransformer1.pinN_Prim.v[1].im = test_DY1.idealTransformer3.pinP_Prim.v[1].im;
 test_DY1.idealTransformer3.pinP_Prim.v[1].im = test_DY1.pinPrim_C.v[1].im;
 test_DY1.idealTransformer1.pinN_Prim.v[1].re = test_DY1.idealTransformer3.pinP_Prim.v[1].re;
 test_DY1.idealTransformer3.pinP_Prim.v[1].re = test_DY1.pinPrim_C.v[1].re;
 test_DY1.idealTransformer1.pinN_Prim.v[2].im = test_DY1.idealTransformer3.pinP_Prim.v[2].im;
 test_DY1.idealTransformer3.pinP_Prim.v[2].im = test_DY1.pinPrim_C.v[2].im;
 test_DY1.idealTransformer1.pinN_Prim.v[2].re = test_DY1.idealTransformer3.pinP_Prim.v[2].re;
 test_DY1.idealTransformer3.pinP_Prim.v[2].re = test_DY1.pinPrim_C.v[2].re;
 test_DY1.idealTransformer1.pinN_Prim.v[3].im = test_DY1.idealTransformer3.pinP_Prim.v[3].im;
 test_DY1.idealTransformer3.pinP_Prim.v[3].im = test_DY1.pinPrim_C.v[3].im;
 test_DY1.idealTransformer1.pinN_Prim.v[3].re = test_DY1.idealTransformer3.pinP_Prim.v[3].re;
 test_DY1.idealTransformer3.pinP_Prim.v[3].re = test_DY1.pinPrim_C.v[3].re;
 test_DY1.idealTransformer2.pinP_Prim.iIm[1:3] + test_DY1.idealTransformer3.pinN_Prim.iIm[1:3] - test_DY1.pinPrim_B.iIm[1:3] = zeros(3);
 test_DY1.idealTransformer2.pinP_Prim.iRe[1:3] + test_DY1.idealTransformer3.pinN_Prim.iRe[1:3] - test_DY1.pinPrim_B.iRe[1:3] = zeros(3);
 test_DY1.idealTransformer2.pinP_Prim.v[1].im = test_DY1.idealTransformer3.pinN_Prim.v[1].im;
 test_DY1.idealTransformer3.pinN_Prim.v[1].im = test_DY1.pinPrim_B.v[1].im;
 test_DY1.idealTransformer2.pinP_Prim.v[1].re = test_DY1.idealTransformer3.pinN_Prim.v[1].re;
 test_DY1.idealTransformer3.pinN_Prim.v[1].re = test_DY1.pinPrim_B.v[1].re;
 test_DY1.idealTransformer2.pinP_Prim.v[2].im = test_DY1.idealTransformer3.pinN_Prim.v[2].im;
 test_DY1.idealTransformer3.pinN_Prim.v[2].im = test_DY1.pinPrim_B.v[2].im;
 test_DY1.idealTransformer2.pinP_Prim.v[2].re = test_DY1.idealTransformer3.pinN_Prim.v[2].re;
 test_DY1.idealTransformer3.pinN_Prim.v[2].re = test_DY1.pinPrim_B.v[2].re;
 test_DY1.idealTransformer2.pinP_Prim.v[3].im = test_DY1.idealTransformer3.pinN_Prim.v[3].im;
 test_DY1.idealTransformer3.pinN_Prim.v[3].im = test_DY1.pinPrim_B.v[3].im;
 test_DY1.idealTransformer2.pinP_Prim.v[3].re = test_DY1.idealTransformer3.pinN_Prim.v[3].re;
 test_DY1.idealTransformer3.pinN_Prim.v[3].re = test_DY1.pinPrim_B.v[3].re;
 - test_DY1.hPin_P1.iIm[1:3] + test_DY1.idealTransformer1.pinP_Sec.iIm[1:3] = zeros(3);
 - test_DY1.hPin_P1.iRe[1:3] + test_DY1.idealTransformer1.pinP_Sec.iRe[1:3] = zeros(3);
 test_DY1.hPin_P1.v[1].im = test_DY1.idealTransformer1.pinP_Sec.v[1].im;
 test_DY1.hPin_P1.v[1].re = test_DY1.idealTransformer1.pinP_Sec.v[1].re;
 test_DY1.hPin_P1.v[2].im = test_DY1.idealTransformer1.pinP_Sec.v[2].im;
 test_DY1.hPin_P1.v[2].re = test_DY1.idealTransformer1.pinP_Sec.v[2].re;
 test_DY1.hPin_P1.v[3].im = test_DY1.idealTransformer1.pinP_Sec.v[3].im;
 test_DY1.hPin_P1.v[3].re = test_DY1.idealTransformer1.pinP_Sec.v[3].re;
 - test_DY1.hPin_P2.iIm[1:3] + test_DY1.idealTransformer2.pinP_Sec.iIm[1:3] = zeros(3);
 - test_DY1.hPin_P2.iRe[1:3] + test_DY1.idealTransformer2.pinP_Sec.iRe[1:3] = zeros(3);
 test_DY1.hPin_P2.v[1].im = test_DY1.idealTransformer2.pinP_Sec.v[1].im;
 test_DY1.hPin_P2.v[1].re = test_DY1.idealTransformer2.pinP_Sec.v[1].re;
 test_DY1.hPin_P2.v[2].im = test_DY1.idealTransformer2.pinP_Sec.v[2].im;
 test_DY1.hPin_P2.v[2].re = test_DY1.idealTransformer2.pinP_Sec.v[2].re;
 test_DY1.hPin_P2.v[3].im = test_DY1.idealTransformer2.pinP_Sec.v[3].im;
 test_DY1.hPin_P2.v[3].re = test_DY1.idealTransformer2.pinP_Sec.v[3].re;
 - test_DY1.hPin_P3.iIm[1:3] + test_DY1.idealTransformer3.pinP_Sec.iIm[1:3] = zeros(3);
 - test_DY1.hPin_P3.iRe[1:3] + test_DY1.idealTransformer3.pinP_Sec.iRe[1:3] = zeros(3);
 test_DY1.hPin_P3.v[1].im = test_DY1.idealTransformer3.pinP_Sec.v[1].im;
 test_DY1.hPin_P3.v[1].re = test_DY1.idealTransformer3.pinP_Sec.v[1].re;
 test_DY1.hPin_P3.v[2].im = test_DY1.idealTransformer3.pinP_Sec.v[2].im;
 test_DY1.hPin_P3.v[2].re = test_DY1.idealTransformer3.pinP_Sec.v[2].re;
 test_DY1.hPin_P3.v[3].im = test_DY1.idealTransformer3.pinP_Sec.v[3].im;
 test_DY1.hPin_P3.v[3].re = test_DY1.idealTransformer3.pinP_Sec.v[3].re;
 - test_DY1.hPin_N.iIm[1:3] + test_DY1.idealTransformer1.pinN_Sec.iIm[1:3] + test_DY1.idealTransformer2.pinN_Sec.iIm[1:3] + test_DY1.idealTransformer3.pinN_Sec.iIm[1:3] = zeros(3);
 - test_DY1.hPin_N.iRe[1:3] + test_DY1.idealTransformer1.pinN_Sec.iRe[1:3] + test_DY1.idealTransformer2.pinN_Sec.iRe[1:3] + test_DY1.idealTransformer3.pinN_Sec.iRe[1:3] = zeros(3);
 test_DY1.hPin_N.v[1].im = test_DY1.idealTransformer1.pinN_Sec.v[1].im;
 test_DY1.idealTransformer1.pinN_Sec.v[1].im = test_DY1.idealTransformer2.pinN_Sec.v[1].im;
 test_DY1.idealTransformer2.pinN_Sec.v[1].im = test_DY1.idealTransformer3.pinN_Sec.v[1].im;
 test_DY1.hPin_N.v[1].re = test_DY1.idealTransformer1.pinN_Sec.v[1].re;
 test_DY1.idealTransformer1.pinN_Sec.v[1].re = test_DY1.idealTransformer2.pinN_Sec.v[1].re;
 test_DY1.idealTransformer2.pinN_Sec.v[1].re = test_DY1.idealTransformer3.pinN_Sec.v[1].re;
 test_DY1.hPin_N.v[2].im = test_DY1.idealTransformer1.pinN_Sec.v[2].im;
 test_DY1.idealTransformer1.pinN_Sec.v[2].im = test_DY1.idealTransformer2.pinN_Sec.v[2].im;
 test_DY1.idealTransformer2.pinN_Sec.v[2].im = test_DY1.idealTransformer3.pinN_Sec.v[2].im;
 test_DY1.hPin_N.v[2].re = test_DY1.idealTransformer1.pinN_Sec.v[2].re;
 test_DY1.idealTransformer1.pinN_Sec.v[2].re = test_DY1.idealTransformer2.pinN_Sec.v[2].re;
 test_DY1.idealTransformer2.pinN_Sec.v[2].re = test_DY1.idealTransformer3.pinN_Sec.v[2].re;
 test_DY1.hPin_N.v[3].im = test_DY1.idealTransformer1.pinN_Sec.v[3].im;
 test_DY1.idealTransformer1.pinN_Sec.v[3].im = test_DY1.idealTransformer2.pinN_Sec.v[3].im;
 test_DY1.idealTransformer2.pinN_Sec.v[3].im = test_DY1.idealTransformer3.pinN_Sec.v[3].im;
 test_DY1.hPin_N.v[3].re = test_DY1.idealTransformer1.pinN_Sec.v[3].re;
 test_DY1.idealTransformer1.pinN_Sec.v[3].re = test_DY1.idealTransformer2.pinN_Sec.v[3].re;
 test_DY1.idealTransformer2.pinN_Sec.v[3].re = test_DY1.idealTransformer3.pinN_Sec.v[3].re;
 PhA.pin_p.reference.theta = test_DY1.pinPrim_A.reference.theta;
 test_DY1.idealTransformer1.pinP_Prim.reference.theta = test_DY1.idealTransformer2.pinN_Prim.reference.theta;
 test_DY1.idealTransformer2.pinN_Prim.reference.theta = test_DY1.pinPrim_A.reference.theta;
 PhA.pin_n.reference.theta = ground.pin.reference.theta;
 test_DY1.idealTransformer1.pinN_Prim.reference.theta = test_DY1.idealTransformer3.pinP_Prim.reference.theta;
 test_DY1.idealTransformer3.pinP_Prim.reference.theta = test_DY1.pinPrim_C.reference.theta;
 test_DY1.hPin_N.reference.theta = test_DY1.idealTransformer1.pinN_Sec.reference.theta;
 test_DY1.hPin_P1.reference.theta = test_DY1.idealTransformer1.pinP_Sec.reference.theta;
 test_DY1.idealTransformer2.pinP_Prim.reference.theta = test_DY1.pinPrim_B.reference.theta;
 test_DY1.hPin_P2.reference.theta = test_DY1.idealTransformer2.pinP_Sec.reference.theta;
 test_DY1.hPin_P3.reference.theta = test_DY1.idealTransformer3.pinP_Sec.reference.theta;
 ground1.pin.reference.theta = test_DY1.hPin_N.reference.theta;
 test_DY1.hPin_P1.reference.theta = z.pin_p.reference.theta;
 r1.pin_p.reference.theta = test_DY1.hPin_P2.reference.theta;
 r2.pin_p.reference.theta = test_DY1.hPin_P3.reference.theta;
 HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(test_DY1.idealTransformer2.pinN_Sec.reference, test_DY1.idealTransformer1.pinN_Sec.reference);
 HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(test_DY1.idealTransformer3.pinN_Sec.reference, test_DY1.idealTransformer1.pinN_Sec.reference);
 HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(PhC.pin_n.reference, ground.pin.reference);
 HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(PhB.pin_n.reference, ground.pin.reference);
 HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(test_DY1.idealTransformer3.pinN_Prim.reference, test_DY1.idealTransformer2.pinP_Prim.reference);
 HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(PhB.pin_p.reference, test_DY1.pinPrim_B.reference);
 HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(test_DY1.pinPrim_C.reference, PhC.pin_p.reference);
 HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(r2.pin_n.reference, ground1.pin.reference);
 HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(r1.pin_n.reference, ground1.pin.reference);
 HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(z.pin_n.reference, ground1.pin.reference);

public
 function Modelica.SIunits.Conversions.from_deg
  input Real degree;
  output Real radian;
 algorithm
  radian := 3.141592653589793 / 180.0 * degree;
  return;
 annotation(Inline = true);
 end Modelica.SIunits.Conversions.from_deg;

 function Modelica.ComplexMath.'abs'
  input Complex c;
  output Real result;
 algorithm
  result := (c.re ^ 2 + c.im ^ 2) ^ 0.5;
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.'abs';

 function Modelica.ComplexMath.arg
  input Complex c;
  input Real phi0;
  output Real phi;
 algorithm
  phi := Modelica.Math.atan3(c.im, c.re, phi0);
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.arg;

 function Modelica.Math.atan3
  input Real u1;
  input Real u2;
  input Real y0;
  output Real y;
  Real w;
 algorithm
  w := atan2(u1, u2);
  if y0 == 0 then
   y := w;
  else
   y := w + 6.283185307179586 * integer((3.141592653589793 + y0 - w) / 6.283185307179586);
  end if;
  return;
 end Modelica.Math.atan3;

 function Complex.'*'.multiply
  input Complex c1;
  input Complex c2;
  output Complex c3;
 algorithm
  (c3) := Complex.'constructor'.fromReal(c1.re * c2.re - c1.im * c2.im, c1.re * c2.im + c1.im * c2.re);
  return;
 annotation(Inline = true);
 end Complex.'*'.multiply;

 function Complex.'constructor'.fromReal
  input Real re;
  input Real im;
  output Complex result;
 algorithm
  result.re := re;
  result.im := im;
  return;
 annotation(Inline = true);
 end Complex.'constructor'.fromReal;

 function Complex.'-'.subtract
  input Complex c1;
  input Complex c2;
  output Complex c3;
 algorithm
  (c3) := Complex.'constructor'.fromReal(c1.re - c2.re, c1.im - c2.im);
  return;
 annotation(Inline = true);
 end Complex.'-'.subtract;

 function HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint;

 record Complex
  Real re "Real part of complex number";
  Real im "Imaginary part of complex number";
 end Complex;

 record HPF.Types.Reference
  Modelica.SIunits.Angle theta;
 end HPF.Types.Reference;

 type Modelica.SIunits.Angle = Real(final quantity = "Angle",final unit = "rad",displayUnit = "deg");
end HPF.Test.Multiphase_Transformer;

Applying transformation: enableIfEquationElimination...
Applying transformation: genInitArrayStatements...
Applying transformation: scalarize...
Applying transformation: MakeReinitedVarsStates...
Applying transformation: enableIfEquationElimination...
Applying transformation: enableStreamsRewrite...
Applying transformation: ExtractEventGeneratingExpressions...
Applying transformation: GenerateEventIndicators...
Applying transformation: convertWhenToIf...
Applying transformation: FunctionInliningIfSet...
Applying transformation: setFDerivativeVariables...
Applying transformation: addFPreVariables...
Applying transformation: enableIfEquationRewrite...
Applying transformation: aliasEliminationIfSet...
Applying transformation: variabilityPropagationIfSet...
Applying transformation: aliasEliminationIfSet...
Applying transformation: eliminateLinearEquations...
Applying transformation: aliasEliminationIfSet...
Applying transformation: enableExpandedInStreamRewrite...
Applying transformation: evaluateAsserts...
Applying transformation: enableSemiLinearRewrite...
Applying transformation: eliminateEqualSwitches...
Applying transformation: genInitialEquations...
Applying transformation: setFDerivativeVariablesPreBLT...
Applying transformation: indexReduction...
Applying transformation: LateFunctionInliningIfSet...
Applying transformation: commonSubexpressionEliminationIfSet...
Applying transformation: addFPreVariables...
Applying transformation: aliasEliminationIfSet...
Applying transformation: eliminateLinearEquations...
Applying transformation: sortDependentParameters...
Applying transformation: addRuntimeOptionParameters...
Applying transformation: computeMatchingsAndBLT...
Flat tree before matching and BLT:
fclass HPF.Test.Multiphase_Transformer
 parameter Integer systemDef.hrms[1] = 1 "Harmonics to simulate" /* 1 */;
 parameter Integer systemDef.hrms[2] = 3 "Harmonics to simulate" /* 3 */;
 parameter Integer systemDef.hrms[3] = 5 "Harmonics to simulate" /* 5 */;
 structural parameter Integer systemDef.numHrm = 3 "Number of harmonics. (Automatically generated from hrms. Do not alter)" /* 3 */;
 parameter Integer systemDef.numHigherHrm = 2 /* 2 */;
 parameter Integer systemDef.numPh = 3 "Number of phases" /* 3 */;
 parameter Real systemDef.fFund = 60 "Fundamental frequency" /* 60 */;
 discrete Boolean systemDef.modeSelect(start = true);
 discrete Boolean systemDef.event1(start = false);
 discrete Boolean systemDef.event2(start = false);
 parameter Integer test_DY1.N = 4 "Turns ration" /* 4 */;
 parameter Real test_DY1.idealTransformer1.N "Turns ratio N1:N2 = N:1 (Subject to review!)";
 parameter Real test_DY1.idealTransformer2.N "Turns ratio N1:N2 = N:1 (Subject to review!)";
 parameter Real test_DY1.idealTransformer3.N "Turns ratio N1:N2 = N:1 (Subject to review!)";
 parameter Real PhA.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhA.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhA.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhA.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real test_DY1.idealTransformer1.iPrim[1].re "Real part of complex number";
 Real test_DY1.idealTransformer1.iPrim[1].im "Imaginary part of complex number";
 Real test_DY1.idealTransformer1.iPrim[2].re "Real part of complex number";
 Real test_DY1.idealTransformer1.iPrim[2].im "Imaginary part of complex number";
 Real test_DY1.idealTransformer1.iPrim[3].re "Real part of complex number";
 Real test_DY1.idealTransformer1.iPrim[3].im "Imaginary part of complex number";
 parameter Real PhA.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhA.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhB.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhB.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhB.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhC.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhC.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhC.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhC.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhC.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhC.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real temp_74;
 parameter Real temp_89;
 parameter Real temp_104;
 parameter Real temp_224;
 parameter Real temp_239;
 parameter Real temp_254;
 parameter Real temp_374;
 parameter Real temp_389;
 parameter Real temp_404;
 parameter Real test_DY1.idealTransformer2.vPrim[1].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer2.vPrim[2].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer2.vPrim[3].re "Real part of complex number";
 Real test_DY1.hPin_N.iIm[1];
 Real test_DY1.hPin_N.iIm[2];
 Real test_DY1.hPin_N.iIm[3];
 Real test_DY1.hPin_N.iRe[1];
 Real test_DY1.hPin_N.iRe[2];
 Real test_DY1.hPin_N.iRe[3];
 parameter Real PhA.vMag[1] = 392 "Voltage Magnitude" /* 392 */;
 parameter Real PhA.vMag[2] = 10 "Voltage Magnitude" /* 10 */;
 parameter Real PhA.vMag[3] = 3 "Voltage Magnitude" /* 3 */;
 parameter Real PhA.vArg[1] = 0 "Voltage angle" /* 0 */;
 parameter Real PhA.vArg[2] = 0.5 "Voltage angle" /* 0.5 */;
 parameter Real PhA.vArg[3] = 2.3 "Voltage angle" /* 2.3 */;
 Modelica.SIunits.Angle PhA.theta(start = 0);
 parameter Real test_DY1.idealTransformer2.vPrim[1].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer2.vPrim[2].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer2.vPrim[3].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[1].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer3.vPrim[1].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[2].re "Real part of complex number";
 Real PhA.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhA.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhA.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhA.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhA.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhA.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhA.omega;
 constant Real PhA.pin_n.v[1].re = 0.0 "Real part of complex number";
 constant Real PhA.pin_n.v[1].im = 0 "Imaginary part of complex number";
 parameter Real PhB.vMag[1] = 392 "Voltage Magnitude" /* 392 */;
 parameter Real PhB.vMag[2] = 11 "Voltage Magnitude" /* 11 */;
 parameter Real PhB.vMag[3] = 2.6 "Voltage Magnitude" /* 2.6 */;
 parameter Real PhB.vArg[1] = -2.0943951023931953 "Voltage angle" /* -2.0943951023931953 */;
 parameter Real PhB.vArg[2] = 0 "Voltage angle" /* 0 */;
 parameter Real PhB.vArg[3] = 1.2 "Voltage angle" /* 1.2 */;
 Modelica.SIunits.Angle PhB.theta(start = 0);
 parameter Real test_DY1.idealTransformer3.vPrim[2].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[3].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer3.vPrim[3].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[1].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.vPrim[1].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[2].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.vPrim[2].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[3].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.vPrim[3].im "Imaginary part of complex number";
 parameter Real r1.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r1.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r1.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhB.omega;
 parameter Real PhC.vMag[1] = 392 "Voltage Magnitude" /* 392 */;
 parameter Real PhC.vMag[2] = 10 "Voltage Magnitude" /* 10 */;
 parameter Real PhC.vMag[3] = 3 "Voltage Magnitude" /* 3 */;
 parameter Real PhC.vArg[1] = 2.0943951023931953 "Voltage angle" /* 2.0943951023931953 */;
 parameter Real PhC.vArg[2] = 0.6 "Voltage angle" /* 0.6 */;
 parameter Real PhC.vArg[3] = 2.1 "Voltage angle" /* 2.1 */;
 Modelica.SIunits.Angle PhC.theta(start = 0);
 parameter Real r1.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r1.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r1.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real z.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r2.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real z.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhC.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhC.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhC.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhC.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhC.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhC.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhC.omega;
 Real ground.pin.iIm[1];
 Real ground.pin.iIm[2];
 Real ground.pin.iIm[3];
 Real ground.pin.iRe[1];
 Real ground.pin.iRe[2];
 Real ground.pin.iRe[3];
 Real ground1.pin.iIm[1];
 Real ground1.pin.iIm[2];
 Real ground1.pin.iIm[3];
 Real ground1.pin.iRe[1];
 Real ground1.pin.iRe[2];
 Real ground1.pin.iRe[3];
 parameter Real r1.r(start = 1) = 500 "Resistance (ohm)" /* 500 */;
 parameter Real r2.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real z.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r2.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real z.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real z.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real z.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r1.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r1.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r1.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r1.vFundAbs;
 parameter Real r1.vFundArg;
 parameter Real r1.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r1.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real r1.omega;
 parameter Real r2.r(start = 1) = 500 "Resistance (ohm)" /* 500 */;
 parameter Real r1.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r2.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r2.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real z.vFundAbs;
 parameter Real z.vFundArg;
 parameter Real r2.vFundAbs;
 parameter Real r2.vFundArg;
 parameter Real r2.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer2.iPrim[1].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer2.iPrim[2].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer2.iPrim[3].re "Real part of complex number";
 parameter Real r1.iFundAbs;
 parameter Real r1.iFundArg;
 Real r2.omega;
 parameter Real z.z.re(start = 1) = 500 "Real part of complex number" /* 500 */;
 parameter Real z.z.im(start = 0) = 20 "Imaginary part of complex number" /* 20 */;
 parameter Real test_DY1.idealTransformer2.iPrim[1].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer2.iPrim[2].im "Imaginary part of complex number";
 Real z.iFundAbs;
 Real z.iFundArg;
 parameter Real test_DY1.idealTransformer2.iPrim[3].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.iPrim[1].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer3.iPrim[2].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer3.iPrim[3].re "Real part of complex number";
 parameter Real r2.iFundAbs;
 parameter Real r2.iFundArg;
 Real z.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 Real z.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real z.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 Real z.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real z.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 Real z.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real z.omega;
 discrete Boolean temp_62;
 discrete Boolean temp_63;
 discrete Boolean temp_64;
 parameter Real test_DY1.idealTransformer3.iPrim[1].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.iPrim[2].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.iPrim[3].im "Imaginary part of complex number";
 parameter Real PhB.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhB.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhB.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
initial equation
 algorithm
  systemDef.modeSelect := false;
;
parameter equation
 test_DY1.idealTransformer1.N = test_DY1.N;
 test_DY1.idealTransformer2.N = test_DY1.N;
 test_DY1.idealTransformer3.N = test_DY1.N;
 PhA.v[1].re = PhA.vMag[1] .* cos(PhA.vArg[1]);
 PhA.v[2].re = PhA.vMag[2] .* cos(PhA.vArg[2]);
 PhA.v[3].re = PhA.vMag[3] .* cos(PhA.vArg[3]);
 PhA.v[1].im = PhA.vMag[1] .* sin(PhA.vArg[1]);
 PhA.v[2].im = PhA.vMag[2] .* sin(PhA.vArg[2]);
 PhA.v[3].im = PhA.vMag[3] .* sin(PhA.vArg[3]);
 PhB.v[1].re = PhB.vMag[1] .* cos(PhB.vArg[1]);
 PhB.v[2].re = PhB.vMag[2] .* cos(PhB.vArg[2]);
 PhB.v[3].re = PhB.vMag[3] .* cos(PhB.vArg[3]);
 PhB.v[1].im = PhB.vMag[1] .* sin(PhB.vArg[1]);
 PhB.v[2].im = PhB.vMag[2] .* sin(PhB.vArg[2]);
 PhB.v[3].im = PhB.vMag[3] .* sin(PhB.vArg[3]);
 PhC.v[1].re = PhC.vMag[1] .* cos(PhC.vArg[1]);
 PhC.v[2].re = PhC.vMag[2] .* cos(PhC.vArg[2]);
 PhC.v[3].re = PhC.vMag[3] .* cos(PhC.vArg[3]);
 PhC.v[1].im = PhC.vMag[1] .* sin(PhC.vArg[1]);
 PhC.v[2].im = PhC.vMag[2] .* sin(PhC.vArg[2]);
 PhC.v[3].im = PhC.vMag[3] .* sin(PhC.vArg[3]);
 temp_74 = 1 / test_DY1.idealTransformer1.N;
 temp_89 = 1 / test_DY1.idealTransformer1.N;
 temp_104 = 1 / test_DY1.idealTransformer1.N;
 temp_224 = 1 / test_DY1.idealTransformer2.N;
 temp_239 = 1 / test_DY1.idealTransformer2.N;
 temp_254 = 1 / test_DY1.idealTransformer2.N;
 temp_374 = 1 / test_DY1.idealTransformer3.N;
 temp_389 = 1 / test_DY1.idealTransformer3.N;
 temp_404 = 1 / test_DY1.idealTransformer3.N;
 test_DY1.idealTransformer2.vPrim[1].re = PhB.v[1].re + (- PhA.v[1].re);
 test_DY1.idealTransformer2.vPrim[2].re = PhB.v[2].re + (- PhA.v[2].re);
 test_DY1.idealTransformer2.vPrim[3].re = PhB.v[3].re + (- PhA.v[3].re);
 test_DY1.idealTransformer2.vPrim[1].im = PhB.v[1].im + (- PhA.v[1].im);
 test_DY1.idealTransformer2.vPrim[2].im = PhB.v[2].im + (- PhA.v[2].im);
 test_DY1.idealTransformer2.vPrim[3].im = PhB.v[3].im + (- PhA.v[3].im);
 test_DY1.idealTransformer1.vPrim[1].re = PhA.v[1].re + (- PhC.v[1].re);
 test_DY1.idealTransformer3.vPrim[1].re = PhC.v[1].re + (- PhB.v[1].re);
 test_DY1.idealTransformer1.vPrim[2].re = PhA.v[2].re + (- PhC.v[2].re);
 test_DY1.idealTransformer3.vPrim[2].re = PhC.v[2].re + (- PhB.v[2].re);
 test_DY1.idealTransformer1.vPrim[3].re = PhA.v[3].re + (- PhC.v[3].re);
 test_DY1.idealTransformer3.vPrim[3].re = PhC.v[3].re + (- PhB.v[3].re);
 test_DY1.idealTransformer1.vPrim[1].im = PhA.v[1].im + (- PhC.v[1].im);
 test_DY1.idealTransformer3.vPrim[1].im = PhC.v[1].im + (- PhB.v[1].im);
 test_DY1.idealTransformer1.vPrim[2].im = PhA.v[2].im + (- PhC.v[2].im);
 test_DY1.idealTransformer3.vPrim[2].im = PhC.v[2].im + (- PhB.v[2].im);
 test_DY1.idealTransformer1.vPrim[3].im = PhA.v[3].im + (- PhC.v[3].im);
 test_DY1.idealTransformer3.vPrim[3].im = PhC.v[3].im + (- PhB.v[3].im);
 r1.v[1].re = temp_224 * test_DY1.idealTransformer2.vPrim[1].re;
 r1.v[2].re = temp_239 * test_DY1.idealTransformer2.vPrim[2].re;
 r1.v[3].re = temp_254 * test_DY1.idealTransformer2.vPrim[3].re;
 r1.v[1].im = temp_224 * test_DY1.idealTransformer2.vPrim[1].im;
 r1.v[2].im = temp_239 * test_DY1.idealTransformer2.vPrim[2].im;
 r1.v[3].im = temp_254 * test_DY1.idealTransformer2.vPrim[3].im;
 z.v[1].re = temp_74 * test_DY1.idealTransformer1.vPrim[1].re;
 r2.v[1].re = temp_374 * test_DY1.idealTransformer3.vPrim[1].re;
 z.v[2].re = temp_89 * test_DY1.idealTransformer1.vPrim[2].re;
 r2.v[2].re = temp_389 * test_DY1.idealTransformer3.vPrim[2].re;
 z.v[3].re = temp_104 * test_DY1.idealTransformer1.vPrim[3].re;
 r2.v[3].re = temp_404 * test_DY1.idealTransformer3.vPrim[3].re;
 z.v[1].im = temp_74 * test_DY1.idealTransformer1.vPrim[1].im;
 r2.v[1].im = temp_374 * test_DY1.idealTransformer3.vPrim[1].im;
 z.v[2].im = temp_89 * test_DY1.idealTransformer1.vPrim[2].im;
 r2.v[2].im = temp_389 * test_DY1.idealTransformer3.vPrim[2].im;
 z.v[3].im = temp_104 * test_DY1.idealTransformer1.vPrim[3].im;
 r2.v[3].im = temp_404 * test_DY1.idealTransformer3.vPrim[3].im;
 r1.i[1].re = (- r1.v[1].re) / (- r1.r);
 r1.i[2].re = (- r1.v[2].re) / (- r1.r);
 r1.i[3].re = (- r1.v[3].re) / (- r1.r);
 r1.vFundAbs = (r1.v[1].re ^ 2 + r1.v[1].im ^ 2) ^ 0.5;
 r1.vFundArg = Modelica.Math.atan3(r1.v[1].im, r1.v[1].re, 0);
 r1.i[1].im = (- r1.v[1].im) / (- r1.r);
 r1.i[2].im = (- r1.v[2].im) / (- r1.r);
 r1.i[3].im = (- r1.v[3].im) / (- r1.r);
 r2.i[1].re = (- r2.v[1].re) / (- r2.r);
 r2.i[2].re = (- r2.v[2].re) / (- r2.r);
 r2.i[3].re = (- r2.v[3].re) / (- r2.r);
 z.vFundAbs = (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5;
 z.vFundArg = Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0);
 r2.vFundAbs = (r2.v[1].re ^ 2 + r2.v[1].im ^ 2) ^ 0.5;
 r2.vFundArg = Modelica.Math.atan3(r2.v[1].im, r2.v[1].re, 0);
 r2.i[1].im = (- r2.v[1].im) / (- r2.r);
 r2.i[2].im = (- r2.v[2].im) / (- r2.r);
 r2.i[3].im = (- r2.v[3].im) / (- r2.r);
 test_DY1.idealTransformer2.iPrim[1].re = r1.i[1].re / (- test_DY1.idealTransformer2.N);
 test_DY1.idealTransformer2.iPrim[2].re = r1.i[2].re / (- test_DY1.idealTransformer2.N);
 test_DY1.idealTransformer2.iPrim[3].re = r1.i[3].re / (- test_DY1.idealTransformer2.N);
 r1.iFundAbs = (r1.i[1].re ^ 2 + r1.i[1].im ^ 2) ^ 0.5;
 r1.iFundArg = Modelica.Math.atan3(r1.i[1].im, r1.i[1].re, 0);
 test_DY1.idealTransformer2.iPrim[1].im = r1.i[1].im / (- test_DY1.idealTransformer2.N);
 test_DY1.idealTransformer2.iPrim[2].im = r1.i[2].im / (- test_DY1.idealTransformer2.N);
 test_DY1.idealTransformer2.iPrim[3].im = r1.i[3].im / (- test_DY1.idealTransformer2.N);
 test_DY1.idealTransformer3.iPrim[1].re = r2.i[1].re / (- test_DY1.idealTransformer3.N);
 test_DY1.idealTransformer3.iPrim[2].re = r2.i[2].re / (- test_DY1.idealTransformer3.N);
 test_DY1.idealTransformer3.iPrim[3].re = r2.i[3].re / (- test_DY1.idealTransformer3.N);
 r2.iFundAbs = (r2.i[1].re ^ 2 + r2.i[1].im ^ 2) ^ 0.5;
 r2.iFundArg = Modelica.Math.atan3(r2.i[1].im, r2.i[1].re, 0);
 test_DY1.idealTransformer3.iPrim[1].im = r2.i[1].im / (- test_DY1.idealTransformer3.N);
 test_DY1.idealTransformer3.iPrim[2].im = r2.i[2].im / (- test_DY1.idealTransformer3.N);
 test_DY1.idealTransformer3.iPrim[3].im = r2.i[3].im / (- test_DY1.idealTransformer3.N);
 PhB.i[1].re = - test_DY1.idealTransformer2.iPrim[1].re + test_DY1.idealTransformer3.iPrim[1].re;
 PhB.i[2].re = - test_DY1.idealTransformer2.iPrim[2].re + test_DY1.idealTransformer3.iPrim[2].re;
 PhB.i[3].re = - test_DY1.idealTransformer2.iPrim[3].re + test_DY1.idealTransformer3.iPrim[3].re;
 PhB.i[1].im = - test_DY1.idealTransformer2.iPrim[1].im + test_DY1.idealTransformer3.iPrim[1].im;
 PhB.i[2].im = - test_DY1.idealTransformer2.iPrim[2].im + test_DY1.idealTransformer3.iPrim[2].im;
 PhB.i[3].im = - test_DY1.idealTransformer2.iPrim[3].im + test_DY1.idealTransformer3.iPrim[3].im;
equation
 temp_62 = time > 0.5;
 temp_63 = time > 0.25;
 temp_64 = time > 0.4;
algorithm
 if temp_62 and not pre(temp_62) then
  systemDef.modeSelect := true;
 end if;
 if temp_63 and not pre(temp_63) then
  systemDef.event1 := true;
 end if;
 if temp_64 and not pre(temp_64) then
  systemDef.event2 := true;
 end if;
equation
 - z.i[1].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].re;
 - z.i[1].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].im;
 - z.i[2].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].re;
 - z.i[2].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].im;
 - z.i[3].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].re;
 - z.i[3].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].im;
 der(PhA.theta) = 6.283185307179586 * systemDef.fFund;
 PhA.omega = der(PhA.theta);
 der(PhB.theta) = 6.283185307179586 * systemDef.fFund;
 PhB.omega = der(PhB.theta);
 der(PhC.theta) = 6.283185307179586 * systemDef.fFund;
 PhC.omega = der(PhC.theta);
 r1.omega = der(PhA.theta);
 r2.omega = der(PhA.theta);
 z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im;
 z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im;
 z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im;
 z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re;
 z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re;
 z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re;
 z.omega = der(PhA.theta);
 ground1.pin.iIm[1] + (- r1.i[1].im) + (- r2.i[1].im) + test_DY1.hPin_N.iIm[1] + (- z.i[1].im) = 0;
 ground1.pin.iIm[2] + (- r1.i[2].im) + (- r2.i[2].im) + test_DY1.hPin_N.iIm[2] + (- z.i[2].im) = 0;
 ground1.pin.iIm[3] + (- r1.i[3].im) + (- r2.i[3].im) + test_DY1.hPin_N.iIm[3] + (- z.i[3].im) = 0;
 ground1.pin.iRe[1] + (- r1.i[1].re) + (- r2.i[1].re) + test_DY1.hPin_N.iRe[1] + (- z.i[1].re) = 0;
 ground1.pin.iRe[2] + (- r1.i[2].re) + (- r2.i[2].re) + test_DY1.hPin_N.iRe[2] + (- z.i[2].re) = 0;
 ground1.pin.iRe[3] + (- r1.i[3].re) + (- r2.i[3].re) + test_DY1.hPin_N.iRe[3] + (- z.i[3].re) = 0;
 - PhA.i[1].im + (- PhB.i[1].im) + (- PhC.i[1].im) + ground.pin.iIm[1] = 0;
 - PhA.i[2].im + (- PhB.i[2].im) + (- PhC.i[2].im) + ground.pin.iIm[2] = 0;
 - PhA.i[3].im + (- PhB.i[3].im) + (- PhC.i[3].im) + ground.pin.iIm[3] = 0;
 - PhA.i[1].re + (- PhB.i[1].re) + (- PhC.i[1].re) + ground.pin.iRe[1] = 0;
 - PhA.i[2].re + (- PhB.i[2].re) + (- PhC.i[2].re) + ground.pin.iRe[2] = 0;
 - PhA.i[3].re + (- PhB.i[3].re) + (- PhC.i[3].re) + ground.pin.iRe[3] = 0;
 test_DY1.idealTransformer1.iPrim[1].im + (- test_DY1.idealTransformer2.iPrim[1].im) + PhA.i[1].im = 0;
 test_DY1.idealTransformer1.iPrim[2].im + (- test_DY1.idealTransformer2.iPrim[2].im) + PhA.i[2].im = 0;
 test_DY1.idealTransformer1.iPrim[3].im + (- test_DY1.idealTransformer2.iPrim[3].im) + PhA.i[3].im = 0;
 test_DY1.idealTransformer1.iPrim[1].re + (- test_DY1.idealTransformer2.iPrim[1].re) + PhA.i[1].re = 0;
 test_DY1.idealTransformer1.iPrim[2].re + (- test_DY1.idealTransformer2.iPrim[2].re) + PhA.i[2].re = 0;
 test_DY1.idealTransformer1.iPrim[3].re + (- test_DY1.idealTransformer2.iPrim[3].re) + PhA.i[3].re = 0;
 - test_DY1.idealTransformer1.iPrim[1].im + test_DY1.idealTransformer3.iPrim[1].im + PhC.i[1].im = 0;
 - test_DY1.idealTransformer1.iPrim[2].im + test_DY1.idealTransformer3.iPrim[2].im + PhC.i[2].im = 0;
 - test_DY1.idealTransformer1.iPrim[3].im + test_DY1.idealTransformer3.iPrim[3].im + PhC.i[3].im = 0;
 - test_DY1.idealTransformer1.iPrim[1].re + test_DY1.idealTransformer3.iPrim[1].re + PhC.i[1].re = 0;
 - test_DY1.idealTransformer1.iPrim[2].re + test_DY1.idealTransformer3.iPrim[2].re + PhC.i[2].re = 0;
 - test_DY1.idealTransformer1.iPrim[3].re + test_DY1.idealTransformer3.iPrim[3].re + PhC.i[3].re = 0;
 0 = ground1.pin.iIm[1];
 0 = ground1.pin.iIm[2];
 0 = ground1.pin.iIm[3];
 0 = ground1.pin.iRe[1];
 0 = ground1.pin.iRe[2];
 0 = ground1.pin.iRe[3];
 HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhC.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhC.theta));
 HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 z.iFundAbs = (z.i[1].re ^ 2 + z.i[1].im ^ 2) ^ 0.5;
 z.iFundArg = Modelica.Math.atan3(z.i[1].im, z.i[1].re, 0);

public
 function Modelica.SIunits.Conversions.from_deg
  input Real degree;
  output Real radian;
 algorithm
  radian := 3.141592653589793 / 180.0 * degree;
  return;
 annotation(Inline = true);
 end Modelica.SIunits.Conversions.from_deg;

 function Modelica.ComplexMath.'abs'
  input Complex c;
  output Real result;
 algorithm
  result := (c.re ^ 2 + c.im ^ 2) ^ 0.5;
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.'abs';

 function Modelica.ComplexMath.arg
  input Complex c;
  input Real phi0;
  output Real phi;
 algorithm
  phi := Modelica.Math.atan3(c.im, c.re, phi0);
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.arg;

 function Modelica.Math.atan3
  input Real u1;
  input Real u2;
  input Real y0;
  output Real y;
  Real w;
 algorithm
  w := atan2(u1, u2);
  if y0 == 0 then
   y := w;
  else
   y := w + 6.283185307179586 * integer((3.141592653589793 + y0 - w) / 6.283185307179586);
  end if;
  return;
 end Modelica.Math.atan3;

 function Complex.'*'.multiply
  input Complex c1;
  input Complex c2;
  output Complex c3;
 algorithm
  (c3) := Complex.'constructor'.fromReal(c1.re * c2.re - c1.im * c2.im, c1.re * c2.im + c1.im * c2.re);
  return;
 annotation(Inline = true);
 end Complex.'*'.multiply;

 function Complex.'constructor'.fromReal
  input Real re;
  input Real im;
  output Complex result;
 algorithm
  result.re := re;
  result.im := im;
  return;
 annotation(Inline = true);
 end Complex.'constructor'.fromReal;

 function Complex.'-'.subtract
  input Complex c1;
  input Complex c2;
  output Complex c3;
 algorithm
  (c3) := Complex.'constructor'.fromReal(c1.re - c2.re, c1.im - c2.im);
  return;
 annotation(Inline = true);
 end Complex.'-'.subtract;

 function HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint;

 record Complex
  Real re "Real part of complex number";
  Real im "Imaginary part of complex number";
 end Complex;

 record HPF.Types.Reference
  Modelica.SIunits.Angle theta;
 end HPF.Types.Reference;

 type Modelica.SIunits.Angle = Real(final quantity = "Angle",final unit = "rad",displayUnit = "deg");
end HPF.Test.Multiphase_Transformer;

DAE BiPGraph
BiPGraph (69 equations, 59 variables)
Variables: {der(PhA.theta) der(PhB.theta) der(PhC.theta) test_DY1.idealTransformer1.iPrim[1].re test_DY1.idealTransformer1.iPrim[1].im test_DY1.idealTransformer1.iPrim[2].re test_DY1.idealTransformer1.iPrim[2].im test_DY1.idealTransformer1.iPrim[3].re test_DY1.idealTransformer1.iPrim[3].im test_DY1.hPin_N.iIm[1] test_DY1.hPin_N.iIm[2] test_DY1.hPin_N.iIm[3] test_DY1.hPin_N.iRe[1] test_DY1.hPin_N.iRe[2] test_DY1.hPin_N.iRe[3] PhA.i[1].re PhA.i[1].im PhA.i[2].re PhA.i[2].im PhA.i[3].re PhA.i[3].im PhA.omega PhB.omega PhC.i[1].re PhC.i[1].im PhC.i[2].re PhC.i[2].im PhC.i[3].re PhC.i[3].im PhC.omega ground.pin.iIm[1] ground.pin.iIm[2] ground.pin.iIm[3] ground.pin.iRe[1] ground.pin.iRe[2] ground.pin.iRe[3] ground1.pin.iIm[1] ground1.pin.iIm[2] ground1.pin.iIm[3] ground1.pin.iRe[1] ground1.pin.iRe[2] ground1.pin.iRe[3] r1.omega r2.omega z.iFundAbs z.iFundArg z.i[1].re z.i[1].im z.i[2].re z.i[2].im z.i[3].re z.i[3].im z.omega systemDef.modeSelect systemDef.event1 systemDef.event2 temp_62 temp_63 temp_64 }
eq_1 : temp_62@M // temp_62 = time > 0.5
eq_2 : temp_63@M // temp_63 = time > 0.25
eq_3 : temp_64@M // temp_64 = time > 0.4
eq_4[1] : temp_62# temp_63# temp_64# systemDef.event2@M // algorithm
 if temp_62 and not pre(temp_62) then
  systemDef.modeSelect := true;
 end if;
 if temp_63 and not pre(temp_63) then
  systemDef.event1 := true;
 end if;
 if temp_64 and not pre(temp_64) then
  systemDef.event2 := true;
 end if;

eq_4[2] : temp_62# temp_63# systemDef.event1@M temp_64# // Already printed, see eq_4[1]
eq_4[3] : temp_62# systemDef.modeSelect@M temp_63# temp_64# // Already printed, see eq_4[1]
eq_5 : z.i[1].re@ test_DY1.idealTransformer1.iPrim[1].re@M // - z.i[1].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].re
eq_6 : z.i[1].im@ test_DY1.idealTransformer1.iPrim[1].im@M // - z.i[1].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].im
eq_7 : z.i[2].re@ test_DY1.idealTransformer1.iPrim[2].re@M // - z.i[2].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].re
eq_8 : z.i[2].im@ test_DY1.idealTransformer1.iPrim[2].im@M // - z.i[2].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].im
eq_9 : z.i[3].re@ test_DY1.idealTransformer1.iPrim[3].re@M // - z.i[3].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].re
eq_10 : z.i[3].im@ test_DY1.idealTransformer1.iPrim[3].im@M // - z.i[3].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].im
eq_11 : der(PhA.theta)@M // der(PhA.theta) = 6.283185307179586 * systemDef.fFund
eq_12 : PhA.omega@M der(PhA.theta)@ // PhA.omega = der(PhA.theta)
eq_13 : der(PhB.theta)@M // der(PhB.theta) = 6.283185307179586 * systemDef.fFund
eq_14 : PhB.omega@M der(PhB.theta)@ // PhB.omega = der(PhB.theta)
eq_15 : der(PhC.theta)@M // der(PhC.theta) = 6.283185307179586 * systemDef.fFund
eq_16 : PhC.omega@M der(PhC.theta)@ // PhC.omega = der(PhC.theta)
eq_17 : r1.omega@M der(PhA.theta)@ // r1.omega = der(PhA.theta)
eq_18 : r2.omega@M der(PhA.theta)@ // r2.omega = der(PhA.theta)
eq_19 : z.i[1].re@ z.i[1].im@M // z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im
eq_20 : z.i[2].re@ z.i[2].im@M // z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im
eq_21 : z.i[3].re@ z.i[3].im@M // z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im
eq_22 : z.i[1].im@ z.i[1].re@M // z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re
eq_23 : z.i[2].im@ z.i[2].re@M // z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re
eq_24 : z.i[3].im@ z.i[3].re@M // z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re
eq_25 : z.omega@M der(PhA.theta)@ // z.omega = der(PhA.theta)
eq_26 : ground1.pin.iIm[1]@ test_DY1.hPin_N.iIm[1]@M z.i[1].im@ // ground1.pin.iIm[1] + (- r1.i[1].im) + (- r2.i[1].im) + test_DY1.hPin_N.iIm[1] + (- z.i[1].im) = 0
eq_27 : ground1.pin.iIm[2]@ test_DY1.hPin_N.iIm[2]@M z.i[2].im@ // ground1.pin.iIm[2] + (- r1.i[2].im) + (- r2.i[2].im) + test_DY1.hPin_N.iIm[2] + (- z.i[2].im) = 0
eq_28 : ground1.pin.iIm[3]@ test_DY1.hPin_N.iIm[3]@M z.i[3].im@ // ground1.pin.iIm[3] + (- r1.i[3].im) + (- r2.i[3].im) + test_DY1.hPin_N.iIm[3] + (- z.i[3].im) = 0
eq_29 : ground1.pin.iRe[1]@ test_DY1.hPin_N.iRe[1]@M z.i[1].re@ // ground1.pin.iRe[1] + (- r1.i[1].re) + (- r2.i[1].re) + test_DY1.hPin_N.iRe[1] + (- z.i[1].re) = 0
eq_30 : ground1.pin.iRe[2]@ test_DY1.hPin_N.iRe[2]@M z.i[2].re@ // ground1.pin.iRe[2] + (- r1.i[2].re) + (- r2.i[2].re) + test_DY1.hPin_N.iRe[2] + (- z.i[2].re) = 0
eq_31 : ground1.pin.iRe[3]@ test_DY1.hPin_N.iRe[3]@M z.i[3].re@ // ground1.pin.iRe[3] + (- r1.i[3].re) + (- r2.i[3].re) + test_DY1.hPin_N.iRe[3] + (- z.i[3].re) = 0
eq_32 : PhA.i[1].im@ PhC.i[1].im@ ground.pin.iIm[1]@M // - PhA.i[1].im + (- PhB.i[1].im) + (- PhC.i[1].im) + ground.pin.iIm[1] = 0
eq_33 : PhA.i[2].im@ PhC.i[2].im@ ground.pin.iIm[2]@M // - PhA.i[2].im + (- PhB.i[2].im) + (- PhC.i[2].im) + ground.pin.iIm[2] = 0
eq_34 : PhA.i[3].im@ PhC.i[3].im@ ground.pin.iIm[3]@M // - PhA.i[3].im + (- PhB.i[3].im) + (- PhC.i[3].im) + ground.pin.iIm[3] = 0
eq_35 : PhA.i[1].re@ PhC.i[1].re@ ground.pin.iRe[1]@M // - PhA.i[1].re + (- PhB.i[1].re) + (- PhC.i[1].re) + ground.pin.iRe[1] = 0
eq_36 : PhA.i[2].re@ PhC.i[2].re@ ground.pin.iRe[2]@M // - PhA.i[2].re + (- PhB.i[2].re) + (- PhC.i[2].re) + ground.pin.iRe[2] = 0
eq_37 : PhA.i[3].re@ PhC.i[3].re@ ground.pin.iRe[3]@M // - PhA.i[3].re + (- PhB.i[3].re) + (- PhC.i[3].re) + ground.pin.iRe[3] = 0
eq_38 : test_DY1.idealTransformer1.iPrim[1].im@ PhA.i[1].im@M // test_DY1.idealTransformer1.iPrim[1].im + (- test_DY1.idealTransformer2.iPrim[1].im) + PhA.i[1].im = 0
eq_39 : test_DY1.idealTransformer1.iPrim[2].im@ PhA.i[2].im@M // test_DY1.idealTransformer1.iPrim[2].im + (- test_DY1.idealTransformer2.iPrim[2].im) + PhA.i[2].im = 0
eq_40 : test_DY1.idealTransformer1.iPrim[3].im@ PhA.i[3].im@M // test_DY1.idealTransformer1.iPrim[3].im + (- test_DY1.idealTransformer2.iPrim[3].im) + PhA.i[3].im = 0
eq_41 : test_DY1.idealTransformer1.iPrim[1].re@ PhA.i[1].re@M // test_DY1.idealTransformer1.iPrim[1].re + (- test_DY1.idealTransformer2.iPrim[1].re) + PhA.i[1].re = 0
eq_42 : test_DY1.idealTransformer1.iPrim[2].re@ PhA.i[2].re@M // test_DY1.idealTransformer1.iPrim[2].re + (- test_DY1.idealTransformer2.iPrim[2].re) + PhA.i[2].re = 0
eq_43 : test_DY1.idealTransformer1.iPrim[3].re@ PhA.i[3].re@M // test_DY1.idealTransformer1.iPrim[3].re + (- test_DY1.idealTransformer2.iPrim[3].re) + PhA.i[3].re = 0
eq_44 : test_DY1.idealTransformer1.iPrim[1].im@ PhC.i[1].im@M // - test_DY1.idealTransformer1.iPrim[1].im + test_DY1.idealTransformer3.iPrim[1].im + PhC.i[1].im = 0
eq_45 : test_DY1.idealTransformer1.iPrim[2].im@ PhC.i[2].im@M // - test_DY1.idealTransformer1.iPrim[2].im + test_DY1.idealTransformer3.iPrim[2].im + PhC.i[2].im = 0
eq_46 : test_DY1.idealTransformer1.iPrim[3].im@ PhC.i[3].im@M // - test_DY1.idealTransformer1.iPrim[3].im + test_DY1.idealTransformer3.iPrim[3].im + PhC.i[3].im = 0
eq_47 : test_DY1.idealTransformer1.iPrim[1].re@ PhC.i[1].re@M // - test_DY1.idealTransformer1.iPrim[1].re + test_DY1.idealTransformer3.iPrim[1].re + PhC.i[1].re = 0
eq_48 : test_DY1.idealTransformer1.iPrim[2].re@ PhC.i[2].re@M // - test_DY1.idealTransformer1.iPrim[2].re + test_DY1.idealTransformer3.iPrim[2].re + PhC.i[2].re = 0
eq_49 : test_DY1.idealTransformer1.iPrim[3].re@ PhC.i[3].re@M // - test_DY1.idealTransformer1.iPrim[3].re + test_DY1.idealTransformer3.iPrim[3].re + PhC.i[3].re = 0
eq_50 : ground1.pin.iIm[1]@M // 0 = ground1.pin.iIm[1]
eq_51 : ground1.pin.iIm[2]@M // 0 = ground1.pin.iIm[2]
eq_52 : ground1.pin.iIm[3]@M // 0 = ground1.pin.iIm[3]
eq_53 : ground1.pin.iRe[1]@M // 0 = ground1.pin.iRe[1]
eq_54 : ground1.pin.iRe[2]@M // 0 = ground1.pin.iRe[2]
eq_55 : ground1.pin.iRe[3]@M // 0 = ground1.pin.iRe[3]
eq_56 : // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_57 : // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_58 : // HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhC.theta), HPF.Types.Reference(PhA.theta))
eq_59 : // HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))
eq_60 : // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_61 : // HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))
eq_62 : // HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhC.theta))
eq_63 : // HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_64 : // HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_65 : // HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_66 : z.iFundAbs@M z.i[1].re@ z.i[1].im@ // z.iFundAbs = (z.i[1].re ^ 2 + z.i[1].im ^ 2) ^ 0.5
eq_67 : z.iFundArg@M z.i[1].im@ z.i[1].re@ // z.iFundArg = Modelica.Math.atan3(z.i[1].im, z.i[1].re, 0)

DAE BiPGraph matching
----------------------------------------
BiPGraph matching:
eq_1 : temp_62
eq_2 : temp_63
eq_3 : temp_64
eq_4[1] : systemDef.event2
eq_4[2] : systemDef.event1
eq_4[3] : systemDef.modeSelect
eq_5 : test_DY1.idealTransformer1.iPrim[1].re
eq_6 : test_DY1.idealTransformer1.iPrim[1].im
eq_7 : test_DY1.idealTransformer1.iPrim[2].re
eq_8 : test_DY1.idealTransformer1.iPrim[2].im
eq_9 : test_DY1.idealTransformer1.iPrim[3].re
eq_10 : test_DY1.idealTransformer1.iPrim[3].im
eq_11 : der(PhA.theta)
eq_12 : PhA.omega
eq_13 : der(PhB.theta)
eq_14 : PhB.omega
eq_15 : der(PhC.theta)
eq_16 : PhC.omega
eq_17 : r1.omega
eq_18 : r2.omega
eq_19 : z.i[1].im
eq_20 : z.i[2].im
eq_21 : z.i[3].im
eq_22 : z.i[1].re
eq_23 : z.i[2].re
eq_24 : z.i[3].re
eq_25 : z.omega
eq_26 : test_DY1.hPin_N.iIm[1]
eq_27 : test_DY1.hPin_N.iIm[2]
eq_28 : test_DY1.hPin_N.iIm[3]
eq_29 : test_DY1.hPin_N.iRe[1]
eq_30 : test_DY1.hPin_N.iRe[2]
eq_31 : test_DY1.hPin_N.iRe[3]
eq_32 : ground.pin.iIm[1]
eq_33 : ground.pin.iIm[2]
eq_34 : ground.pin.iIm[3]
eq_35 : ground.pin.iRe[1]
eq_36 : ground.pin.iRe[2]
eq_37 : ground.pin.iRe[3]
eq_38 : PhA.i[1].im
eq_39 : PhA.i[2].im
eq_40 : PhA.i[3].im
eq_41 : PhA.i[1].re
eq_42 : PhA.i[2].re
eq_43 : PhA.i[3].re
eq_44 : PhC.i[1].im
eq_45 : PhC.i[2].im
eq_46 : PhC.i[3].im
eq_47 : PhC.i[1].re
eq_48 : PhC.i[2].re
eq_49 : PhC.i[3].re
eq_50 : ground1.pin.iIm[1]
eq_51 : ground1.pin.iIm[2]
eq_52 : ground1.pin.iIm[3]
eq_53 : ground1.pin.iRe[1]
eq_54 : ground1.pin.iRe[2]
eq_55 : ground1.pin.iRe[3]
eq_66 : z.iFundAbs
eq_67 : z.iFundArg
Unmatched equations: {}
Unmatched variables: {}
----------------------------------------

BiPGraph (69 equations, 59 variables)
Variables: {der(PhA.theta) der(PhB.theta) der(PhC.theta) test_DY1.idealTransformer1.iPrim[1].re test_DY1.idealTransformer1.iPrim[1].im test_DY1.idealTransformer1.iPrim[2].re test_DY1.idealTransformer1.iPrim[2].im test_DY1.idealTransformer1.iPrim[3].re test_DY1.idealTransformer1.iPrim[3].im test_DY1.hPin_N.iIm[1] test_DY1.hPin_N.iIm[2] test_DY1.hPin_N.iIm[3] test_DY1.hPin_N.iRe[1] test_DY1.hPin_N.iRe[2] test_DY1.hPin_N.iRe[3] PhA.i[1].re PhA.i[1].im PhA.i[2].re PhA.i[2].im PhA.i[3].re PhA.i[3].im PhA.omega PhB.omega PhC.i[1].re PhC.i[1].im PhC.i[2].re PhC.i[2].im PhC.i[3].re PhC.i[3].im PhC.omega ground.pin.iIm[1] ground.pin.iIm[2] ground.pin.iIm[3] ground.pin.iRe[1] ground.pin.iRe[2] ground.pin.iRe[3] ground1.pin.iIm[1] ground1.pin.iIm[2] ground1.pin.iIm[3] ground1.pin.iRe[1] ground1.pin.iRe[2] ground1.pin.iRe[3] r1.omega r2.omega z.iFundAbs z.iFundArg z.i[1].re z.i[1].im z.i[2].re z.i[2].im z.i[3].re z.i[3].im z.omega systemDef.modeSelect systemDef.event1 systemDef.event2 temp_62 temp_63 temp_64 }
eq_1 : temp_62@M // temp_62 = time > 0.5
eq_2 : temp_63@M // temp_63 = time > 0.25
eq_3 : temp_64@M // temp_64 = time > 0.4
eq_4[1] : temp_62# temp_63# temp_64# systemDef.event2@M // algorithm
 if temp_62 and not pre(temp_62) then
  systemDef.modeSelect := true;
 end if;
 if temp_63 and not pre(temp_63) then
  systemDef.event1 := true;
 end if;
 if temp_64 and not pre(temp_64) then
  systemDef.event2 := true;
 end if;

eq_4[2] : temp_62# temp_63# systemDef.event1@M temp_64# // Already printed, see eq_4[1]
eq_4[3] : temp_62# systemDef.modeSelect@M temp_63# temp_64# // Already printed, see eq_4[1]
eq_5 : z.i[1].re@ test_DY1.idealTransformer1.iPrim[1].re@M // - z.i[1].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].re
eq_6 : z.i[1].im@ test_DY1.idealTransformer1.iPrim[1].im@M // - z.i[1].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].im
eq_7 : z.i[2].re@ test_DY1.idealTransformer1.iPrim[2].re@M // - z.i[2].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].re
eq_8 : z.i[2].im@ test_DY1.idealTransformer1.iPrim[2].im@M // - z.i[2].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].im
eq_9 : z.i[3].re@ test_DY1.idealTransformer1.iPrim[3].re@M // - z.i[3].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].re
eq_10 : z.i[3].im@ test_DY1.idealTransformer1.iPrim[3].im@M // - z.i[3].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].im
eq_11 : der(PhA.theta)@M // der(PhA.theta) = 6.283185307179586 * systemDef.fFund
eq_12 : PhA.omega@M der(PhA.theta)@ // PhA.omega = der(PhA.theta)
eq_13 : der(PhB.theta)@M // der(PhB.theta) = 6.283185307179586 * systemDef.fFund
eq_14 : PhB.omega@M der(PhB.theta)@ // PhB.omega = der(PhB.theta)
eq_15 : der(PhC.theta)@M // der(PhC.theta) = 6.283185307179586 * systemDef.fFund
eq_16 : PhC.omega@M der(PhC.theta)@ // PhC.omega = der(PhC.theta)
eq_17 : r1.omega@M der(PhA.theta)@ // r1.omega = der(PhA.theta)
eq_18 : r2.omega@M der(PhA.theta)@ // r2.omega = der(PhA.theta)
eq_19 : z.i[1].re@ z.i[1].im@M // z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im
eq_20 : z.i[2].re@ z.i[2].im@M // z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im
eq_21 : z.i[3].re@ z.i[3].im@M // z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im
eq_22 : z.i[1].im@ z.i[1].re@M // z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re
eq_23 : z.i[2].im@ z.i[2].re@M // z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re
eq_24 : z.i[3].im@ z.i[3].re@M // z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re
eq_25 : z.omega@M der(PhA.theta)@ // z.omega = der(PhA.theta)
eq_26 : ground1.pin.iIm[1]@ test_DY1.hPin_N.iIm[1]@M z.i[1].im@ // ground1.pin.iIm[1] + (- r1.i[1].im) + (- r2.i[1].im) + test_DY1.hPin_N.iIm[1] + (- z.i[1].im) = 0
eq_27 : ground1.pin.iIm[2]@ test_DY1.hPin_N.iIm[2]@M z.i[2].im@ // ground1.pin.iIm[2] + (- r1.i[2].im) + (- r2.i[2].im) + test_DY1.hPin_N.iIm[2] + (- z.i[2].im) = 0
eq_28 : ground1.pin.iIm[3]@ test_DY1.hPin_N.iIm[3]@M z.i[3].im@ // ground1.pin.iIm[3] + (- r1.i[3].im) + (- r2.i[3].im) + test_DY1.hPin_N.iIm[3] + (- z.i[3].im) = 0
eq_29 : ground1.pin.iRe[1]@ test_DY1.hPin_N.iRe[1]@M z.i[1].re@ // ground1.pin.iRe[1] + (- r1.i[1].re) + (- r2.i[1].re) + test_DY1.hPin_N.iRe[1] + (- z.i[1].re) = 0
eq_30 : ground1.pin.iRe[2]@ test_DY1.hPin_N.iRe[2]@M z.i[2].re@ // ground1.pin.iRe[2] + (- r1.i[2].re) + (- r2.i[2].re) + test_DY1.hPin_N.iRe[2] + (- z.i[2].re) = 0
eq_31 : ground1.pin.iRe[3]@ test_DY1.hPin_N.iRe[3]@M z.i[3].re@ // ground1.pin.iRe[3] + (- r1.i[3].re) + (- r2.i[3].re) + test_DY1.hPin_N.iRe[3] + (- z.i[3].re) = 0
eq_32 : PhA.i[1].im@ PhC.i[1].im@ ground.pin.iIm[1]@M // - PhA.i[1].im + (- PhB.i[1].im) + (- PhC.i[1].im) + ground.pin.iIm[1] = 0
eq_33 : PhA.i[2].im@ PhC.i[2].im@ ground.pin.iIm[2]@M // - PhA.i[2].im + (- PhB.i[2].im) + (- PhC.i[2].im) + ground.pin.iIm[2] = 0
eq_34 : PhA.i[3].im@ PhC.i[3].im@ ground.pin.iIm[3]@M // - PhA.i[3].im + (- PhB.i[3].im) + (- PhC.i[3].im) + ground.pin.iIm[3] = 0
eq_35 : PhA.i[1].re@ PhC.i[1].re@ ground.pin.iRe[1]@M // - PhA.i[1].re + (- PhB.i[1].re) + (- PhC.i[1].re) + ground.pin.iRe[1] = 0
eq_36 : PhA.i[2].re@ PhC.i[2].re@ ground.pin.iRe[2]@M // - PhA.i[2].re + (- PhB.i[2].re) + (- PhC.i[2].re) + ground.pin.iRe[2] = 0
eq_37 : PhA.i[3].re@ PhC.i[3].re@ ground.pin.iRe[3]@M // - PhA.i[3].re + (- PhB.i[3].re) + (- PhC.i[3].re) + ground.pin.iRe[3] = 0
eq_38 : test_DY1.idealTransformer1.iPrim[1].im@ PhA.i[1].im@M // test_DY1.idealTransformer1.iPrim[1].im + (- test_DY1.idealTransformer2.iPrim[1].im) + PhA.i[1].im = 0
eq_39 : test_DY1.idealTransformer1.iPrim[2].im@ PhA.i[2].im@M // test_DY1.idealTransformer1.iPrim[2].im + (- test_DY1.idealTransformer2.iPrim[2].im) + PhA.i[2].im = 0
eq_40 : test_DY1.idealTransformer1.iPrim[3].im@ PhA.i[3].im@M // test_DY1.idealTransformer1.iPrim[3].im + (- test_DY1.idealTransformer2.iPrim[3].im) + PhA.i[3].im = 0
eq_41 : test_DY1.idealTransformer1.iPrim[1].re@ PhA.i[1].re@M // test_DY1.idealTransformer1.iPrim[1].re + (- test_DY1.idealTransformer2.iPrim[1].re) + PhA.i[1].re = 0
eq_42 : test_DY1.idealTransformer1.iPrim[2].re@ PhA.i[2].re@M // test_DY1.idealTransformer1.iPrim[2].re + (- test_DY1.idealTransformer2.iPrim[2].re) + PhA.i[2].re = 0
eq_43 : test_DY1.idealTransformer1.iPrim[3].re@ PhA.i[3].re@M // test_DY1.idealTransformer1.iPrim[3].re + (- test_DY1.idealTransformer2.iPrim[3].re) + PhA.i[3].re = 0
eq_44 : test_DY1.idealTransformer1.iPrim[1].im@ PhC.i[1].im@M // - test_DY1.idealTransformer1.iPrim[1].im + test_DY1.idealTransformer3.iPrim[1].im + PhC.i[1].im = 0
eq_45 : test_DY1.idealTransformer1.iPrim[2].im@ PhC.i[2].im@M // - test_DY1.idealTransformer1.iPrim[2].im + test_DY1.idealTransformer3.iPrim[2].im + PhC.i[2].im = 0
eq_46 : test_DY1.idealTransformer1.iPrim[3].im@ PhC.i[3].im@M // - test_DY1.idealTransformer1.iPrim[3].im + test_DY1.idealTransformer3.iPrim[3].im + PhC.i[3].im = 0
eq_47 : test_DY1.idealTransformer1.iPrim[1].re@ PhC.i[1].re@M // - test_DY1.idealTransformer1.iPrim[1].re + test_DY1.idealTransformer3.iPrim[1].re + PhC.i[1].re = 0
eq_48 : test_DY1.idealTransformer1.iPrim[2].re@ PhC.i[2].re@M // - test_DY1.idealTransformer1.iPrim[2].re + test_DY1.idealTransformer3.iPrim[2].re + PhC.i[2].re = 0
eq_49 : test_DY1.idealTransformer1.iPrim[3].re@ PhC.i[3].re@M // - test_DY1.idealTransformer1.iPrim[3].re + test_DY1.idealTransformer3.iPrim[3].re + PhC.i[3].re = 0
eq_50 : ground1.pin.iIm[1]@M // 0 = ground1.pin.iIm[1]
eq_51 : ground1.pin.iIm[2]@M // 0 = ground1.pin.iIm[2]
eq_52 : ground1.pin.iIm[3]@M // 0 = ground1.pin.iIm[3]
eq_53 : ground1.pin.iRe[1]@M // 0 = ground1.pin.iRe[1]
eq_54 : ground1.pin.iRe[2]@M // 0 = ground1.pin.iRe[2]
eq_55 : ground1.pin.iRe[3]@M // 0 = ground1.pin.iRe[3]
eq_56 : // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_57 : // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_58 : // HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhC.theta), HPF.Types.Reference(PhA.theta))
eq_59 : // HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))
eq_60 : // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_61 : // HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))
eq_62 : // HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhC.theta))
eq_63 : // HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_64 : // HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_65 : // HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_66 : z.iFundAbs@M z.i[1].re@ z.i[1].im@ // z.iFundAbs = (z.i[1].re ^ 2 + z.i[1].im ^ 2) ^ 0.5
eq_67 : z.iFundArg@M z.i[1].im@ z.i[1].re@ // z.iFundArg = Modelica.Math.atan3(z.i[1].im, z.i[1].re, 0)

Starting automatic tearing
BiPGraph (2 equations, 2 variables)
Variables: {z.i[1].im z.i[1].re }
eq_19 : z.i[1].re# z.i[1].im# // z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im
eq_22 : z.i[1].im# z.i[1].re# // z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re

Initial matching
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_19 eq_22 }
Unmatched variables: {z.i[1].im z.i[1].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_19 eq_22 }
Unmatched variables: {z.i[1].im z.i[1].re }
----------------------------------------

Automatic tearing pair, equation: z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im, tearing with variable: z.i[1].im
Automatic tearing pair, equation: z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re, tearing with variable: z.i[1].re
Starting automatic tearing
BiPGraph (2 equations, 2 variables)
Variables: {z.i[2].im z.i[2].re }
eq_20 : z.i[2].re# z.i[2].im# // z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im
eq_23 : z.i[2].im# z.i[2].re# // z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re

Initial matching
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_20 eq_23 }
Unmatched variables: {z.i[2].im z.i[2].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_20 eq_23 }
Unmatched variables: {z.i[2].im z.i[2].re }
----------------------------------------

Automatic tearing pair, equation: z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im, tearing with variable: z.i[2].im
Automatic tearing pair, equation: z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re, tearing with variable: z.i[2].re
Starting automatic tearing
BiPGraph (2 equations, 2 variables)
Variables: {z.i[3].im z.i[3].re }
eq_21 : z.i[3].re# z.i[3].im# // z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im
eq_24 : z.i[3].im# z.i[3].re# // z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re

Initial matching
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_21 eq_24 }
Unmatched variables: {z.i[3].im z.i[3].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_21 eq_24 }
Unmatched variables: {z.i[3].im z.i[3].re }
----------------------------------------

Automatic tearing pair, equation: z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im, tearing with variable: z.i[3].im
Automatic tearing pair, equation: z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re, tearing with variable: z.i[3].re
***********************************
*********** ODE section ***********
***********************************

--- Solved equation ---
der(PhA.theta) := 6.283185307179586 * systemDef.fFund

--- Solved equation ---
der(PhB.theta) := 6.283185307179586 * systemDef.fFund

--- Solved equation ---
der(PhC.theta) := 6.283185307179586 * systemDef.fFund

***********************************
*********** Real outputs **********
***********************************

***********************************
*** Integer and boolean outputs ***
***********************************

***********************************
********* Other variables *********
***********************************

--- Unsolved mixed linear system (Block 1) of 6 variables ---
Coefficient variability: constant
Unknown continuous variables:

Solved discrete variables:
  temp_64
  temp_63
  temp_62
  systemDef.modeSelect
  systemDef.event1
  systemDef.event2

Continuous residual equations:

Discrete equations:
  temp_64 := time > 0.4
  temp_63 := time > 0.25
  temp_62 := time > 0.5
  algorithm
    if temp_62 and not pre(temp_62) then
      systemDef.modeSelect := true;
    end if;
    if temp_63 and not pre(temp_63) then
      systemDef.event1 := true;
    end if;
    if temp_64 and not pre(temp_64) then
      systemDef.event2 := true;
    end if;

    Assigned variables: systemDef.modeSelect
                        systemDef.event1
                        systemDef.event2

Jacobian:

--- Unsolved linear system (Block 2) of 2 variables ---
Coefficient variability: parameter
Unknown variables:
  z.i[1].im
  z.i[1].re

Equations:
  z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im
    Iteration variables: z.i[1].im
  z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re
    Iteration variables: z.i[1].re

Jacobian:
  |z.z.im .* systemDef.hrms[1], - z.z.re|
  |- z.z.re, - z.z.im .* systemDef.hrms[1]|

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[1].re := z.i[1].re / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[1].im := z.i[1].im / (- test_DY1.idealTransformer1.N)

--- Unsolved linear system (Block 3) of 2 variables ---
Coefficient variability: parameter
Unknown variables:
  z.i[2].im
  z.i[2].re

Equations:
  z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im
    Iteration variables: z.i[2].im
  z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re
    Iteration variables: z.i[2].re

Jacobian:
  |z.z.im .* systemDef.hrms[2], - z.z.re|
  |- z.z.re, - z.z.im .* systemDef.hrms[2]|

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[2].re := z.i[2].re / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[2].im := z.i[2].im / (- test_DY1.idealTransformer1.N)

--- Unsolved linear system (Block 4) of 2 variables ---
Coefficient variability: parameter
Unknown variables:
  z.i[3].im
  z.i[3].re

Equations:
  z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im
    Iteration variables: z.i[3].im
  z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re
    Iteration variables: z.i[3].re

Jacobian:
  |z.z.im .* systemDef.hrms[3], - z.z.re|
  |- z.z.re, - z.z.im .* systemDef.hrms[3]|

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[3].re := z.i[3].re / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[3].im := z.i[3].im / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
ground1.pin.iIm[1] := 0

--- Solved equation ---
test_DY1.hPin_N.iIm[1] := - ground1.pin.iIm[1] + r1.i[1].im + r2.i[1].im + z.i[1].im

--- Solved equation ---
ground1.pin.iIm[2] := 0

--- Solved equation ---
test_DY1.hPin_N.iIm[2] := - ground1.pin.iIm[2] + r1.i[2].im + r2.i[2].im + z.i[2].im

--- Solved equation ---
ground1.pin.iIm[3] := 0

--- Solved equation ---
test_DY1.hPin_N.iIm[3] := - ground1.pin.iIm[3] + r1.i[3].im + r2.i[3].im + z.i[3].im

--- Solved equation ---
ground1.pin.iRe[1] := 0

--- Solved equation ---
test_DY1.hPin_N.iRe[1] := - ground1.pin.iRe[1] + r1.i[1].re + r2.i[1].re + z.i[1].re

--- Solved equation ---
ground1.pin.iRe[2] := 0

--- Solved equation ---
test_DY1.hPin_N.iRe[2] := - ground1.pin.iRe[2] + r1.i[2].re + r2.i[2].re + z.i[2].re

--- Solved equation ---
ground1.pin.iRe[3] := 0

--- Solved equation ---
test_DY1.hPin_N.iRe[3] := - ground1.pin.iRe[3] + r1.i[3].re + r2.i[3].re + z.i[3].re

--- Solved equation ---
PhA.i[1].re := - test_DY1.idealTransformer1.iPrim[1].re + test_DY1.idealTransformer2.iPrim[1].re

--- Solved equation ---
PhA.i[1].im := - test_DY1.idealTransformer1.iPrim[1].im + test_DY1.idealTransformer2.iPrim[1].im

--- Solved equation ---
PhA.i[2].re := - test_DY1.idealTransformer1.iPrim[2].re + test_DY1.idealTransformer2.iPrim[2].re

--- Solved equation ---
PhA.i[2].im := - test_DY1.idealTransformer1.iPrim[2].im + test_DY1.idealTransformer2.iPrim[2].im

--- Solved equation ---
PhA.i[3].re := - test_DY1.idealTransformer1.iPrim[3].re + test_DY1.idealTransformer2.iPrim[3].re

--- Solved equation ---
PhA.i[3].im := - test_DY1.idealTransformer1.iPrim[3].im + test_DY1.idealTransformer2.iPrim[3].im

--- Solved equation ---
PhA.omega := der(PhA.theta)

--- Solved equation ---
PhB.omega := der(PhB.theta)

--- Solved equation ---
PhC.i[1].re := test_DY1.idealTransformer1.iPrim[1].re + (- test_DY1.idealTransformer3.iPrim[1].re)

--- Solved equation ---
PhC.i[1].im := test_DY1.idealTransformer1.iPrim[1].im + (- test_DY1.idealTransformer3.iPrim[1].im)

--- Solved equation ---
PhC.i[2].re := test_DY1.idealTransformer1.iPrim[2].re + (- test_DY1.idealTransformer3.iPrim[2].re)

--- Solved equation ---
PhC.i[2].im := test_DY1.idealTransformer1.iPrim[2].im + (- test_DY1.idealTransformer3.iPrim[2].im)

--- Solved equation ---
PhC.i[3].re := test_DY1.idealTransformer1.iPrim[3].re + (- test_DY1.idealTransformer3.iPrim[3].re)

--- Solved equation ---
PhC.i[3].im := test_DY1.idealTransformer1.iPrim[3].im + (- test_DY1.idealTransformer3.iPrim[3].im)

--- Solved equation ---
PhC.omega := der(PhC.theta)

--- Solved equation ---
ground.pin.iIm[1] := PhA.i[1].im + PhB.i[1].im + PhC.i[1].im

--- Solved equation ---
ground.pin.iIm[2] := PhA.i[2].im + PhB.i[2].im + PhC.i[2].im

--- Solved equation ---
ground.pin.iIm[3] := PhA.i[3].im + PhB.i[3].im + PhC.i[3].im

--- Solved equation ---
ground.pin.iRe[1] := PhA.i[1].re + PhB.i[1].re + PhC.i[1].re

--- Solved equation ---
ground.pin.iRe[2] := PhA.i[2].re + PhB.i[2].re + PhC.i[2].re

--- Solved equation ---
ground.pin.iRe[3] := PhA.i[3].re + PhB.i[3].re + PhC.i[3].re

--- Solved equation ---
r1.omega := der(PhA.theta)

--- Solved equation ---
r2.omega := der(PhA.theta)

--- Solved equation ---
z.iFundAbs := (z.i[1].re ^ 2 + z.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
z.iFundArg := Modelica.Math.atan3(z.i[1].im, z.i[1].re, 0)

--- Solved equation ---
z.omega := der(PhA.theta)

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhC.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhC.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

***********************************

--- Unsolved mixed linear system (Block 1) of 6 variables ---
Coefficient variability: constant
Unknown continuous variables:

Solved discrete variables:
  temp_64
  temp_63
  temp_62
  systemDef.modeSelect
  systemDef.event1
  systemDef.event2

Continuous residual equations:

Discrete equations:
  temp_64 := time > 0.4
  temp_63 := time > 0.25
  temp_62 := time > 0.5
  algorithm
    if temp_62 and not pre(temp_62) then
      systemDef.modeSelect := true;
    end if;
    if temp_63 and not pre(temp_63) then
      systemDef.event1 := true;
    end if;
    if temp_64 and not pre(temp_64) then
      systemDef.event2 := true;
    end if;

    Assigned variables: systemDef.modeSelect
                        systemDef.event1
                        systemDef.event2

Jacobian:

--- Unsolved linear system (Block 2) of 2 variables ---
Coefficient variability: parameter
Unknown variables:
  z.i[1].im
  z.i[1].re

Equations:
  z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im
    Iteration variables: z.i[1].im
  z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re
    Iteration variables: z.i[1].re

Jacobian:
  |z.z.im .* systemDef.hrms[1], - z.z.re|
  |- z.z.re, - z.z.im .* systemDef.hrms[1]|

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[1].re := z.i[1].re / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[1].im := z.i[1].im / (- test_DY1.idealTransformer1.N)

--- Unsolved linear system (Block 3) of 2 variables ---
Coefficient variability: parameter
Unknown variables:
  z.i[2].im
  z.i[2].re

Equations:
  z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im
    Iteration variables: z.i[2].im
  z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re
    Iteration variables: z.i[2].re

Jacobian:
  |z.z.im .* systemDef.hrms[2], - z.z.re|
  |- z.z.re, - z.z.im .* systemDef.hrms[2]|

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[2].re := z.i[2].re / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[2].im := z.i[2].im / (- test_DY1.idealTransformer1.N)

--- Unsolved linear system (Block 4) of 2 variables ---
Coefficient variability: parameter
Unknown variables:
  z.i[3].im
  z.i[3].re

Equations:
  z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im
    Iteration variables: z.i[3].im
  z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re
    Iteration variables: z.i[3].re

Jacobian:
  |z.z.im .* systemDef.hrms[3], - z.z.re|
  |- z.z.re, - z.z.im .* systemDef.hrms[3]|

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[3].re := z.i[3].re / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[3].im := z.i[3].im / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
der(PhA.theta) := 6.283185307179586 * systemDef.fFund

--- Solved equation ---
PhA.omega := der(PhA.theta)

--- Solved equation ---
der(PhB.theta) := 6.283185307179586 * systemDef.fFund

--- Solved equation ---
PhB.omega := der(PhB.theta)

--- Solved equation ---
der(PhC.theta) := 6.283185307179586 * systemDef.fFund

--- Solved equation ---
PhC.omega := der(PhC.theta)

--- Solved equation ---
r1.omega := der(PhA.theta)

--- Solved equation ---
r2.omega := der(PhA.theta)

--- Solved equation ---
z.omega := der(PhA.theta)

--- Solved equation ---
ground1.pin.iIm[1] := 0

--- Solved equation ---
test_DY1.hPin_N.iIm[1] := - ground1.pin.iIm[1] + r1.i[1].im + r2.i[1].im + z.i[1].im

--- Solved equation ---
ground1.pin.iIm[2] := 0

--- Solved equation ---
test_DY1.hPin_N.iIm[2] := - ground1.pin.iIm[2] + r1.i[2].im + r2.i[2].im + z.i[2].im

--- Solved equation ---
ground1.pin.iIm[3] := 0

--- Solved equation ---
test_DY1.hPin_N.iIm[3] := - ground1.pin.iIm[3] + r1.i[3].im + r2.i[3].im + z.i[3].im

--- Solved equation ---
ground1.pin.iRe[1] := 0

--- Solved equation ---
test_DY1.hPin_N.iRe[1] := - ground1.pin.iRe[1] + r1.i[1].re + r2.i[1].re + z.i[1].re

--- Solved equation ---
ground1.pin.iRe[2] := 0

--- Solved equation ---
test_DY1.hPin_N.iRe[2] := - ground1.pin.iRe[2] + r1.i[2].re + r2.i[2].re + z.i[2].re

--- Solved equation ---
ground1.pin.iRe[3] := 0

--- Solved equation ---
test_DY1.hPin_N.iRe[3] := - ground1.pin.iRe[3] + r1.i[3].re + r2.i[3].re + z.i[3].re

--- Solved equation ---
PhA.i[1].im := - test_DY1.idealTransformer1.iPrim[1].im + test_DY1.idealTransformer2.iPrim[1].im

--- Solved equation ---
PhC.i[1].im := test_DY1.idealTransformer1.iPrim[1].im + (- test_DY1.idealTransformer3.iPrim[1].im)

--- Solved equation ---
ground.pin.iIm[1] := PhA.i[1].im + PhB.i[1].im + PhC.i[1].im

--- Solved equation ---
PhA.i[2].im := - test_DY1.idealTransformer1.iPrim[2].im + test_DY1.idealTransformer2.iPrim[2].im

--- Solved equation ---
PhC.i[2].im := test_DY1.idealTransformer1.iPrim[2].im + (- test_DY1.idealTransformer3.iPrim[2].im)

--- Solved equation ---
ground.pin.iIm[2] := PhA.i[2].im + PhB.i[2].im + PhC.i[2].im

--- Solved equation ---
PhA.i[3].im := - test_DY1.idealTransformer1.iPrim[3].im + test_DY1.idealTransformer2.iPrim[3].im

--- Solved equation ---
PhC.i[3].im := test_DY1.idealTransformer1.iPrim[3].im + (- test_DY1.idealTransformer3.iPrim[3].im)

--- Solved equation ---
ground.pin.iIm[3] := PhA.i[3].im + PhB.i[3].im + PhC.i[3].im

--- Solved equation ---
PhA.i[1].re := - test_DY1.idealTransformer1.iPrim[1].re + test_DY1.idealTransformer2.iPrim[1].re

--- Solved equation ---
PhC.i[1].re := test_DY1.idealTransformer1.iPrim[1].re + (- test_DY1.idealTransformer3.iPrim[1].re)

--- Solved equation ---
ground.pin.iRe[1] := PhA.i[1].re + PhB.i[1].re + PhC.i[1].re

--- Solved equation ---
PhA.i[2].re := - test_DY1.idealTransformer1.iPrim[2].re + test_DY1.idealTransformer2.iPrim[2].re

--- Solved equation ---
PhC.i[2].re := test_DY1.idealTransformer1.iPrim[2].re + (- test_DY1.idealTransformer3.iPrim[2].re)

--- Solved equation ---
ground.pin.iRe[2] := PhA.i[2].re + PhB.i[2].re + PhC.i[2].re

--- Solved equation ---
PhA.i[3].re := - test_DY1.idealTransformer1.iPrim[3].re + test_DY1.idealTransformer2.iPrim[3].re

--- Solved equation ---
PhC.i[3].re := test_DY1.idealTransformer1.iPrim[3].re + (- test_DY1.idealTransformer3.iPrim[3].re)

--- Solved equation ---
ground.pin.iRe[3] := PhA.i[3].re + PhB.i[3].re + PhC.i[3].re

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhC.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhC.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Solved equation ---
z.iFundAbs := (z.i[1].re ^ 2 + z.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
z.iFundArg := Modelica.Math.atan3(z.i[1].im, z.i[1].re, 0)
-------------------------------

BiPGraph (66 equations, 68 variables)
Variables: {der(PhA.theta) der(PhB.theta) der(PhC.theta) test_DY1.idealTransformer1.iPrim[1].re test_DY1.idealTransformer1.iPrim[1].im test_DY1.idealTransformer1.iPrim[2].re test_DY1.idealTransformer1.iPrim[2].im test_DY1.idealTransformer1.iPrim[3].re test_DY1.idealTransformer1.iPrim[3].im test_DY1.hPin_N.iIm[1] test_DY1.hPin_N.iIm[2] test_DY1.hPin_N.iIm[3] test_DY1.hPin_N.iRe[1] test_DY1.hPin_N.iRe[2] test_DY1.hPin_N.iRe[3] PhA.i[1].re PhA.i[1].im PhA.i[2].re PhA.i[2].im PhA.i[3].re PhA.i[3].im PhA.omega PhB.omega PhC.i[1].re PhC.i[1].im PhC.i[2].re PhC.i[2].im PhC.i[3].re PhC.i[3].im PhC.omega ground.pin.iIm[1] ground.pin.iIm[2] ground.pin.iIm[3] ground.pin.iRe[1] ground.pin.iRe[2] ground.pin.iRe[3] ground1.pin.iIm[1] ground1.pin.iIm[2] ground1.pin.iIm[3] ground1.pin.iRe[1] ground1.pin.iRe[2] ground1.pin.iRe[3] r1.omega r2.omega z.iFundAbs z.iFundArg z.i[1].re z.i[1].im z.i[2].re z.i[2].im z.i[3].re z.i[3].im z.omega systemDef.modeSelect systemDef.event1 systemDef.event2 temp_62 temp_63 temp_64 PhA.theta PhB.theta PhC.theta pre(systemDef.modeSelect) pre(systemDef.event1) pre(systemDef.event2) pre(temp_62) pre(temp_63) pre(temp_64) }
eq_1 : temp_62@M // temp_62 = time > 0.5
eq_2 : temp_63@M // temp_63 = time > 0.25
eq_3 : temp_64@M // temp_64 = time > 0.4
eq_5 : z.i[1].re@ test_DY1.idealTransformer1.iPrim[1].re@M // - z.i[1].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].re
eq_6 : z.i[1].im@ test_DY1.idealTransformer1.iPrim[1].im@M // - z.i[1].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].im
eq_7 : z.i[2].re@ test_DY1.idealTransformer1.iPrim[2].re@M // - z.i[2].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].re
eq_8 : z.i[2].im@ test_DY1.idealTransformer1.iPrim[2].im@M // - z.i[2].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].im
eq_9 : z.i[3].re@ test_DY1.idealTransformer1.iPrim[3].re@M // - z.i[3].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].re
eq_10 : z.i[3].im@ test_DY1.idealTransformer1.iPrim[3].im@M // - z.i[3].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].im
eq_11 : der(PhA.theta)@M // der(PhA.theta) = 6.283185307179586 * systemDef.fFund
eq_12 : PhA.omega@M der(PhA.theta)@ // PhA.omega = der(PhA.theta)
eq_13 : der(PhB.theta)@M // der(PhB.theta) = 6.283185307179586 * systemDef.fFund
eq_14 : PhB.omega@M der(PhB.theta)@ // PhB.omega = der(PhB.theta)
eq_15 : der(PhC.theta)@M // der(PhC.theta) = 6.283185307179586 * systemDef.fFund
eq_16 : PhC.omega@M der(PhC.theta)@ // PhC.omega = der(PhC.theta)
eq_17 : r1.omega@M der(PhA.theta)@ // r1.omega = der(PhA.theta)
eq_18 : r2.omega@M der(PhA.theta)@ // r2.omega = der(PhA.theta)
eq_19 : z.i[1].re@ z.i[1].im@M // z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im
eq_20 : z.i[2].re@ z.i[2].im@M // z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im
eq_21 : z.i[3].re@ z.i[3].im@M // z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im
eq_22 : z.i[1].im@ z.i[1].re@M // z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re
eq_23 : z.i[2].im@ z.i[2].re@M // z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re
eq_24 : z.i[3].im@ z.i[3].re@M // z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re
eq_25 : z.omega@M der(PhA.theta)@ // z.omega = der(PhA.theta)
eq_26 : ground1.pin.iIm[1]@ test_DY1.hPin_N.iIm[1]@M z.i[1].im@ // ground1.pin.iIm[1] + (- r1.i[1].im) + (- r2.i[1].im) + test_DY1.hPin_N.iIm[1] + (- z.i[1].im) = 0
eq_27 : ground1.pin.iIm[2]@ test_DY1.hPin_N.iIm[2]@M z.i[2].im@ // ground1.pin.iIm[2] + (- r1.i[2].im) + (- r2.i[2].im) + test_DY1.hPin_N.iIm[2] + (- z.i[2].im) = 0
eq_28 : ground1.pin.iIm[3]@ test_DY1.hPin_N.iIm[3]@M z.i[3].im@ // ground1.pin.iIm[3] + (- r1.i[3].im) + (- r2.i[3].im) + test_DY1.hPin_N.iIm[3] + (- z.i[3].im) = 0
eq_29 : ground1.pin.iRe[1]@ test_DY1.hPin_N.iRe[1]@M z.i[1].re@ // ground1.pin.iRe[1] + (- r1.i[1].re) + (- r2.i[1].re) + test_DY1.hPin_N.iRe[1] + (- z.i[1].re) = 0
eq_30 : ground1.pin.iRe[2]@ test_DY1.hPin_N.iRe[2]@M z.i[2].re@ // ground1.pin.iRe[2] + (- r1.i[2].re) + (- r2.i[2].re) + test_DY1.hPin_N.iRe[2] + (- z.i[2].re) = 0
eq_31 : ground1.pin.iRe[3]@ test_DY1.hPin_N.iRe[3]@M z.i[3].re@ // ground1.pin.iRe[3] + (- r1.i[3].re) + (- r2.i[3].re) + test_DY1.hPin_N.iRe[3] + (- z.i[3].re) = 0
eq_32 : PhA.i[1].im@ PhC.i[1].im@ ground.pin.iIm[1]@M // - PhA.i[1].im + (- PhB.i[1].im) + (- PhC.i[1].im) + ground.pin.iIm[1] = 0
eq_33 : PhA.i[2].im@ PhC.i[2].im@ ground.pin.iIm[2]@M // - PhA.i[2].im + (- PhB.i[2].im) + (- PhC.i[2].im) + ground.pin.iIm[2] = 0
eq_34 : PhA.i[3].im@ PhC.i[3].im@ ground.pin.iIm[3]@M // - PhA.i[3].im + (- PhB.i[3].im) + (- PhC.i[3].im) + ground.pin.iIm[3] = 0
eq_35 : PhA.i[1].re@ PhC.i[1].re@ ground.pin.iRe[1]@M // - PhA.i[1].re + (- PhB.i[1].re) + (- PhC.i[1].re) + ground.pin.iRe[1] = 0
eq_36 : PhA.i[2].re@ PhC.i[2].re@ ground.pin.iRe[2]@M // - PhA.i[2].re + (- PhB.i[2].re) + (- PhC.i[2].re) + ground.pin.iRe[2] = 0
eq_37 : PhA.i[3].re@ PhC.i[3].re@ ground.pin.iRe[3]@M // - PhA.i[3].re + (- PhB.i[3].re) + (- PhC.i[3].re) + ground.pin.iRe[3] = 0
eq_38 : test_DY1.idealTransformer1.iPrim[1].im@ PhA.i[1].im@M // test_DY1.idealTransformer1.iPrim[1].im + (- test_DY1.idealTransformer2.iPrim[1].im) + PhA.i[1].im = 0
eq_39 : test_DY1.idealTransformer1.iPrim[2].im@ PhA.i[2].im@M // test_DY1.idealTransformer1.iPrim[2].im + (- test_DY1.idealTransformer2.iPrim[2].im) + PhA.i[2].im = 0
eq_40 : test_DY1.idealTransformer1.iPrim[3].im@ PhA.i[3].im@M // test_DY1.idealTransformer1.iPrim[3].im + (- test_DY1.idealTransformer2.iPrim[3].im) + PhA.i[3].im = 0
eq_41 : test_DY1.idealTransformer1.iPrim[1].re@ PhA.i[1].re@M // test_DY1.idealTransformer1.iPrim[1].re + (- test_DY1.idealTransformer2.iPrim[1].re) + PhA.i[1].re = 0
eq_42 : test_DY1.idealTransformer1.iPrim[2].re@ PhA.i[2].re@M // test_DY1.idealTransformer1.iPrim[2].re + (- test_DY1.idealTransformer2.iPrim[2].re) + PhA.i[2].re = 0
eq_43 : test_DY1.idealTransformer1.iPrim[3].re@ PhA.i[3].re@M // test_DY1.idealTransformer1.iPrim[3].re + (- test_DY1.idealTransformer2.iPrim[3].re) + PhA.i[3].re = 0
eq_44 : test_DY1.idealTransformer1.iPrim[1].im@ PhC.i[1].im@M // - test_DY1.idealTransformer1.iPrim[1].im + test_DY1.idealTransformer3.iPrim[1].im + PhC.i[1].im = 0
eq_45 : test_DY1.idealTransformer1.iPrim[2].im@ PhC.i[2].im@M // - test_DY1.idealTransformer1.iPrim[2].im + test_DY1.idealTransformer3.iPrim[2].im + PhC.i[2].im = 0
eq_46 : test_DY1.idealTransformer1.iPrim[3].im@ PhC.i[3].im@M // - test_DY1.idealTransformer1.iPrim[3].im + test_DY1.idealTransformer3.iPrim[3].im + PhC.i[3].im = 0
eq_47 : test_DY1.idealTransformer1.iPrim[1].re@ PhC.i[1].re@M // - test_DY1.idealTransformer1.iPrim[1].re + test_DY1.idealTransformer3.iPrim[1].re + PhC.i[1].re = 0
eq_48 : test_DY1.idealTransformer1.iPrim[2].re@ PhC.i[2].re@M // - test_DY1.idealTransformer1.iPrim[2].re + test_DY1.idealTransformer3.iPrim[2].re + PhC.i[2].re = 0
eq_49 : test_DY1.idealTransformer1.iPrim[3].re@ PhC.i[3].re@M // - test_DY1.idealTransformer1.iPrim[3].re + test_DY1.idealTransformer3.iPrim[3].re + PhC.i[3].re = 0
eq_50 : ground1.pin.iIm[1]@M // 0 = ground1.pin.iIm[1]
eq_51 : ground1.pin.iIm[2]@M // 0 = ground1.pin.iIm[2]
eq_52 : ground1.pin.iIm[3]@M // 0 = ground1.pin.iIm[3]
eq_53 : ground1.pin.iRe[1]@M // 0 = ground1.pin.iRe[1]
eq_54 : ground1.pin.iRe[2]@M // 0 = ground1.pin.iRe[2]
eq_55 : ground1.pin.iRe[3]@M // 0 = ground1.pin.iRe[3]
eq_56 : PhA.theta# // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_57 : PhA.theta# // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_58 : PhC.theta# PhA.theta# // HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhC.theta), HPF.Types.Reference(PhA.theta))
eq_59 : PhB.theta# PhA.theta# // HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))
eq_60 : PhA.theta# // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_61 : PhB.theta# PhA.theta# // HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))
eq_62 : PhA.theta# PhC.theta# // HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhC.theta))
eq_63 : PhA.theta# // HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_64 : PhA.theta# // HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_65 : PhA.theta# // HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_66 : z.iFundAbs@M z.i[1].re@ z.i[1].im@ // z.iFundAbs = (z.i[1].re ^ 2 + z.i[1].im ^ 2) ^ 0.5
eq_67 : z.iFundArg@M z.i[1].im@ z.i[1].re@ // z.iFundArg = Modelica.Math.atan3(z.i[1].im, z.i[1].re, 0)

Init DAE BiPGraph
BiPGraph (67 equations, 68 variables)
Variables: {der(PhA.theta) der(PhB.theta) der(PhC.theta) test_DY1.idealTransformer1.iPrim[1].re test_DY1.idealTransformer1.iPrim[1].im test_DY1.idealTransformer1.iPrim[2].re test_DY1.idealTransformer1.iPrim[2].im test_DY1.idealTransformer1.iPrim[3].re test_DY1.idealTransformer1.iPrim[3].im test_DY1.hPin_N.iIm[1] test_DY1.hPin_N.iIm[2] test_DY1.hPin_N.iIm[3] test_DY1.hPin_N.iRe[1] test_DY1.hPin_N.iRe[2] test_DY1.hPin_N.iRe[3] PhA.i[1].re PhA.i[1].im PhA.i[2].re PhA.i[2].im PhA.i[3].re PhA.i[3].im PhA.omega PhB.omega PhC.i[1].re PhC.i[1].im PhC.i[2].re PhC.i[2].im PhC.i[3].re PhC.i[3].im PhC.omega ground.pin.iIm[1] ground.pin.iIm[2] ground.pin.iIm[3] ground.pin.iRe[1] ground.pin.iRe[2] ground.pin.iRe[3] ground1.pin.iIm[1] ground1.pin.iIm[2] ground1.pin.iIm[3] ground1.pin.iRe[1] ground1.pin.iRe[2] ground1.pin.iRe[3] r1.omega r2.omega z.iFundAbs z.iFundArg z.i[1].re z.i[1].im z.i[2].re z.i[2].im z.i[3].re z.i[3].im z.omega systemDef.modeSelect systemDef.event1 systemDef.event2 temp_62 temp_63 temp_64 PhA.theta PhB.theta PhC.theta pre(systemDef.modeSelect) pre(systemDef.event1) pre(systemDef.event2) pre(temp_62) pre(temp_63) pre(temp_64) }
eq_1 : temp_62@M // temp_62 = time > 0.5
eq_2 : temp_63@M // temp_63 = time > 0.25
eq_3 : temp_64@M // temp_64 = time > 0.4
eq_5 : z.i[1].re@ test_DY1.idealTransformer1.iPrim[1].re@M // - z.i[1].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].re
eq_6 : z.i[1].im@ test_DY1.idealTransformer1.iPrim[1].im@M // - z.i[1].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].im
eq_7 : z.i[2].re@ test_DY1.idealTransformer1.iPrim[2].re@M // - z.i[2].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].re
eq_8 : z.i[2].im@ test_DY1.idealTransformer1.iPrim[2].im@M // - z.i[2].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].im
eq_9 : z.i[3].re@ test_DY1.idealTransformer1.iPrim[3].re@M // - z.i[3].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].re
eq_10 : z.i[3].im@ test_DY1.idealTransformer1.iPrim[3].im@M // - z.i[3].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].im
eq_11 : der(PhA.theta)@M // der(PhA.theta) = 6.283185307179586 * systemDef.fFund
eq_12 : PhA.omega@M der(PhA.theta)@ // PhA.omega = der(PhA.theta)
eq_13 : der(PhB.theta)@M // der(PhB.theta) = 6.283185307179586 * systemDef.fFund
eq_14 : PhB.omega@M der(PhB.theta)@ // PhB.omega = der(PhB.theta)
eq_15 : der(PhC.theta)@M // der(PhC.theta) = 6.283185307179586 * systemDef.fFund
eq_16 : PhC.omega@M der(PhC.theta)@ // PhC.omega = der(PhC.theta)
eq_17 : r1.omega@M der(PhA.theta)@ // r1.omega = der(PhA.theta)
eq_18 : r2.omega@M der(PhA.theta)@ // r2.omega = der(PhA.theta)
eq_19 : z.i[1].re@ z.i[1].im@M // z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im
eq_20 : z.i[2].re@ z.i[2].im@M // z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im
eq_21 : z.i[3].re@ z.i[3].im@M // z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im
eq_22 : z.i[1].im@ z.i[1].re@M // z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re
eq_23 : z.i[2].im@ z.i[2].re@M // z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re
eq_24 : z.i[3].im@ z.i[3].re@M // z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re
eq_25 : z.omega@M der(PhA.theta)@ // z.omega = der(PhA.theta)
eq_26 : ground1.pin.iIm[1]@ test_DY1.hPin_N.iIm[1]@M z.i[1].im@ // ground1.pin.iIm[1] + (- r1.i[1].im) + (- r2.i[1].im) + test_DY1.hPin_N.iIm[1] + (- z.i[1].im) = 0
eq_27 : ground1.pin.iIm[2]@ test_DY1.hPin_N.iIm[2]@M z.i[2].im@ // ground1.pin.iIm[2] + (- r1.i[2].im) + (- r2.i[2].im) + test_DY1.hPin_N.iIm[2] + (- z.i[2].im) = 0
eq_28 : ground1.pin.iIm[3]@ test_DY1.hPin_N.iIm[3]@M z.i[3].im@ // ground1.pin.iIm[3] + (- r1.i[3].im) + (- r2.i[3].im) + test_DY1.hPin_N.iIm[3] + (- z.i[3].im) = 0
eq_29 : ground1.pin.iRe[1]@ test_DY1.hPin_N.iRe[1]@M z.i[1].re@ // ground1.pin.iRe[1] + (- r1.i[1].re) + (- r2.i[1].re) + test_DY1.hPin_N.iRe[1] + (- z.i[1].re) = 0
eq_30 : ground1.pin.iRe[2]@ test_DY1.hPin_N.iRe[2]@M z.i[2].re@ // ground1.pin.iRe[2] + (- r1.i[2].re) + (- r2.i[2].re) + test_DY1.hPin_N.iRe[2] + (- z.i[2].re) = 0
eq_31 : ground1.pin.iRe[3]@ test_DY1.hPin_N.iRe[3]@M z.i[3].re@ // ground1.pin.iRe[3] + (- r1.i[3].re) + (- r2.i[3].re) + test_DY1.hPin_N.iRe[3] + (- z.i[3].re) = 0
eq_32 : PhA.i[1].im@ PhC.i[1].im@ ground.pin.iIm[1]@M // - PhA.i[1].im + (- PhB.i[1].im) + (- PhC.i[1].im) + ground.pin.iIm[1] = 0
eq_33 : PhA.i[2].im@ PhC.i[2].im@ ground.pin.iIm[2]@M // - PhA.i[2].im + (- PhB.i[2].im) + (- PhC.i[2].im) + ground.pin.iIm[2] = 0
eq_34 : PhA.i[3].im@ PhC.i[3].im@ ground.pin.iIm[3]@M // - PhA.i[3].im + (- PhB.i[3].im) + (- PhC.i[3].im) + ground.pin.iIm[3] = 0
eq_35 : PhA.i[1].re@ PhC.i[1].re@ ground.pin.iRe[1]@M // - PhA.i[1].re + (- PhB.i[1].re) + (- PhC.i[1].re) + ground.pin.iRe[1] = 0
eq_36 : PhA.i[2].re@ PhC.i[2].re@ ground.pin.iRe[2]@M // - PhA.i[2].re + (- PhB.i[2].re) + (- PhC.i[2].re) + ground.pin.iRe[2] = 0
eq_37 : PhA.i[3].re@ PhC.i[3].re@ ground.pin.iRe[3]@M // - PhA.i[3].re + (- PhB.i[3].re) + (- PhC.i[3].re) + ground.pin.iRe[3] = 0
eq_38 : test_DY1.idealTransformer1.iPrim[1].im@ PhA.i[1].im@M // test_DY1.idealTransformer1.iPrim[1].im + (- test_DY1.idealTransformer2.iPrim[1].im) + PhA.i[1].im = 0
eq_39 : test_DY1.idealTransformer1.iPrim[2].im@ PhA.i[2].im@M // test_DY1.idealTransformer1.iPrim[2].im + (- test_DY1.idealTransformer2.iPrim[2].im) + PhA.i[2].im = 0
eq_40 : test_DY1.idealTransformer1.iPrim[3].im@ PhA.i[3].im@M // test_DY1.idealTransformer1.iPrim[3].im + (- test_DY1.idealTransformer2.iPrim[3].im) + PhA.i[3].im = 0
eq_41 : test_DY1.idealTransformer1.iPrim[1].re@ PhA.i[1].re@M // test_DY1.idealTransformer1.iPrim[1].re + (- test_DY1.idealTransformer2.iPrim[1].re) + PhA.i[1].re = 0
eq_42 : test_DY1.idealTransformer1.iPrim[2].re@ PhA.i[2].re@M // test_DY1.idealTransformer1.iPrim[2].re + (- test_DY1.idealTransformer2.iPrim[2].re) + PhA.i[2].re = 0
eq_43 : test_DY1.idealTransformer1.iPrim[3].re@ PhA.i[3].re@M // test_DY1.idealTransformer1.iPrim[3].re + (- test_DY1.idealTransformer2.iPrim[3].re) + PhA.i[3].re = 0
eq_44 : test_DY1.idealTransformer1.iPrim[1].im@ PhC.i[1].im@M // - test_DY1.idealTransformer1.iPrim[1].im + test_DY1.idealTransformer3.iPrim[1].im + PhC.i[1].im = 0
eq_45 : test_DY1.idealTransformer1.iPrim[2].im@ PhC.i[2].im@M // - test_DY1.idealTransformer1.iPrim[2].im + test_DY1.idealTransformer3.iPrim[2].im + PhC.i[2].im = 0
eq_46 : test_DY1.idealTransformer1.iPrim[3].im@ PhC.i[3].im@M // - test_DY1.idealTransformer1.iPrim[3].im + test_DY1.idealTransformer3.iPrim[3].im + PhC.i[3].im = 0
eq_47 : test_DY1.idealTransformer1.iPrim[1].re@ PhC.i[1].re@M // - test_DY1.idealTransformer1.iPrim[1].re + test_DY1.idealTransformer3.iPrim[1].re + PhC.i[1].re = 0
eq_48 : test_DY1.idealTransformer1.iPrim[2].re@ PhC.i[2].re@M // - test_DY1.idealTransformer1.iPrim[2].re + test_DY1.idealTransformer3.iPrim[2].re + PhC.i[2].re = 0
eq_49 : test_DY1.idealTransformer1.iPrim[3].re@ PhC.i[3].re@M // - test_DY1.idealTransformer1.iPrim[3].re + test_DY1.idealTransformer3.iPrim[3].re + PhC.i[3].re = 0
eq_50 : ground1.pin.iIm[1]@M // 0 = ground1.pin.iIm[1]
eq_51 : ground1.pin.iIm[2]@M // 0 = ground1.pin.iIm[2]
eq_52 : ground1.pin.iIm[3]@M // 0 = ground1.pin.iIm[3]
eq_53 : ground1.pin.iRe[1]@M // 0 = ground1.pin.iRe[1]
eq_54 : ground1.pin.iRe[2]@M // 0 = ground1.pin.iRe[2]
eq_55 : ground1.pin.iRe[3]@M // 0 = ground1.pin.iRe[3]
eq_56 : PhA.theta# // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_57 : PhA.theta# // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_58 : PhC.theta# PhA.theta# // HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhC.theta), HPF.Types.Reference(PhA.theta))
eq_59 : PhB.theta# PhA.theta# // HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))
eq_60 : PhA.theta# // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_61 : PhB.theta# PhA.theta# // HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))
eq_62 : PhA.theta# PhC.theta# // HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhC.theta))
eq_63 : PhA.theta# // HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_64 : PhA.theta# // HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_65 : PhA.theta# // HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_66 : z.iFundAbs@M z.i[1].re@ z.i[1].im@ // z.iFundAbs = (z.i[1].re ^ 2 + z.i[1].im ^ 2) ^ 0.5
eq_67 : z.iFundArg@M z.i[1].im@ z.i[1].re@ // z.iFundArg = Modelica.Math.atan3(z.i[1].im, z.i[1].re, 0)
eq_68 : systemDef.modeSelect@M // algorithm
 systemDef.modeSelect := false;


Init BiPGraph matching
----------------------------------------
BiPGraph matching:
eq_1 : temp_62
eq_2 : temp_63
eq_3 : temp_64
eq_5 : test_DY1.idealTransformer1.iPrim[1].re
eq_6 : test_DY1.idealTransformer1.iPrim[1].im
eq_7 : test_DY1.idealTransformer1.iPrim[2].re
eq_8 : test_DY1.idealTransformer1.iPrim[2].im
eq_9 : test_DY1.idealTransformer1.iPrim[3].re
eq_10 : test_DY1.idealTransformer1.iPrim[3].im
eq_11 : der(PhA.theta)
eq_12 : PhA.omega
eq_13 : der(PhB.theta)
eq_14 : PhB.omega
eq_15 : der(PhC.theta)
eq_16 : PhC.omega
eq_17 : r1.omega
eq_18 : r2.omega
eq_19 : z.i[1].im
eq_20 : z.i[2].im
eq_21 : z.i[3].im
eq_22 : z.i[1].re
eq_23 : z.i[2].re
eq_24 : z.i[3].re
eq_25 : z.omega
eq_26 : test_DY1.hPin_N.iIm[1]
eq_27 : test_DY1.hPin_N.iIm[2]
eq_28 : test_DY1.hPin_N.iIm[3]
eq_29 : test_DY1.hPin_N.iRe[1]
eq_30 : test_DY1.hPin_N.iRe[2]
eq_31 : test_DY1.hPin_N.iRe[3]
eq_32 : ground.pin.iIm[1]
eq_33 : ground.pin.iIm[2]
eq_34 : ground.pin.iIm[3]
eq_35 : ground.pin.iRe[1]
eq_36 : ground.pin.iRe[2]
eq_37 : ground.pin.iRe[3]
eq_38 : PhA.i[1].im
eq_39 : PhA.i[2].im
eq_40 : PhA.i[3].im
eq_41 : PhA.i[1].re
eq_42 : PhA.i[2].re
eq_43 : PhA.i[3].re
eq_44 : PhC.i[1].im
eq_45 : PhC.i[2].im
eq_46 : PhC.i[3].im
eq_47 : PhC.i[1].re
eq_48 : PhC.i[2].re
eq_49 : PhC.i[3].re
eq_50 : ground1.pin.iIm[1]
eq_51 : ground1.pin.iIm[2]
eq_52 : ground1.pin.iIm[3]
eq_53 : ground1.pin.iRe[1]
eq_54 : ground1.pin.iRe[2]
eq_55 : ground1.pin.iRe[3]
eq_66 : z.iFundAbs
eq_67 : z.iFundArg
eq_68 : systemDef.modeSelect
Unmatched equations: {}
Unmatched variables: {systemDef.event1 systemDef.event2 PhA.theta PhB.theta PhC.theta pre(systemDef.modeSelect) pre(systemDef.event1) pre(systemDef.event2) pre(temp_62) pre(temp_63) pre(temp_64) }
----------------------------------------

Analysing initial system for redundant equations to remove.
All seems to be ok!
Init DAE BiPGraph after addition of initial equations
BiPGraph (78 equations, 68 variables)
Variables: {der(PhA.theta) der(PhB.theta) der(PhC.theta) test_DY1.idealTransformer1.iPrim[1].re test_DY1.idealTransformer1.iPrim[1].im test_DY1.idealTransformer1.iPrim[2].re test_DY1.idealTransformer1.iPrim[2].im test_DY1.idealTransformer1.iPrim[3].re test_DY1.idealTransformer1.iPrim[3].im test_DY1.hPin_N.iIm[1] test_DY1.hPin_N.iIm[2] test_DY1.hPin_N.iIm[3] test_DY1.hPin_N.iRe[1] test_DY1.hPin_N.iRe[2] test_DY1.hPin_N.iRe[3] PhA.i[1].re PhA.i[1].im PhA.i[2].re PhA.i[2].im PhA.i[3].re PhA.i[3].im PhA.omega PhB.omega PhC.i[1].re PhC.i[1].im PhC.i[2].re PhC.i[2].im PhC.i[3].re PhC.i[3].im PhC.omega ground.pin.iIm[1] ground.pin.iIm[2] ground.pin.iIm[3] ground.pin.iRe[1] ground.pin.iRe[2] ground.pin.iRe[3] ground1.pin.iIm[1] ground1.pin.iIm[2] ground1.pin.iIm[3] ground1.pin.iRe[1] ground1.pin.iRe[2] ground1.pin.iRe[3] r1.omega r2.omega z.iFundAbs z.iFundArg z.i[1].re z.i[1].im z.i[2].re z.i[2].im z.i[3].re z.i[3].im z.omega systemDef.modeSelect systemDef.event1 systemDef.event2 temp_62 temp_63 temp_64 PhA.theta PhB.theta PhC.theta pre(systemDef.modeSelect) pre(systemDef.event1) pre(systemDef.event2) pre(temp_62) pre(temp_63) pre(temp_64) }
eq_1 : temp_62@M // temp_62 = time > 0.5
eq_2 : temp_63@M // temp_63 = time > 0.25
eq_3 : temp_64@M // temp_64 = time > 0.4
eq_5 : z.i[1].re@ test_DY1.idealTransformer1.iPrim[1].re@M // - z.i[1].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].re
eq_6 : z.i[1].im@ test_DY1.idealTransformer1.iPrim[1].im@M // - z.i[1].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].im
eq_7 : z.i[2].re@ test_DY1.idealTransformer1.iPrim[2].re@M // - z.i[2].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].re
eq_8 : z.i[2].im@ test_DY1.idealTransformer1.iPrim[2].im@M // - z.i[2].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].im
eq_9 : z.i[3].re@ test_DY1.idealTransformer1.iPrim[3].re@M // - z.i[3].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].re
eq_10 : z.i[3].im@ test_DY1.idealTransformer1.iPrim[3].im@M // - z.i[3].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].im
eq_11 : der(PhA.theta)@M // der(PhA.theta) = 6.283185307179586 * systemDef.fFund
eq_12 : PhA.omega@M der(PhA.theta)@ // PhA.omega = der(PhA.theta)
eq_13 : der(PhB.theta)@M // der(PhB.theta) = 6.283185307179586 * systemDef.fFund
eq_14 : PhB.omega@M der(PhB.theta)@ // PhB.omega = der(PhB.theta)
eq_15 : der(PhC.theta)@M // der(PhC.theta) = 6.283185307179586 * systemDef.fFund
eq_16 : PhC.omega@M der(PhC.theta)@ // PhC.omega = der(PhC.theta)
eq_17 : r1.omega@M der(PhA.theta)@ // r1.omega = der(PhA.theta)
eq_18 : r2.omega@M der(PhA.theta)@ // r2.omega = der(PhA.theta)
eq_19 : z.i[1].re@ z.i[1].im@M // z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im
eq_20 : z.i[2].re@ z.i[2].im@M // z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im
eq_21 : z.i[3].re@ z.i[3].im@M // z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im
eq_22 : z.i[1].im@ z.i[1].re@M // z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re
eq_23 : z.i[2].im@ z.i[2].re@M // z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re
eq_24 : z.i[3].im@ z.i[3].re@M // z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re
eq_25 : z.omega@M der(PhA.theta)@ // z.omega = der(PhA.theta)
eq_26 : ground1.pin.iIm[1]@ test_DY1.hPin_N.iIm[1]@M z.i[1].im@ // ground1.pin.iIm[1] + (- r1.i[1].im) + (- r2.i[1].im) + test_DY1.hPin_N.iIm[1] + (- z.i[1].im) = 0
eq_27 : ground1.pin.iIm[2]@ test_DY1.hPin_N.iIm[2]@M z.i[2].im@ // ground1.pin.iIm[2] + (- r1.i[2].im) + (- r2.i[2].im) + test_DY1.hPin_N.iIm[2] + (- z.i[2].im) = 0
eq_28 : ground1.pin.iIm[3]@ test_DY1.hPin_N.iIm[3]@M z.i[3].im@ // ground1.pin.iIm[3] + (- r1.i[3].im) + (- r2.i[3].im) + test_DY1.hPin_N.iIm[3] + (- z.i[3].im) = 0
eq_29 : ground1.pin.iRe[1]@ test_DY1.hPin_N.iRe[1]@M z.i[1].re@ // ground1.pin.iRe[1] + (- r1.i[1].re) + (- r2.i[1].re) + test_DY1.hPin_N.iRe[1] + (- z.i[1].re) = 0
eq_30 : ground1.pin.iRe[2]@ test_DY1.hPin_N.iRe[2]@M z.i[2].re@ // ground1.pin.iRe[2] + (- r1.i[2].re) + (- r2.i[2].re) + test_DY1.hPin_N.iRe[2] + (- z.i[2].re) = 0
eq_31 : ground1.pin.iRe[3]@ test_DY1.hPin_N.iRe[3]@M z.i[3].re@ // ground1.pin.iRe[3] + (- r1.i[3].re) + (- r2.i[3].re) + test_DY1.hPin_N.iRe[3] + (- z.i[3].re) = 0
eq_32 : PhA.i[1].im@ PhC.i[1].im@ ground.pin.iIm[1]@M // - PhA.i[1].im + (- PhB.i[1].im) + (- PhC.i[1].im) + ground.pin.iIm[1] = 0
eq_33 : PhA.i[2].im@ PhC.i[2].im@ ground.pin.iIm[2]@M // - PhA.i[2].im + (- PhB.i[2].im) + (- PhC.i[2].im) + ground.pin.iIm[2] = 0
eq_34 : PhA.i[3].im@ PhC.i[3].im@ ground.pin.iIm[3]@M // - PhA.i[3].im + (- PhB.i[3].im) + (- PhC.i[3].im) + ground.pin.iIm[3] = 0
eq_35 : PhA.i[1].re@ PhC.i[1].re@ ground.pin.iRe[1]@M // - PhA.i[1].re + (- PhB.i[1].re) + (- PhC.i[1].re) + ground.pin.iRe[1] = 0
eq_36 : PhA.i[2].re@ PhC.i[2].re@ ground.pin.iRe[2]@M // - PhA.i[2].re + (- PhB.i[2].re) + (- PhC.i[2].re) + ground.pin.iRe[2] = 0
eq_37 : PhA.i[3].re@ PhC.i[3].re@ ground.pin.iRe[3]@M // - PhA.i[3].re + (- PhB.i[3].re) + (- PhC.i[3].re) + ground.pin.iRe[3] = 0
eq_38 : test_DY1.idealTransformer1.iPrim[1].im@ PhA.i[1].im@M // test_DY1.idealTransformer1.iPrim[1].im + (- test_DY1.idealTransformer2.iPrim[1].im) + PhA.i[1].im = 0
eq_39 : test_DY1.idealTransformer1.iPrim[2].im@ PhA.i[2].im@M // test_DY1.idealTransformer1.iPrim[2].im + (- test_DY1.idealTransformer2.iPrim[2].im) + PhA.i[2].im = 0
eq_40 : test_DY1.idealTransformer1.iPrim[3].im@ PhA.i[3].im@M // test_DY1.idealTransformer1.iPrim[3].im + (- test_DY1.idealTransformer2.iPrim[3].im) + PhA.i[3].im = 0
eq_41 : test_DY1.idealTransformer1.iPrim[1].re@ PhA.i[1].re@M // test_DY1.idealTransformer1.iPrim[1].re + (- test_DY1.idealTransformer2.iPrim[1].re) + PhA.i[1].re = 0
eq_42 : test_DY1.idealTransformer1.iPrim[2].re@ PhA.i[2].re@M // test_DY1.idealTransformer1.iPrim[2].re + (- test_DY1.idealTransformer2.iPrim[2].re) + PhA.i[2].re = 0
eq_43 : test_DY1.idealTransformer1.iPrim[3].re@ PhA.i[3].re@M // test_DY1.idealTransformer1.iPrim[3].re + (- test_DY1.idealTransformer2.iPrim[3].re) + PhA.i[3].re = 0
eq_44 : test_DY1.idealTransformer1.iPrim[1].im@ PhC.i[1].im@M // - test_DY1.idealTransformer1.iPrim[1].im + test_DY1.idealTransformer3.iPrim[1].im + PhC.i[1].im = 0
eq_45 : test_DY1.idealTransformer1.iPrim[2].im@ PhC.i[2].im@M // - test_DY1.idealTransformer1.iPrim[2].im + test_DY1.idealTransformer3.iPrim[2].im + PhC.i[2].im = 0
eq_46 : test_DY1.idealTransformer1.iPrim[3].im@ PhC.i[3].im@M // - test_DY1.idealTransformer1.iPrim[3].im + test_DY1.idealTransformer3.iPrim[3].im + PhC.i[3].im = 0
eq_47 : test_DY1.idealTransformer1.iPrim[1].re@ PhC.i[1].re@M // - test_DY1.idealTransformer1.iPrim[1].re + test_DY1.idealTransformer3.iPrim[1].re + PhC.i[1].re = 0
eq_48 : test_DY1.idealTransformer1.iPrim[2].re@ PhC.i[2].re@M // - test_DY1.idealTransformer1.iPrim[2].re + test_DY1.idealTransformer3.iPrim[2].re + PhC.i[2].re = 0
eq_49 : test_DY1.idealTransformer1.iPrim[3].re@ PhC.i[3].re@M // - test_DY1.idealTransformer1.iPrim[3].re + test_DY1.idealTransformer3.iPrim[3].re + PhC.i[3].re = 0
eq_50 : ground1.pin.iIm[1]@M // 0 = ground1.pin.iIm[1]
eq_51 : ground1.pin.iIm[2]@M // 0 = ground1.pin.iIm[2]
eq_52 : ground1.pin.iIm[3]@M // 0 = ground1.pin.iIm[3]
eq_53 : ground1.pin.iRe[1]@M // 0 = ground1.pin.iRe[1]
eq_54 : ground1.pin.iRe[2]@M // 0 = ground1.pin.iRe[2]
eq_55 : ground1.pin.iRe[3]@M // 0 = ground1.pin.iRe[3]
eq_56 : PhA.theta# // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_57 : PhA.theta# // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_58 : PhC.theta# PhA.theta# // HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhC.theta), HPF.Types.Reference(PhA.theta))
eq_59 : PhB.theta# PhA.theta# // HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))
eq_60 : PhA.theta# // HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_61 : PhB.theta# PhA.theta# // HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))
eq_62 : PhA.theta# PhC.theta# // HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhC.theta))
eq_63 : PhA.theta# // HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_64 : PhA.theta# // HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_65 : PhA.theta# // HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))
eq_66 : z.iFundAbs@M z.i[1].re@ z.i[1].im@ // z.iFundAbs = (z.i[1].re ^ 2 + z.i[1].im ^ 2) ^ 0.5
eq_67 : z.iFundArg@M z.i[1].im@ z.i[1].re@ // z.iFundArg = Modelica.Math.atan3(z.i[1].im, z.i[1].re, 0)
eq_68 : systemDef.modeSelect@M // algorithm
 systemDef.modeSelect := false;

eq_69 : systemDef.event1@M pre(systemDef.event1)@ // systemDef.event1 = pre(systemDef.event1)
eq_70 : systemDef.event2@M pre(systemDef.event2)@ // systemDef.event2 = pre(systemDef.event2)
eq_71 : PhA.theta@M // PhA.theta = 0
eq_72 : PhB.theta@M // PhB.theta = 0
eq_73 : PhC.theta@M // PhC.theta = 0
eq_74 : systemDef.modeSelect@ pre(systemDef.modeSelect)@M // systemDef.modeSelect = pre(systemDef.modeSelect)
eq_75 : pre(systemDef.event1)@M // pre(systemDef.event1) = false
eq_76 : pre(systemDef.event2)@M // pre(systemDef.event2) = false
eq_77 : pre(temp_62)@M // pre(temp_62) = false
eq_78 : pre(temp_63)@M // pre(temp_63) = false
eq_79 : pre(temp_64)@M // pre(temp_64) = false

Init BiPGraph matching after addition of initial equations
----------------------------------------
BiPGraph matching:
eq_1 : temp_62
eq_2 : temp_63
eq_3 : temp_64
eq_5 : test_DY1.idealTransformer1.iPrim[1].re
eq_6 : test_DY1.idealTransformer1.iPrim[1].im
eq_7 : test_DY1.idealTransformer1.iPrim[2].re
eq_8 : test_DY1.idealTransformer1.iPrim[2].im
eq_9 : test_DY1.idealTransformer1.iPrim[3].re
eq_10 : test_DY1.idealTransformer1.iPrim[3].im
eq_11 : der(PhA.theta)
eq_12 : PhA.omega
eq_13 : der(PhB.theta)
eq_14 : PhB.omega
eq_15 : der(PhC.theta)
eq_16 : PhC.omega
eq_17 : r1.omega
eq_18 : r2.omega
eq_19 : z.i[1].im
eq_20 : z.i[2].im
eq_21 : z.i[3].im
eq_22 : z.i[1].re
eq_23 : z.i[2].re
eq_24 : z.i[3].re
eq_25 : z.omega
eq_26 : test_DY1.hPin_N.iIm[1]
eq_27 : test_DY1.hPin_N.iIm[2]
eq_28 : test_DY1.hPin_N.iIm[3]
eq_29 : test_DY1.hPin_N.iRe[1]
eq_30 : test_DY1.hPin_N.iRe[2]
eq_31 : test_DY1.hPin_N.iRe[3]
eq_32 : ground.pin.iIm[1]
eq_33 : ground.pin.iIm[2]
eq_34 : ground.pin.iIm[3]
eq_35 : ground.pin.iRe[1]
eq_36 : ground.pin.iRe[2]
eq_37 : ground.pin.iRe[3]
eq_38 : PhA.i[1].im
eq_39 : PhA.i[2].im
eq_40 : PhA.i[3].im
eq_41 : PhA.i[1].re
eq_42 : PhA.i[2].re
eq_43 : PhA.i[3].re
eq_44 : PhC.i[1].im
eq_45 : PhC.i[2].im
eq_46 : PhC.i[3].im
eq_47 : PhC.i[1].re
eq_48 : PhC.i[2].re
eq_49 : PhC.i[3].re
eq_50 : ground1.pin.iIm[1]
eq_51 : ground1.pin.iIm[2]
eq_52 : ground1.pin.iIm[3]
eq_53 : ground1.pin.iRe[1]
eq_54 : ground1.pin.iRe[2]
eq_55 : ground1.pin.iRe[3]
eq_66 : z.iFundAbs
eq_67 : z.iFundArg
eq_68 : systemDef.modeSelect
eq_69 : systemDef.event1
eq_70 : systemDef.event2
eq_71 : PhA.theta
eq_72 : PhB.theta
eq_73 : PhC.theta
eq_74 : pre(systemDef.modeSelect)
eq_75 : pre(systemDef.event1)
eq_76 : pre(systemDef.event2)
eq_77 : pre(temp_62)
eq_78 : pre(temp_63)
eq_79 : pre(temp_64)
Unmatched equations: {}
Unmatched variables: {}
----------------------------------------

Initial system contains homotopy, computing homotopy block components...
... block components computed: []
Starting automatic tearing
BiPGraph (2 equations, 2 variables)
Variables: {z.i[1].im z.i[1].re }
eq_19 : z.i[1].re# z.i[1].im# // z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im
eq_22 : z.i[1].im# z.i[1].re# // z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re

Initial matching
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_19 eq_22 }
Unmatched variables: {z.i[1].im z.i[1].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_19 eq_22 }
Unmatched variables: {z.i[1].im z.i[1].re }
----------------------------------------

Automatic tearing pair, equation: z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im, tearing with variable: z.i[1].im
Automatic tearing pair, equation: z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re, tearing with variable: z.i[1].re
Starting automatic tearing
BiPGraph (2 equations, 2 variables)
Variables: {z.i[2].im z.i[2].re }
eq_20 : z.i[2].re# z.i[2].im# // z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im
eq_23 : z.i[2].im# z.i[2].re# // z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re

Initial matching
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_20 eq_23 }
Unmatched variables: {z.i[2].im z.i[2].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_20 eq_23 }
Unmatched variables: {z.i[2].im z.i[2].re }
----------------------------------------

Automatic tearing pair, equation: z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im, tearing with variable: z.i[2].im
Automatic tearing pair, equation: z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re, tearing with variable: z.i[2].re
Starting automatic tearing
BiPGraph (2 equations, 2 variables)
Variables: {z.i[3].im z.i[3].re }
eq_21 : z.i[3].re# z.i[3].im# // z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im
eq_24 : z.i[3].im# z.i[3].re# // z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re

Initial matching
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_21 eq_24 }
Unmatched variables: {z.i[3].im z.i[3].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
Unmatched equations: {eq_21 eq_24 }
Unmatched variables: {z.i[3].im z.i[3].re }
----------------------------------------

Automatic tearing pair, equation: z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im, tearing with variable: z.i[3].im
Automatic tearing pair, equation: z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re, tearing with variable: z.i[3].re
--- Solved equation ---
temp_62 := time > 0.5

--- Solved equation ---
temp_63 := time > 0.25

--- Solved equation ---
temp_64 := time > 0.4

--- Unsolved linear system (Block 1) of 2 variables ---
Coefficient variability: parameter
Unknown variables:
  z.i[1].im
  z.i[1].re

Equations:
  z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im
    Iteration variables: z.i[1].im
  z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re
    Iteration variables: z.i[1].re

Jacobian:
  |z.z.im .* systemDef.hrms[1], - z.z.re|
  |- z.z.re, - z.z.im .* systemDef.hrms[1]|

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[1].re := z.i[1].re / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[1].im := z.i[1].im / (- test_DY1.idealTransformer1.N)

--- Unsolved linear system (Block 2) of 2 variables ---
Coefficient variability: parameter
Unknown variables:
  z.i[2].im
  z.i[2].re

Equations:
  z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im
    Iteration variables: z.i[2].im
  z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re
    Iteration variables: z.i[2].re

Jacobian:
  |z.z.im .* systemDef.hrms[2], - z.z.re|
  |- z.z.re, - z.z.im .* systemDef.hrms[2]|

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[2].re := z.i[2].re / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[2].im := z.i[2].im / (- test_DY1.idealTransformer1.N)

--- Unsolved linear system (Block 3) of 2 variables ---
Coefficient variability: parameter
Unknown variables:
  z.i[3].im
  z.i[3].re

Equations:
  z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im
    Iteration variables: z.i[3].im
  z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re
    Iteration variables: z.i[3].re

Jacobian:
  |z.z.im .* systemDef.hrms[3], - z.z.re|
  |- z.z.re, - z.z.im .* systemDef.hrms[3]|

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[3].re := z.i[3].re / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
test_DY1.idealTransformer1.iPrim[3].im := z.i[3].im / (- test_DY1.idealTransformer1.N)

--- Solved equation ---
der(PhA.theta) := 6.283185307179586 * systemDef.fFund

--- Solved equation ---
PhA.omega := der(PhA.theta)

--- Solved equation ---
der(PhB.theta) := 6.283185307179586 * systemDef.fFund

--- Solved equation ---
PhB.omega := der(PhB.theta)

--- Solved equation ---
der(PhC.theta) := 6.283185307179586 * systemDef.fFund

--- Solved equation ---
PhC.omega := der(PhC.theta)

--- Solved equation ---
r1.omega := der(PhA.theta)

--- Solved equation ---
r2.omega := der(PhA.theta)

--- Solved equation ---
z.omega := der(PhA.theta)

--- Solved equation ---
ground1.pin.iIm[1] := 0

--- Solved equation ---
test_DY1.hPin_N.iIm[1] := - ground1.pin.iIm[1] + r1.i[1].im + r2.i[1].im + z.i[1].im

--- Solved equation ---
ground1.pin.iIm[2] := 0

--- Solved equation ---
test_DY1.hPin_N.iIm[2] := - ground1.pin.iIm[2] + r1.i[2].im + r2.i[2].im + z.i[2].im

--- Solved equation ---
ground1.pin.iIm[3] := 0

--- Solved equation ---
test_DY1.hPin_N.iIm[3] := - ground1.pin.iIm[3] + r1.i[3].im + r2.i[3].im + z.i[3].im

--- Solved equation ---
ground1.pin.iRe[1] := 0

--- Solved equation ---
test_DY1.hPin_N.iRe[1] := - ground1.pin.iRe[1] + r1.i[1].re + r2.i[1].re + z.i[1].re

--- Solved equation ---
ground1.pin.iRe[2] := 0

--- Solved equation ---
test_DY1.hPin_N.iRe[2] := - ground1.pin.iRe[2] + r1.i[2].re + r2.i[2].re + z.i[2].re

--- Solved equation ---
ground1.pin.iRe[3] := 0

--- Solved equation ---
test_DY1.hPin_N.iRe[3] := - ground1.pin.iRe[3] + r1.i[3].re + r2.i[3].re + z.i[3].re

--- Solved equation ---
PhA.i[1].im := - test_DY1.idealTransformer1.iPrim[1].im + test_DY1.idealTransformer2.iPrim[1].im

--- Solved equation ---
PhC.i[1].im := test_DY1.idealTransformer1.iPrim[1].im + (- test_DY1.idealTransformer3.iPrim[1].im)

--- Solved equation ---
ground.pin.iIm[1] := PhA.i[1].im + PhB.i[1].im + PhC.i[1].im

--- Solved equation ---
PhA.i[2].im := - test_DY1.idealTransformer1.iPrim[2].im + test_DY1.idealTransformer2.iPrim[2].im

--- Solved equation ---
PhC.i[2].im := test_DY1.idealTransformer1.iPrim[2].im + (- test_DY1.idealTransformer3.iPrim[2].im)

--- Solved equation ---
ground.pin.iIm[2] := PhA.i[2].im + PhB.i[2].im + PhC.i[2].im

--- Solved equation ---
PhA.i[3].im := - test_DY1.idealTransformer1.iPrim[3].im + test_DY1.idealTransformer2.iPrim[3].im

--- Solved equation ---
PhC.i[3].im := test_DY1.idealTransformer1.iPrim[3].im + (- test_DY1.idealTransformer3.iPrim[3].im)

--- Solved equation ---
ground.pin.iIm[3] := PhA.i[3].im + PhB.i[3].im + PhC.i[3].im

--- Solved equation ---
PhA.i[1].re := - test_DY1.idealTransformer1.iPrim[1].re + test_DY1.idealTransformer2.iPrim[1].re

--- Solved equation ---
PhC.i[1].re := test_DY1.idealTransformer1.iPrim[1].re + (- test_DY1.idealTransformer3.iPrim[1].re)

--- Solved equation ---
ground.pin.iRe[1] := PhA.i[1].re + PhB.i[1].re + PhC.i[1].re

--- Solved equation ---
PhA.i[2].re := - test_DY1.idealTransformer1.iPrim[2].re + test_DY1.idealTransformer2.iPrim[2].re

--- Solved equation ---
PhC.i[2].re := test_DY1.idealTransformer1.iPrim[2].re + (- test_DY1.idealTransformer3.iPrim[2].re)

--- Solved equation ---
ground.pin.iRe[2] := PhA.i[2].re + PhB.i[2].re + PhC.i[2].re

--- Solved equation ---
PhA.i[3].re := - test_DY1.idealTransformer1.iPrim[3].re + test_DY1.idealTransformer2.iPrim[3].re

--- Solved equation ---
PhC.i[3].re := test_DY1.idealTransformer1.iPrim[3].re + (- test_DY1.idealTransformer3.iPrim[3].re)

--- Solved equation ---
ground.pin.iRe[3] := PhA.i[3].re + PhB.i[3].re + PhC.i[3].re

--- Solved equation ---
PhA.theta := 0

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Solved equation ---
PhC.theta := 0

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhC.theta), HPF.Types.Reference(PhA.theta))

--- Solved equation ---
PhB.theta := 0

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhC.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Meta equation block ---
HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta))

--- Solved equation ---
z.iFundAbs := (z.i[1].re ^ 2 + z.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
z.iFundArg := Modelica.Math.atan3(z.i[1].im, z.i[1].re, 0)

--- Solved algorithm ---
algorithm
  systemDef.modeSelect := false;

  Assigned variables: systemDef.modeSelect

--- Solved equation ---
pre(systemDef.event1) := false

--- Solved equation ---
systemDef.event1 := pre(systemDef.event1)

--- Solved equation ---
pre(systemDef.event2) := false

--- Solved equation ---
systemDef.event2 := pre(systemDef.event2)

--- Solved equation ---
pre(systemDef.modeSelect) := systemDef.modeSelect

--- Solved equation ---
pre(temp_62) := false

--- Solved equation ---
pre(temp_63) := false

--- Solved equation ---
pre(temp_64) := false
-------------------------------

Diagnostics for transformed flattened model:
Diagnostics for flattened class HPF.Test.Multiphase_Transformer
Number of independent constants:                   2(    2 scalars)
  Number of Real independent constants:            2(    2 scalars)
  Number of Real independent constants:            2(    2 scalars)
  Number of Integer independent constants:         0(    0 scalars)
  Number of Enum independent constants:            0(    0 scalars)
  Number of Boolean independent constants:         0(    0 scalars)
  Number of String independent constants:          0(    0 scalars)
Number of dependent constants:                     0(    0 scalars)
  Number of Real dependent constants:              0(    0 scalars)
  Number of Integer dependent constants:           0(    0 scalars)
  Number of Enum dependent constants:              0(    0 scalars)
  Number of Boolean dependent constants:           0(    0 scalars)
  Number of String dependent constants:            0(    0 scalars)
Number of independent parameters:                 69(   69 scalars)
  Number of Real independent parameters:          37(   37 scalars)
  Number of Integer independent parameters:       19(   19 scalars)
  Number of Enum independent parameters:           0(    0 scalars)
  Number of Boolean independent parameters:       13(   13 scalars)
  Number of String independent parameters:         0(    0 scalars)
Number of dependent parameters:                  106(  106 scalars)
  Number of Real dependent parameters:           106(  106 scalars)
  Number of Integer dependent parameters:          0(    0 scalars)
  Number of Enum dependent parameters:             0(    0 scalars)
  Number of Boolean dependent parameters:          0(    0 scalars)
  Number of String dependent parameters:           0(    0 scalars)
Number of initial parameters:                      0(    0 scalars)
  Number of Real dependent parameters:             0(    0 scalars)
  Number of Integer dependent parameters:          0(    0 scalars)
  Number of Enum dependent parameters:             0(    0 scalars)
  Number of Boolean dependent parameters:          0(    0 scalars)
  Number of String dependent parameters:           0(    0 scalars)
Number of variables:                              62(   62 scalars)
  Number of Real variables:                       56(   56 scalars)
  Number of Integer variables:                     0(    0 scalars)
  Number of Enum variables:                        0(    0 scalars)
  Number of Boolean variables:                     6(    6 scalars)
  Number of String variables:                      0(    0 scalars)
Number of Real differentiated variables:           3(    3 scalars)
Number of Real derivative variables:               3(    3 scalars)
Number of Real continous algebraic variables:     50(   50 scalars)
Number of inputs:                                  0(    0 scalars)
  Number of Real inputs:                           0(    0 scalars)
  Number of Integer inputs:                        0(    0 scalars)
  Number of Enum inputs:                           0(    0 scalars)
  Number of Boolean inputs:                        0(    0 scalars)
  Number of String inputs:                         0(    0 scalars)
Number of discrete variables:                      6(    6 scalars)
  Number of Real discrete variables:               0(    0 scalars)
  Number of Integer discrete variables:            0(    0 scalars)
  Number of Enum discrete variables:               0(    0 scalars)
  Number of Boolean discrete variables:            6(    6 scalars)
  Number of String discrete variables:             0(    0 scalars)
Number of equations:                              67(   59 scalars)
Number of variables with binding expression:       0(    0 scalars)
  Number of Real variables with binding exp:       0(    0 scalars)
  Number of Integer variables binding exp:         0(    0 scalars)
  Number of Enum variables binding exp:            0(    0 scalars)
  Number of Boolean variables binding exp:         0(    0 scalars)
  Number of String variables binding exp:          0(    0 scalars)
Total number of equations:                        67(   59 scalars)
Number of initial equations:                       9(    9 scalars)
Number of event indicators in equations:           0
Number of event indicators in init equations:      0

Independent constants: 
 PhA.pin_n.v[1].re: number of uses: 0, isLinear: true
 PhA.pin_n.v[1].im: number of uses: 0, isLinear: true

Dependent constants: 

Independent parameters: 
 systemDef.fFund: number of uses: 3, isLinear: true, evaluated binding exp: 60
 PhA.vMag[1]: number of uses: 2, isLinear: true, evaluated binding exp: 392
 PhA.vMag[2]: number of uses: 2, isLinear: true, evaluated binding exp: 10
 PhA.vMag[3]: number of uses: 2, isLinear: true, evaluated binding exp: 3
 PhA.vArg[1]: number of uses: 2, isLinear: true, evaluated binding exp: 0
 PhA.vArg[2]: number of uses: 2, isLinear: true, evaluated binding exp: 0.5
 PhA.vArg[3]: number of uses: 2, isLinear: true, evaluated binding exp: 2.3
 PhB.vMag[1]: number of uses: 2, isLinear: true, evaluated binding exp: 392
 PhB.vMag[2]: number of uses: 2, isLinear: true, evaluated binding exp: 11
 PhB.vMag[3]: number of uses: 2, isLinear: true, evaluated binding exp: 2.6
 PhB.vArg[1]: number of uses: 2, isLinear: true, evaluated binding exp: -2.0943951023931953
 PhB.vArg[2]: number of uses: 2, isLinear: true, evaluated binding exp: 0
 PhB.vArg[3]: number of uses: 2, isLinear: true, evaluated binding exp: 1.2
 PhC.vMag[1]: number of uses: 2, isLinear: true, evaluated binding exp: 392
 PhC.vMag[2]: number of uses: 2, isLinear: true, evaluated binding exp: 10
 PhC.vMag[3]: number of uses: 2, isLinear: true, evaluated binding exp: 3
 PhC.vArg[1]: number of uses: 2, isLinear: true, evaluated binding exp: 2.0943951023931953
 PhC.vArg[2]: number of uses: 2, isLinear: true, evaluated binding exp: 0.6
 PhC.vArg[3]: number of uses: 2, isLinear: true, evaluated binding exp: 2.1
 r1.r: number of uses: 6, isLinear: true, evaluated binding exp: 500
 r2.r: number of uses: 6, isLinear: true, evaluated binding exp: 500
 z.z.re: number of uses: 6, isLinear: true, evaluated binding exp: 500
 z.z.im: number of uses: 6, isLinear: true, evaluated binding exp: 20
 _block_jacobian_check_tol: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-6
 _cs_rel_tol: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-6
 _cs_step_size: number of uses: 0, isLinear: true, evaluated binding exp: 0.001
 _events_default_tol: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-10
 _events_tol_factor: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-4
 _nle_jacobian_finite_difference_delta: number of uses: 0, isLinear: true, evaluated binding exp: 1.490116119384766E-8
 _nle_solver_default_tol: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-10
 _nle_solver_max_residual_scaling_factor: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E10
 _nle_solver_min_residual_scaling_factor: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-10
 _nle_solver_min_tol: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-12
 _nle_solver_regularization_tolerance: number of uses: 0, isLinear: true, evaluated binding exp: -1.0
 _nle_solver_step_limit_factor: number of uses: 0, isLinear: true, evaluated binding exp: 10.0
 _nle_solver_tol_factor: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-4
 _time_events_default_tol: number of uses: 0, isLinear: true, evaluated binding exp: 2.220446049250313E-14
 systemDef.hrms[1]: number of uses: 2, isLinear: true, evaluated binding exp: 1
 systemDef.hrms[2]: number of uses: 2, isLinear: true, evaluated binding exp: 3
 systemDef.hrms[3]: number of uses: 2, isLinear: true, evaluated binding exp: 5
 systemDef.numHigherHrm: number of uses: 0, isLinear: true, evaluated binding exp: 2
 systemDef.numPh: number of uses: 0, isLinear: true, evaluated binding exp: 3
 test_DY1.N: number of uses: 3, isLinear: true, evaluated binding exp: 4
 _block_solver_experimental_mode: number of uses: 0, isLinear: true, evaluated binding exp: 0
 _cs_experimental_mode: number of uses: 0, isLinear: true, evaluated binding exp: 0
 _cs_solver: number of uses: 0, isLinear: true, evaluated binding exp: 0
 _iteration_variable_scaling: number of uses: 0, isLinear: true, evaluated binding exp: 1
 _log_level: number of uses: 0, isLinear: true, evaluated binding exp: 3
 _nle_active_bounds_mode: number of uses: 0, isLinear: true, evaluated binding exp: 0
 _nle_jacobian_calculation_mode: number of uses: 0, isLinear: true, evaluated binding exp: 0
 _nle_jacobian_update_mode: number of uses: 0, isLinear: true, evaluated binding exp: 2
 _nle_solver_exit_criterion: number of uses: 0, isLinear: true, evaluated binding exp: 3
 _nle_solver_max_iter: number of uses: 0, isLinear: true, evaluated binding exp: 100
 _nle_solver_max_iter_no_jacobian: number of uses: 0, isLinear: true, evaluated binding exp: 10
 _residual_equation_scaling: number of uses: 0, isLinear: true, evaluated binding exp: 1
 systemDef.numHrm: number of uses: 0, isLinear: true, evaluated binding exp: 3
 _block_jacobian_check: number of uses: 0, isLinear: true, evaluated binding exp: false
 _block_solver_profiling: number of uses: 0, isLinear: true, evaluated binding exp: false
 _enforce_bounds: number of uses: 0, isLinear: true, evaluated binding exp: true
 _nle_brent_ignore_error: number of uses: 0, isLinear: true, evaluated binding exp: false
 _nle_solver_check_jac_cond: number of uses: 0, isLinear: true, evaluated binding exp: false
 _nle_solver_use_last_integrator_step: number of uses: 0, isLinear: true, evaluated binding exp: true
 _nle_solver_use_nominals_as_fallback: number of uses: 0, isLinear: true, evaluated binding exp: true
 _rescale_after_singular_jac: number of uses: 0, isLinear: true, evaluated binding exp: true
 _rescale_each_step: number of uses: 0, isLinear: true, evaluated binding exp: false
 _runtime_log_to_file: number of uses: 0, isLinear: true, evaluated binding exp: false
 _use_Brent_in_1d: number of uses: 0, isLinear: true, evaluated binding exp: true
 _use_jacobian_equilibration: number of uses: 0, isLinear: true, evaluated binding exp: false
 _use_newton_for_brent: number of uses: 0, isLinear: true, evaluated binding exp: true

Dependent parameters: 
 test_DY1.idealTransformer1.N: number of uses: 10, isLinear: true
 test_DY1.idealTransformer2.N: number of uses: 10, isLinear: true
 test_DY1.idealTransformer3.N: number of uses: 10, isLinear: true
 PhA.v[1].re: number of uses: 3, isLinear: true
 PhA.v[2].re: number of uses: 3, isLinear: true
 PhA.v[3].re: number of uses: 3, isLinear: true
 PhA.v[1].im: number of uses: 3, isLinear: true
 PhA.v[2].im: number of uses: 3, isLinear: true
 PhA.v[3].im: number of uses: 3, isLinear: true
 PhB.v[1].re: number of uses: 3, isLinear: true
 PhB.v[2].re: number of uses: 3, isLinear: true
 PhB.v[3].re: number of uses: 3, isLinear: true
 PhB.v[1].im: number of uses: 3, isLinear: true
 PhB.v[2].im: number of uses: 3, isLinear: true
 PhB.v[3].im: number of uses: 3, isLinear: true
 PhC.v[1].re: number of uses: 3, isLinear: true
 PhC.v[2].re: number of uses: 3, isLinear: true
 PhC.v[3].re: number of uses: 3, isLinear: true
 PhC.v[1].im: number of uses: 3, isLinear: true
 PhC.v[2].im: number of uses: 3, isLinear: true
 PhC.v[3].im: number of uses: 3, isLinear: true
 temp_74: number of uses: 3, isLinear: true
 temp_89: number of uses: 3, isLinear: true
 temp_104: number of uses: 3, isLinear: true
 temp_224: number of uses: 3, isLinear: true
 temp_239: number of uses: 3, isLinear: true
 temp_254: number of uses: 3, isLinear: true
 temp_374: number of uses: 3, isLinear: true
 temp_389: number of uses: 3, isLinear: true
 temp_404: number of uses: 3, isLinear: true
 test_DY1.idealTransformer2.vPrim[1].re: number of uses: 2, isLinear: true
 test_DY1.idealTransformer2.vPrim[2].re: number of uses: 2, isLinear: true
 test_DY1.idealTransformer2.vPrim[3].re: number of uses: 2, isLinear: true
 test_DY1.idealTransformer2.vPrim[1].im: number of uses: 2, isLinear: true
 test_DY1.idealTransformer2.vPrim[2].im: number of uses: 2, isLinear: true
 test_DY1.idealTransformer2.vPrim[3].im: number of uses: 2, isLinear: true
 test_DY1.idealTransformer1.vPrim[1].re: number of uses: 2, isLinear: true
 test_DY1.idealTransformer3.vPrim[1].re: number of uses: 2, isLinear: true
 test_DY1.idealTransformer1.vPrim[2].re: number of uses: 2, isLinear: true
 test_DY1.idealTransformer3.vPrim[2].re: number of uses: 2, isLinear: true
 test_DY1.idealTransformer1.vPrim[3].re: number of uses: 2, isLinear: true
 test_DY1.idealTransformer3.vPrim[3].re: number of uses: 2, isLinear: true
 test_DY1.idealTransformer1.vPrim[1].im: number of uses: 2, isLinear: true
 test_DY1.idealTransformer3.vPrim[1].im: number of uses: 2, isLinear: true
 test_DY1.idealTransformer1.vPrim[2].im: number of uses: 2, isLinear: true
 test_DY1.idealTransformer3.vPrim[2].im: number of uses: 2, isLinear: true
 test_DY1.idealTransformer1.vPrim[3].im: number of uses: 2, isLinear: true
 test_DY1.idealTransformer3.vPrim[3].im: number of uses: 2, isLinear: true
 r1.v[1].re: number of uses: 4, isLinear: true
 r1.v[2].re: number of uses: 2, isLinear: true
 r1.v[3].re: number of uses: 2, isLinear: true
 r1.v[1].im: number of uses: 4, isLinear: true
 r1.v[2].im: number of uses: 2, isLinear: true
 r1.v[3].im: number of uses: 2, isLinear: true
 z.v[1].re: number of uses: 4, isLinear: true
 r2.v[1].re: number of uses: 4, isLinear: true
 z.v[2].re: number of uses: 2, isLinear: true
 r2.v[2].re: number of uses: 2, isLinear: true
 z.v[3].re: number of uses: 2, isLinear: true
 r2.v[3].re: number of uses: 2, isLinear: true
 z.v[1].im: number of uses: 4, isLinear: true
 r2.v[1].im: number of uses: 4, isLinear: true
 z.v[2].im: number of uses: 2, isLinear: true
 r2.v[2].im: number of uses: 2, isLinear: true
 z.v[3].im: number of uses: 2, isLinear: true
 r2.v[3].im: number of uses: 2, isLinear: true
 r1.i[1].re: number of uses: 5, isLinear: true
 r1.i[2].re: number of uses: 3, isLinear: true
 r1.i[3].re: number of uses: 3, isLinear: true
 r1.vFundAbs: number of uses: 1, isLinear: true
 r1.vFundArg: number of uses: 1, isLinear: true
 r1.i[1].im: number of uses: 5, isLinear: true
 r1.i[2].im: number of uses: 3, isLinear: true
 r1.i[3].im: number of uses: 3, isLinear: true
 r2.i[1].re: number of uses: 5, isLinear: true
 r2.i[2].re: number of uses: 3, isLinear: true
 r2.i[3].re: number of uses: 3, isLinear: true
 z.vFundAbs: number of uses: 1, isLinear: true
 z.vFundArg: number of uses: 1, isLinear: true
 r2.vFundAbs: number of uses: 1, isLinear: true
 r2.vFundArg: number of uses: 1, isLinear: true
 r2.i[1].im: number of uses: 5, isLinear: true
 r2.i[2].im: number of uses: 3, isLinear: true
 r2.i[3].im: number of uses: 3, isLinear: true
 test_DY1.idealTransformer2.iPrim[1].re: number of uses: 3, isLinear: true
 test_DY1.idealTransformer2.iPrim[2].re: number of uses: 3, isLinear: true
 test_DY1.idealTransformer2.iPrim[3].re: number of uses: 3, isLinear: true
 r1.iFundAbs: number of uses: 1, isLinear: true
 r1.iFundArg: number of uses: 1, isLinear: true
 test_DY1.idealTransformer2.iPrim[1].im: number of uses: 3, isLinear: true
 test_DY1.idealTransformer2.iPrim[2].im: number of uses: 3, isLinear: true
 test_DY1.idealTransformer2.iPrim[3].im: number of uses: 3, isLinear: true
 test_DY1.idealTransformer3.iPrim[1].re: number of uses: 3, isLinear: true
 test_DY1.idealTransformer3.iPrim[2].re: number of uses: 3, isLinear: true
 test_DY1.idealTransformer3.iPrim[3].re: number of uses: 3, isLinear: true
 r2.iFundAbs: number of uses: 1, isLinear: true
 r2.iFundArg: number of uses: 1, isLinear: true
 test_DY1.idealTransformer3.iPrim[1].im: number of uses: 3, isLinear: true
 test_DY1.idealTransformer3.iPrim[2].im: number of uses: 3, isLinear: true
 test_DY1.idealTransformer3.iPrim[3].im: number of uses: 3, isLinear: true
 PhB.i[1].re: number of uses: 2, isLinear: true
 PhB.i[2].re: number of uses: 2, isLinear: true
 PhB.i[3].re: number of uses: 2, isLinear: true
 PhB.i[1].im: number of uses: 2, isLinear: true
 PhB.i[2].im: number of uses: 2, isLinear: true
 PhB.i[3].im: number of uses: 2, isLinear: true

Differentiated variables: 
 PhA.theta: number of uses: 17, isLinear: false
 PhB.theta: number of uses: 3, isLinear: false
 PhC.theta: number of uses: 3, isLinear: false

Derivative variables: 
 der(PhA.theta): number of uses: 5, isLinear: true
 der(PhB.theta): number of uses: 2, isLinear: true
 der(PhC.theta): number of uses: 2, isLinear: true

Discrete variables: 
 systemDef.modeSelect: number of uses: 2, isLinear: true, alias: no
 systemDef.event1: number of uses: 1, isLinear: true, alias: no
 systemDef.event2: number of uses: 1, isLinear: true, alias: no
 temp_62: number of uses: 2, isLinear: true, alias: no
 temp_63: number of uses: 2, isLinear: true, alias: no
 temp_64: number of uses: 2, isLinear: true, alias: no

Algebraic real variables: 
 test_DY1.idealTransformer1.iPrim[1].re: number of uses: 3, isLinear: true, alias: no
 test_DY1.idealTransformer1.iPrim[1].im: number of uses: 3, isLinear: true, alias: no
 test_DY1.idealTransformer1.iPrim[2].re: number of uses: 3, isLinear: true, alias: no
 test_DY1.idealTransformer1.iPrim[2].im: number of uses: 3, isLinear: true, alias: no
 test_DY1.idealTransformer1.iPrim[3].re: number of uses: 3, isLinear: true, alias: no
 test_DY1.idealTransformer1.iPrim[3].im: number of uses: 3, isLinear: true, alias: no
 test_DY1.hPin_N.iIm[1]: number of uses: 1, isLinear: true, alias: no
 test_DY1.hPin_N.iIm[2]: number of uses: 1, isLinear: true, alias: no
 test_DY1.hPin_N.iIm[3]: number of uses: 1, isLinear: true, alias: no
 test_DY1.hPin_N.iRe[1]: number of uses: 1, isLinear: true, alias: no
 test_DY1.hPin_N.iRe[2]: number of uses: 1, isLinear: true, alias: no
 test_DY1.hPin_N.iRe[3]: number of uses: 1, isLinear: true, alias: no
 PhA.i[1].re: number of uses: 2, isLinear: true, alias: no
 PhA.i[1].im: number of uses: 2, isLinear: true, alias: no
 PhA.i[2].re: number of uses: 2, isLinear: true, alias: no
 PhA.i[2].im: number of uses: 2, isLinear: true, alias: no
 PhA.i[3].re: number of uses: 2, isLinear: true, alias: no
 PhA.i[3].im: number of uses: 2, isLinear: true, alias: no
 PhA.omega: number of uses: 1, isLinear: true, alias: no
 PhB.omega: number of uses: 1, isLinear: true, alias: no
 PhC.i[1].re: number of uses: 2, isLinear: true, alias: no
 PhC.i[1].im: number of uses: 2, isLinear: true, alias: no
 PhC.i[2].re: number of uses: 2, isLinear: true, alias: no
 PhC.i[2].im: number of uses: 2, isLinear: true, alias: no
 PhC.i[3].re: number of uses: 2, isLinear: true, alias: no
 PhC.i[3].im: number of uses: 2, isLinear: true, alias: no
 PhC.omega: number of uses: 1, isLinear: true, alias: no
 ground.pin.iIm[1]: number of uses: 1, isLinear: true, alias: no
 ground.pin.iIm[2]: number of uses: 1, isLinear: true, alias: no
 ground.pin.iIm[3]: number of uses: 1, isLinear: true, alias: no
 ground.pin.iRe[1]: number of uses: 1, isLinear: true, alias: no
 ground.pin.iRe[2]: number of uses: 1, isLinear: true, alias: no
 ground.pin.iRe[3]: number of uses: 1, isLinear: true, alias: no
 ground1.pin.iIm[1]: number of uses: 2, isLinear: true, alias: no
 ground1.pin.iIm[2]: number of uses: 2, isLinear: true, alias: no
 ground1.pin.iIm[3]: number of uses: 2, isLinear: true, alias: no
 ground1.pin.iRe[1]: number of uses: 2, isLinear: true, alias: no
 ground1.pin.iRe[2]: number of uses: 2, isLinear: true, alias: no
 ground1.pin.iRe[3]: number of uses: 2, isLinear: true, alias: no
 r1.omega: number of uses: 1, isLinear: true, alias: no
 r2.omega: number of uses: 1, isLinear: true, alias: no
 z.iFundAbs: number of uses: 1, isLinear: true, alias: no
 z.iFundArg: number of uses: 1, isLinear: true, alias: no
 z.i[1].re: number of uses: 6, isLinear: false, alias: no
 z.i[1].im: number of uses: 6, isLinear: false, alias: no
 z.i[2].re: number of uses: 4, isLinear: true, alias: no
 z.i[2].im: number of uses: 4, isLinear: true, alias: no
 z.i[3].re: number of uses: 4, isLinear: true, alias: no
 z.i[3].im: number of uses: 4, isLinear: true, alias: no
 z.omega: number of uses: 1, isLinear: true, alias: no

Input variables: 

Alias sets:
{test_DY1.idealTransformer1.iPrim[1].re, test_DY1.idealTransformer1.pinP_Prim.iRe[1], -test_DY1.idealTransformer1.pinN_Prim.iRe[1]}
{test_DY1.idealTransformer1.iPrim[2].re, test_DY1.idealTransformer1.pinP_Prim.iRe[2], -test_DY1.idealTransformer1.pinN_Prim.iRe[2]}
{test_DY1.idealTransformer1.iPrim[3].re, test_DY1.idealTransformer1.pinP_Prim.iRe[3], -test_DY1.idealTransformer1.pinN_Prim.iRe[3]}
{test_DY1.idealTransformer1.iPrim[1].im, test_DY1.idealTransformer1.pinP_Prim.iIm[1], -test_DY1.idealTransformer1.pinN_Prim.iIm[1]}
{test_DY1.idealTransformer1.iPrim[2].im, test_DY1.idealTransformer1.pinP_Prim.iIm[2], -test_DY1.idealTransformer1.pinN_Prim.iIm[2]}
{test_DY1.idealTransformer1.iPrim[3].im, test_DY1.idealTransformer1.pinP_Prim.iIm[3], -test_DY1.idealTransformer1.pinN_Prim.iIm[3]}
{test_DY1.idealTransformer2.iPrim[1].re, test_DY1.idealTransformer2.pinP_Prim.iRe[1], -test_DY1.idealTransformer2.pinN_Prim.iRe[1]}
{test_DY1.idealTransformer2.iPrim[2].re, test_DY1.idealTransformer2.pinP_Prim.iRe[2], -test_DY1.idealTransformer2.pinN_Prim.iRe[2]}
{test_DY1.idealTransformer2.iPrim[3].re, test_DY1.idealTransformer2.pinP_Prim.iRe[3], -test_DY1.idealTransformer2.pinN_Prim.iRe[3]}
{test_DY1.idealTransformer2.iPrim[1].im, test_DY1.idealTransformer2.pinP_Prim.iIm[1], -test_DY1.idealTransformer2.pinN_Prim.iIm[1]}
{test_DY1.idealTransformer2.iPrim[2].im, test_DY1.idealTransformer2.pinP_Prim.iIm[2], -test_DY1.idealTransformer2.pinN_Prim.iIm[2]}
{test_DY1.idealTransformer2.iPrim[3].im, test_DY1.idealTransformer2.pinP_Prim.iIm[3], -test_DY1.idealTransformer2.pinN_Prim.iIm[3]}
{test_DY1.idealTransformer3.iPrim[1].re, test_DY1.idealTransformer3.pinP_Prim.iRe[1], -test_DY1.idealTransformer3.pinN_Prim.iRe[1]}
{test_DY1.idealTransformer3.iPrim[2].re, test_DY1.idealTransformer3.pinP_Prim.iRe[2], -test_DY1.idealTransformer3.pinN_Prim.iRe[2]}
{test_DY1.idealTransformer3.iPrim[3].re, test_DY1.idealTransformer3.pinP_Prim.iRe[3], -test_DY1.idealTransformer3.pinN_Prim.iRe[3]}
{test_DY1.idealTransformer3.iPrim[1].im, test_DY1.idealTransformer3.pinP_Prim.iIm[1], -test_DY1.idealTransformer3.pinN_Prim.iIm[1]}
{test_DY1.idealTransformer3.iPrim[2].im, test_DY1.idealTransformer3.pinP_Prim.iIm[2], -test_DY1.idealTransformer3.pinN_Prim.iIm[2]}
{test_DY1.idealTransformer3.iPrim[3].im, test_DY1.idealTransformer3.pinP_Prim.iIm[3], -test_DY1.idealTransformer3.pinN_Prim.iIm[3]}
{PhA.i[1].re(start=0), PhA.pin_p.iRe[1], -PhA.pin_n.iRe[1], -test_DY1.pinPrim_A.iRe[1]}
{PhA.i[2].re(start=0), PhA.pin_p.iRe[2], -PhA.pin_n.iRe[2], -test_DY1.pinPrim_A.iRe[2]}
{PhA.i[3].re(start=0), PhA.pin_p.iRe[3], -PhA.pin_n.iRe[3], -test_DY1.pinPrim_A.iRe[3]}
{PhA.i[1].im(start=0), PhA.pin_p.iIm[1], -PhA.pin_n.iIm[1], -test_DY1.pinPrim_A.iIm[1]}
{PhA.i[2].im(start=0), PhA.pin_p.iIm[2], -PhA.pin_n.iIm[2], -test_DY1.pinPrim_A.iIm[2]}
{PhA.i[3].im(start=0), PhA.pin_p.iIm[3], -PhA.pin_n.iIm[3], -test_DY1.pinPrim_A.iIm[3]}
{PhB.theta(start=0), PhB.pin_p.reference.theta, PhB.pin_n.reference.theta}
{PhB.i[1].re(start=0), PhB.pin_p.iRe[1], -PhB.pin_n.iRe[1], -test_DY1.pinPrim_B.iRe[1]}
{PhB.i[2].re(start=0), PhB.pin_p.iRe[2], -PhB.pin_n.iRe[2], -test_DY1.pinPrim_B.iRe[2]}
{PhB.i[3].re(start=0), PhB.pin_p.iRe[3], -PhB.pin_n.iRe[3], -test_DY1.pinPrim_B.iRe[3]}
{PhB.i[1].im(start=0), PhB.pin_p.iIm[1], -PhB.pin_n.iIm[1], -test_DY1.pinPrim_B.iIm[1]}
{PhB.i[2].im(start=0), PhB.pin_p.iIm[2], -PhB.pin_n.iIm[2], -test_DY1.pinPrim_B.iIm[2]}
{PhB.i[3].im(start=0), PhB.pin_p.iIm[3], -PhB.pin_n.iIm[3], -test_DY1.pinPrim_B.iIm[3]}
{PhC.theta(start=0), PhC.pin_p.reference.theta, PhC.pin_n.reference.theta}
{PhC.i[1].re(start=0), PhC.pin_p.iRe[1], -PhC.pin_n.iRe[1], -test_DY1.pinPrim_C.iRe[1]}
{PhC.i[2].re(start=0), PhC.pin_p.iRe[2], -PhC.pin_n.iRe[2], -test_DY1.pinPrim_C.iRe[2]}
{PhC.i[3].re(start=0), PhC.pin_p.iRe[3], -PhC.pin_n.iRe[3], -test_DY1.pinPrim_C.iRe[3]}
{PhC.i[1].im(start=0), PhC.pin_p.iIm[1], -PhC.pin_n.iIm[1], -test_DY1.pinPrim_C.iIm[1]}
{PhC.i[2].im(start=0), PhC.pin_p.iIm[2], -PhC.pin_n.iIm[2], -test_DY1.pinPrim_C.iIm[2]}
{PhC.i[3].im(start=0), PhC.pin_p.iIm[3], -PhC.pin_n.iIm[3], -test_DY1.pinPrim_C.iIm[3]}
{r1.i[1].re(start=0), r1.pin_p.iRe[1], -r1.pin_n.iRe[1], -test_DY1.hPin_P2.iRe[1], -test_DY1.idealTransformer2.iSec[1].re, -test_DY1.idealTransformer2.pinP_Sec.iRe[1], test_DY1.idealTransformer2.pinN_Sec.iRe[1]}
{r1.i[2].re(start=0), r1.pin_p.iRe[2], -r1.pin_n.iRe[2], -test_DY1.hPin_P2.iRe[2], -test_DY1.idealTransformer2.iSec[2].re, -test_DY1.idealTransformer2.pinP_Sec.iRe[2], test_DY1.idealTransformer2.pinN_Sec.iRe[2]}
{r1.i[3].re(start=0), r1.pin_p.iRe[3], -r1.pin_n.iRe[3], -test_DY1.hPin_P2.iRe[3], -test_DY1.idealTransformer2.iSec[3].re, -test_DY1.idealTransformer2.pinP_Sec.iRe[3], test_DY1.idealTransformer2.pinN_Sec.iRe[3]}
{r1.i[1].im(start=0), r1.pin_p.iIm[1], -r1.pin_n.iIm[1], -test_DY1.hPin_P2.iIm[1], -test_DY1.idealTransformer2.iSec[1].im, -test_DY1.idealTransformer2.pinP_Sec.iIm[1], test_DY1.idealTransformer2.pinN_Sec.iIm[1]}
{r1.i[2].im(start=0), r1.pin_p.iIm[2], -r1.pin_n.iIm[2], -test_DY1.hPin_P2.iIm[2], -test_DY1.idealTransformer2.iSec[2].im, -test_DY1.idealTransformer2.pinP_Sec.iIm[2], test_DY1.idealTransformer2.pinN_Sec.iIm[2]}
{r1.i[3].im(start=0), r1.pin_p.iIm[3], -r1.pin_n.iIm[3], -test_DY1.hPin_P2.iIm[3], -test_DY1.idealTransformer2.iSec[3].im, -test_DY1.idealTransformer2.pinP_Sec.iIm[3], test_DY1.idealTransformer2.pinN_Sec.iIm[3]}
{PhA.theta(start=0), r2.pin_p.reference.theta, r2.pin_n.reference.theta, r1.pin_p.reference.theta, r1.pin_n.reference.theta, test_DY1.idealTransformer1.pinP_Prim.reference.theta, test_DY1.idealTransformer1.pinN_Prim.reference.theta, test_DY1.idealTransformer1.pinP_Sec.reference.theta, test_DY1.idealTransformer1.pinN_Sec.reference.theta, test_DY1.idealTransformer2.pinP_Prim.reference.theta, test_DY1.idealTransformer2.pinN_Prim.reference.theta, test_DY1.idealTransformer2.pinP_Sec.reference.theta, test_DY1.idealTransformer2.pinN_Sec.reference.theta, PhA.pin_p.reference.theta, PhA.pin_n.reference.theta, test_DY1.pinPrim_A.reference.theta, ground.pin.reference.theta, test_DY1.idealTransformer3.pinP_Prim.reference.theta, test_DY1.idealTransformer3.pinN_Prim.reference.theta, test_DY1.idealTransformer3.pinP_Sec.reference.theta, test_DY1.idealTransformer3.pinN_Sec.reference.theta, test_DY1.pinPrim_C.reference.theta, test_DY1.hPin_N.reference.theta, test_DY1.hPin_P1.reference.theta, test_DY1.pinPrim_B.reference.theta, test_DY1.hPin_P2.reference.theta, test_DY1.hPin_P3.reference.theta, ground1.pin.reference.theta, z.pin_p.reference.theta, z.pin_n.reference.theta}
{r2.i[1].re(start=0), r2.pin_p.iRe[1], -r2.pin_n.iRe[1], -test_DY1.hPin_P3.iRe[1], -test_DY1.idealTransformer3.iSec[1].re, -test_DY1.idealTransformer3.pinP_Sec.iRe[1], test_DY1.idealTransformer3.pinN_Sec.iRe[1]}
{r2.i[2].re(start=0), r2.pin_p.iRe[2], -r2.pin_n.iRe[2], -test_DY1.hPin_P3.iRe[2], -test_DY1.idealTransformer3.iSec[2].re, -test_DY1.idealTransformer3.pinP_Sec.iRe[2], test_DY1.idealTransformer3.pinN_Sec.iRe[2]}
{r2.i[3].re(start=0), r2.pin_p.iRe[3], -r2.pin_n.iRe[3], -test_DY1.hPin_P3.iRe[3], -test_DY1.idealTransformer3.iSec[3].re, -test_DY1.idealTransformer3.pinP_Sec.iRe[3], test_DY1.idealTransformer3.pinN_Sec.iRe[3]}
{r2.i[1].im(start=0), r2.pin_p.iIm[1], -r2.pin_n.iIm[1], -test_DY1.hPin_P3.iIm[1], -test_DY1.idealTransformer3.iSec[1].im, -test_DY1.idealTransformer3.pinP_Sec.iIm[1], test_DY1.idealTransformer3.pinN_Sec.iIm[1]}
{r2.i[2].im(start=0), r2.pin_p.iIm[2], -r2.pin_n.iIm[2], -test_DY1.hPin_P3.iIm[2], -test_DY1.idealTransformer3.iSec[2].im, -test_DY1.idealTransformer3.pinP_Sec.iIm[2], test_DY1.idealTransformer3.pinN_Sec.iIm[2]}
{r2.i[3].im(start=0), r2.pin_p.iIm[3], -r2.pin_n.iIm[3], -test_DY1.hPin_P3.iIm[3], -test_DY1.idealTransformer3.iSec[3].im, -test_DY1.idealTransformer3.pinP_Sec.iIm[3], test_DY1.idealTransformer3.pinN_Sec.iIm[3]}
{z.i[1].re(start=0), z.pin_p.iRe[1], -z.pin_n.iRe[1], -test_DY1.hPin_P1.iRe[1], -test_DY1.idealTransformer1.iSec[1].re, -test_DY1.idealTransformer1.pinP_Sec.iRe[1], test_DY1.idealTransformer1.pinN_Sec.iRe[1]}
{z.i[2].re(start=0), z.pin_p.iRe[2], -z.pin_n.iRe[2], -test_DY1.hPin_P1.iRe[2], -test_DY1.idealTransformer1.iSec[2].re, -test_DY1.idealTransformer1.pinP_Sec.iRe[2], test_DY1.idealTransformer1.pinN_Sec.iRe[2]}
{z.i[3].re(start=0), z.pin_p.iRe[3], -z.pin_n.iRe[3], -test_DY1.hPin_P1.iRe[3], -test_DY1.idealTransformer1.iSec[3].re, -test_DY1.idealTransformer1.pinP_Sec.iRe[3], test_DY1.idealTransformer1.pinN_Sec.iRe[3]}
{z.i[1].im(start=0), z.pin_p.iIm[1], -z.pin_n.iIm[1], -test_DY1.hPin_P1.iIm[1], -test_DY1.idealTransformer1.iSec[1].im, -test_DY1.idealTransformer1.pinP_Sec.iIm[1], test_DY1.idealTransformer1.pinN_Sec.iIm[1]}
{z.i[2].im(start=0), z.pin_p.iIm[2], -z.pin_n.iIm[2], -test_DY1.hPin_P1.iIm[2], -test_DY1.idealTransformer1.iSec[2].im, -test_DY1.idealTransformer1.pinP_Sec.iIm[2], test_DY1.idealTransformer1.pinN_Sec.iIm[2]}
{z.i[3].im(start=0), z.pin_p.iIm[3], -z.pin_n.iIm[3], -test_DY1.hPin_P1.iIm[3], -test_DY1.idealTransformer1.iSec[3].im, -test_DY1.idealTransformer1.pinP_Sec.iIm[3], test_DY1.idealTransformer1.pinN_Sec.iIm[3]}
{PhA.pin_n.v[1].im, PhB.pin_n.v[1].im, PhC.pin_n.v[1].im, ground.pin.v[1].im, PhA.pin_n.v[2].im, PhB.pin_n.v[2].im, PhC.pin_n.v[2].im, ground.pin.v[2].im, PhA.pin_n.v[3].im, PhB.pin_n.v[3].im, PhC.pin_n.v[3].im, ground.pin.v[3].im, ground1.pin.v[1].im, r1.pin_n.v[1].im, r2.pin_n.v[1].im, test_DY1.hPin_N.v[1].im, z.pin_n.v[1].im, test_DY1.idealTransformer1.pinN_Sec.v[1].im, test_DY1.idealTransformer2.pinN_Sec.v[1].im, test_DY1.idealTransformer3.pinN_Sec.v[1].im, ground1.pin.v[2].im, r1.pin_n.v[2].im, r2.pin_n.v[2].im, test_DY1.hPin_N.v[2].im, z.pin_n.v[2].im, test_DY1.idealTransformer1.pinN_Sec.v[2].im, test_DY1.idealTransformer2.pinN_Sec.v[2].im, test_DY1.idealTransformer3.pinN_Sec.v[2].im, ground1.pin.v[3].im, r1.pin_n.v[3].im, r2.pin_n.v[3].im, test_DY1.hPin_N.v[3].im, z.pin_n.v[3].im, test_DY1.idealTransformer1.pinN_Sec.v[3].im, test_DY1.idealTransformer2.pinN_Sec.v[3].im, test_DY1.idealTransformer3.pinN_Sec.v[3].im, temp_65.im, temp_80.im, temp_95.im, temp_110.im, temp_125.im, temp_140.im, temp_215.im, temp_230.im, temp_245.im, temp_260.im, temp_275.im, temp_290.im, temp_365.im, temp_380.im, temp_395.im, temp_410.im, temp_425.im, temp_440.im}
{PhA.pin_n.v[1].re, PhB.pin_n.v[1].re, PhC.pin_n.v[1].re, ground.pin.v[1].re, PhA.pin_n.v[2].re, PhB.pin_n.v[2].re, PhC.pin_n.v[2].re, ground.pin.v[2].re, PhA.pin_n.v[3].re, PhB.pin_n.v[3].re, PhC.pin_n.v[3].re, ground.pin.v[3].re, ground1.pin.v[1].re, r1.pin_n.v[1].re, r2.pin_n.v[1].re, test_DY1.hPin_N.v[1].re, z.pin_n.v[1].re, test_DY1.idealTransformer1.pinN_Sec.v[1].re, test_DY1.idealTransformer2.pinN_Sec.v[1].re, test_DY1.idealTransformer3.pinN_Sec.v[1].re, ground1.pin.v[2].re, r1.pin_n.v[2].re, r2.pin_n.v[2].re, test_DY1.hPin_N.v[2].re, z.pin_n.v[2].re, test_DY1.idealTransformer1.pinN_Sec.v[2].re, test_DY1.idealTransformer2.pinN_Sec.v[2].re, test_DY1.idealTransformer3.pinN_Sec.v[2].re, ground1.pin.v[3].re, r1.pin_n.v[3].re, r2.pin_n.v[3].re, test_DY1.hPin_N.v[3].re, z.pin_n.v[3].re, test_DY1.idealTransformer1.pinN_Sec.v[3].re, test_DY1.idealTransformer2.pinN_Sec.v[3].re, test_DY1.idealTransformer3.pinN_Sec.v[3].re}
{r1.v[1].im(start=0), r1.pin_p.v[1].im, test_DY1.hPin_P2.v[1].im, test_DY1.idealTransformer2.pinP_Sec.v[1].im, test_DY1.idealTransformer2.vSec[1].im}
{r1.v[1].re(start=0), r1.pin_p.v[1].re, test_DY1.hPin_P2.v[1].re, test_DY1.idealTransformer2.pinP_Sec.v[1].re, test_DY1.idealTransformer2.vSec[1].re}
{r1.v[2].im(start=0), r1.pin_p.v[2].im, test_DY1.hPin_P2.v[2].im, test_DY1.idealTransformer2.pinP_Sec.v[2].im, test_DY1.idealTransformer2.vSec[2].im}
{r1.v[2].re(start=0), r1.pin_p.v[2].re, test_DY1.hPin_P2.v[2].re, test_DY1.idealTransformer2.pinP_Sec.v[2].re, test_DY1.idealTransformer2.vSec[2].re}
{r1.v[3].im(start=0), r1.pin_p.v[3].im, test_DY1.hPin_P2.v[3].im, test_DY1.idealTransformer2.pinP_Sec.v[3].im, test_DY1.idealTransformer2.vSec[3].im}
{r1.v[3].re(start=0), r1.pin_p.v[3].re, test_DY1.hPin_P2.v[3].re, test_DY1.idealTransformer2.pinP_Sec.v[3].re, test_DY1.idealTransformer2.vSec[3].re}
{r2.v[1].im(start=0), r2.pin_p.v[1].im, test_DY1.hPin_P3.v[1].im, test_DY1.idealTransformer3.pinP_Sec.v[1].im, test_DY1.idealTransformer3.vSec[1].im}
{r2.v[1].re(start=0), r2.pin_p.v[1].re, test_DY1.hPin_P3.v[1].re, test_DY1.idealTransformer3.pinP_Sec.v[1].re, test_DY1.idealTransformer3.vSec[1].re}
{r2.v[2].im(start=0), r2.pin_p.v[2].im, test_DY1.hPin_P3.v[2].im, test_DY1.idealTransformer3.pinP_Sec.v[2].im, test_DY1.idealTransformer3.vSec[2].im}
{r2.v[2].re(start=0), r2.pin_p.v[2].re, test_DY1.hPin_P3.v[2].re, test_DY1.idealTransformer3.pinP_Sec.v[2].re, test_DY1.idealTransformer3.vSec[2].re}
{r2.v[3].im(start=0), r2.pin_p.v[3].im, test_DY1.hPin_P3.v[3].im, test_DY1.idealTransformer3.pinP_Sec.v[3].im, test_DY1.idealTransformer3.vSec[3].im}
{r2.v[3].re(start=0), r2.pin_p.v[3].re, test_DY1.hPin_P3.v[3].re, test_DY1.idealTransformer3.pinP_Sec.v[3].re, test_DY1.idealTransformer3.vSec[3].re}
{z.v[1].im(start=0), test_DY1.hPin_P1.v[1].im, z.pin_p.v[1].im, test_DY1.idealTransformer1.pinP_Sec.v[1].im, test_DY1.idealTransformer1.vSec[1].im}
{z.v[1].re(start=0), test_DY1.hPin_P1.v[1].re, z.pin_p.v[1].re, test_DY1.idealTransformer1.pinP_Sec.v[1].re, test_DY1.idealTransformer1.vSec[1].re}
{z.v[2].im(start=0), test_DY1.hPin_P1.v[2].im, z.pin_p.v[2].im, test_DY1.idealTransformer1.pinP_Sec.v[2].im, test_DY1.idealTransformer1.vSec[2].im}
{z.v[2].re(start=0), test_DY1.hPin_P1.v[2].re, z.pin_p.v[2].re, test_DY1.idealTransformer1.pinP_Sec.v[2].re, test_DY1.idealTransformer1.vSec[2].re}
{z.v[3].im(start=0), test_DY1.hPin_P1.v[3].im, z.pin_p.v[3].im, test_DY1.idealTransformer1.pinP_Sec.v[3].im, test_DY1.idealTransformer1.vSec[3].im}
{z.v[3].re(start=0), test_DY1.hPin_P1.v[3].re, z.pin_p.v[3].re, test_DY1.idealTransformer1.pinP_Sec.v[3].re, test_DY1.idealTransformer1.vSec[3].re}
{PhA.v[1].im(start=0), test_DY1.idealTransformer1.pinP_Prim.v[1].im, test_DY1.idealTransformer2.pinN_Prim.v[1].im, PhA.pin_p.v[1].im, test_DY1.pinPrim_A.v[1].im}
{PhA.v[1].re(start=0), test_DY1.idealTransformer1.pinP_Prim.v[1].re, test_DY1.idealTransformer2.pinN_Prim.v[1].re, PhA.pin_p.v[1].re, test_DY1.pinPrim_A.v[1].re}
{PhA.v[2].im(start=0), test_DY1.idealTransformer1.pinP_Prim.v[2].im, test_DY1.idealTransformer2.pinN_Prim.v[2].im, PhA.pin_p.v[2].im, test_DY1.pinPrim_A.v[2].im}
{PhA.v[2].re(start=0), test_DY1.idealTransformer1.pinP_Prim.v[2].re, test_DY1.idealTransformer2.pinN_Prim.v[2].re, PhA.pin_p.v[2].re, test_DY1.pinPrim_A.v[2].re}
{PhA.v[3].im(start=0), test_DY1.idealTransformer1.pinP_Prim.v[3].im, test_DY1.idealTransformer2.pinN_Prim.v[3].im, PhA.pin_p.v[3].im, test_DY1.pinPrim_A.v[3].im}
{PhA.v[3].re(start=0), test_DY1.idealTransformer1.pinP_Prim.v[3].re, test_DY1.idealTransformer2.pinN_Prim.v[3].re, PhA.pin_p.v[3].re, test_DY1.pinPrim_A.v[3].re}
{PhC.v[1].im(start=0), test_DY1.idealTransformer1.pinN_Prim.v[1].im, test_DY1.idealTransformer3.pinP_Prim.v[1].im, PhC.pin_p.v[1].im, test_DY1.pinPrim_C.v[1].im}
{PhC.v[1].re(start=0), test_DY1.idealTransformer1.pinN_Prim.v[1].re, test_DY1.idealTransformer3.pinP_Prim.v[1].re, PhC.pin_p.v[1].re, test_DY1.pinPrim_C.v[1].re}
{PhC.v[2].im(start=0), test_DY1.idealTransformer1.pinN_Prim.v[2].im, test_DY1.idealTransformer3.pinP_Prim.v[2].im, PhC.pin_p.v[2].im, test_DY1.pinPrim_C.v[2].im}
{PhC.v[2].re(start=0), test_DY1.idealTransformer1.pinN_Prim.v[2].re, test_DY1.idealTransformer3.pinP_Prim.v[2].re, PhC.pin_p.v[2].re, test_DY1.pinPrim_C.v[2].re}
{PhC.v[3].im(start=0), test_DY1.idealTransformer1.pinN_Prim.v[3].im, test_DY1.idealTransformer3.pinP_Prim.v[3].im, PhC.pin_p.v[3].im, test_DY1.pinPrim_C.v[3].im}
{PhC.v[3].re(start=0), test_DY1.idealTransformer1.pinN_Prim.v[3].re, test_DY1.idealTransformer3.pinP_Prim.v[3].re, PhC.pin_p.v[3].re, test_DY1.pinPrim_C.v[3].re}
{PhB.v[1].im(start=0), test_DY1.idealTransformer2.pinP_Prim.v[1].im, test_DY1.idealTransformer3.pinN_Prim.v[1].im, PhB.pin_p.v[1].im, test_DY1.pinPrim_B.v[1].im}
{PhB.v[1].re(start=0), test_DY1.idealTransformer2.pinP_Prim.v[1].re, test_DY1.idealTransformer3.pinN_Prim.v[1].re, PhB.pin_p.v[1].re, test_DY1.pinPrim_B.v[1].re}
{PhB.v[2].im(start=0), test_DY1.idealTransformer2.pinP_Prim.v[2].im, test_DY1.idealTransformer3.pinN_Prim.v[2].im, PhB.pin_p.v[2].im, test_DY1.pinPrim_B.v[2].im}
{PhB.v[2].re(start=0), test_DY1.idealTransformer2.pinP_Prim.v[2].re, test_DY1.idealTransformer3.pinN_Prim.v[2].re, PhB.pin_p.v[2].re, test_DY1.pinPrim_B.v[2].re}
{PhB.v[3].im(start=0), test_DY1.idealTransformer2.pinP_Prim.v[3].im, test_DY1.idealTransformer3.pinN_Prim.v[3].im, PhB.pin_p.v[3].im, test_DY1.pinPrim_B.v[3].im}
{PhB.v[3].re(start=0), test_DY1.idealTransformer2.pinP_Prim.v[3].re, test_DY1.idealTransformer3.pinN_Prim.v[3].re, PhB.pin_p.v[3].re, test_DY1.pinPrim_B.v[3].re}
{systemDef.numHrm, test_DY1.idealTransformer1.pinP_Prim.h, test_DY1.idealTransformer1.pinN_Prim.h, test_DY1.idealTransformer1.pinP_Sec.h, test_DY1.idealTransformer1.pinN_Sec.h, test_DY1.idealTransformer2.pinP_Prim.h, test_DY1.idealTransformer2.pinN_Prim.h, test_DY1.idealTransformer2.pinP_Sec.h, test_DY1.idealTransformer2.pinN_Sec.h, test_DY1.idealTransformer3.pinP_Prim.h, test_DY1.idealTransformer3.pinN_Prim.h, test_DY1.idealTransformer3.pinP_Sec.h, test_DY1.idealTransformer3.pinN_Sec.h, test_DY1.pinPrim_A.h, test_DY1.pinPrim_B.h, test_DY1.pinPrim_C.h, test_DY1.hPin_P1.h, test_DY1.hPin_P2.h, test_DY1.hPin_P3.h, test_DY1.hPin_N.h, PhA.pin_p.h, PhA.pin_n.h, PhB.pin_p.h, PhB.pin_n.h, PhC.pin_p.h, PhC.pin_n.h, ground.pin.h, ground1.pin.h, r1.pin_p.h, r1.pin_n.h, r2.pin_p.h, r2.pin_n.h, z.pin_p.h, z.pin_n.h}
496 variables can be eliminated

Incidence:
 eq 0: temp_62
 eq 1: temp_63
 eq 2: temp_64
 eq 3: temp_62 systemDef.modeSelect temp_63 systemDef.event1 temp_64 systemDef.event2
 eq 4: z.i[1].re test_DY1.idealTransformer1.iPrim[1].re
 eq 5: z.i[1].im test_DY1.idealTransformer1.iPrim[1].im
 eq 6: z.i[2].re test_DY1.idealTransformer1.iPrim[2].re
 eq 7: z.i[2].im test_DY1.idealTransformer1.iPrim[2].im
 eq 8: z.i[3].re test_DY1.idealTransformer1.iPrim[3].re
 eq 9: z.i[3].im test_DY1.idealTransformer1.iPrim[3].im
 eq 10: der(PhA.theta)
 eq 11: der(PhA.theta) PhA.omega
 eq 12: der(PhB.theta)
 eq 13: der(PhB.theta) PhB.omega
 eq 14: der(PhC.theta)
 eq 15: der(PhC.theta) PhC.omega
 eq 16: der(PhA.theta) r1.omega
 eq 17: der(PhA.theta) r2.omega
 eq 18: z.i[1].re z.i[1].im
 eq 19: z.i[2].re z.i[2].im
 eq 20: z.i[3].re z.i[3].im
 eq 21: z.i[1].im z.i[1].re
 eq 22: z.i[2].im z.i[2].re
 eq 23: z.i[3].im z.i[3].re
 eq 24: der(PhA.theta) z.omega
 eq 25: ground1.pin.iIm[1] test_DY1.hPin_N.iIm[1] z.i[1].im
 eq 26: ground1.pin.iIm[2] test_DY1.hPin_N.iIm[2] z.i[2].im
 eq 27: ground1.pin.iIm[3] test_DY1.hPin_N.iIm[3] z.i[3].im
 eq 28: ground1.pin.iRe[1] test_DY1.hPin_N.iRe[1] z.i[1].re
 eq 29: ground1.pin.iRe[2] test_DY1.hPin_N.iRe[2] z.i[2].re
 eq 30: ground1.pin.iRe[3] test_DY1.hPin_N.iRe[3] z.i[3].re
 eq 31: PhA.i[1].im PhC.i[1].im ground.pin.iIm[1]
 eq 32: PhA.i[2].im PhC.i[2].im ground.pin.iIm[2]
 eq 33: PhA.i[3].im PhC.i[3].im ground.pin.iIm[3]
 eq 34: PhA.i[1].re PhC.i[1].re ground.pin.iRe[1]
 eq 35: PhA.i[2].re PhC.i[2].re ground.pin.iRe[2]
 eq 36: PhA.i[3].re PhC.i[3].re ground.pin.iRe[3]
 eq 37: test_DY1.idealTransformer1.iPrim[1].im PhA.i[1].im
 eq 38: test_DY1.idealTransformer1.iPrim[2].im PhA.i[2].im
 eq 39: test_DY1.idealTransformer1.iPrim[3].im PhA.i[3].im
 eq 40: test_DY1.idealTransformer1.iPrim[1].re PhA.i[1].re
 eq 41: test_DY1.idealTransformer1.iPrim[2].re PhA.i[2].re
 eq 42: test_DY1.idealTransformer1.iPrim[3].re PhA.i[3].re
 eq 43: test_DY1.idealTransformer1.iPrim[1].im PhC.i[1].im
 eq 44: test_DY1.idealTransformer1.iPrim[2].im PhC.i[2].im
 eq 45: test_DY1.idealTransformer1.iPrim[3].im PhC.i[3].im
 eq 46: test_DY1.idealTransformer1.iPrim[1].re PhC.i[1].re
 eq 47: test_DY1.idealTransformer1.iPrim[2].re PhC.i[2].re
 eq 48: test_DY1.idealTransformer1.iPrim[3].re PhC.i[3].re
 eq 49: ground1.pin.iIm[1]
 eq 50: ground1.pin.iIm[2]
 eq 51: ground1.pin.iIm[3]
 eq 52: ground1.pin.iRe[1]
 eq 53: ground1.pin.iRe[2]
 eq 54: ground1.pin.iRe[3]
 eq 55:
 eq 56:
 eq 57:
 eq 58:
 eq 59:
 eq 60:
 eq 61:
 eq 62:
 eq 63:
 eq 64:
 eq 65: z.iFundAbs z.i[1].re z.i[1].im
 eq 66: z.iFundArg z.i[1].im z.i[1].re

Variable dependencies:
Derivative variables: 
 der(PhA.theta)
    systemDef.fFund
 der(PhB.theta)
    systemDef.fFund
 der(PhC.theta)
    systemDef.fFund

Differentiated variables: 
 PhA.theta
 PhB.theta
 PhC.theta

Algebraic real variables: 
 test_DY1.idealTransformer1.iPrim[1].re
    test_DY1.N
    PhC.vArg[1]
    PhA.vArg[1]
    PhC.vMag[1]
    PhA.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 test_DY1.idealTransformer1.iPrim[1].im
    test_DY1.N
    PhC.vArg[1]
    PhA.vArg[1]
    PhC.vMag[1]
    PhA.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 test_DY1.idealTransformer1.iPrim[2].re
    test_DY1.N
    PhA.vArg[2]
    PhA.vMag[2]
    PhC.vMag[2]
    PhC.vArg[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
 test_DY1.idealTransformer1.iPrim[2].im
    test_DY1.N
    PhA.vArg[2]
    PhA.vMag[2]
    PhC.vMag[2]
    PhC.vArg[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
 test_DY1.idealTransformer1.iPrim[3].re
    test_DY1.N
    PhA.vArg[3]
    PhC.vMag[3]
    PhC.vArg[3]
    PhA.vMag[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 test_DY1.idealTransformer1.iPrim[3].im
    test_DY1.N
    PhA.vArg[3]
    PhC.vMag[3]
    PhC.vArg[3]
    PhA.vMag[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 test_DY1.hPin_N.iIm[1]
    PhB.vMag[1]
    PhB.vArg[1]
    r1.r
    PhA.vArg[1]
    test_DY1.N
    PhA.vMag[1]
    PhC.vArg[1]
    r2.r
    PhC.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 test_DY1.hPin_N.iIm[2]
    PhA.vArg[2]
    PhA.vMag[2]
    r1.r
    test_DY1.N
    PhB.vMag[2]
    PhB.vArg[2]
    r2.r
    PhC.vMag[2]
    PhC.vArg[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
 test_DY1.hPin_N.iIm[3]
    PhA.vArg[3]
    PhB.vMag[3]
    r1.r
    test_DY1.N
    PhB.vArg[3]
    PhA.vMag[3]
    r2.r
    PhC.vMag[3]
    PhC.vArg[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 test_DY1.hPin_N.iRe[1]
    PhB.vMag[1]
    PhB.vArg[1]
    r1.r
    PhA.vArg[1]
    test_DY1.N
    PhA.vMag[1]
    PhC.vArg[1]
    r2.r
    PhC.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 test_DY1.hPin_N.iRe[2]
    PhA.vArg[2]
    PhA.vMag[2]
    r1.r
    test_DY1.N
    PhB.vMag[2]
    PhB.vArg[2]
    r2.r
    PhC.vMag[2]
    PhC.vArg[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
 test_DY1.hPin_N.iRe[3]
    PhA.vArg[3]
    PhB.vMag[3]
    r1.r
    test_DY1.N
    PhB.vArg[3]
    PhA.vMag[3]
    r2.r
    PhC.vMag[3]
    PhC.vArg[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 PhA.i[1].re
    PhB.vMag[1]
    PhB.vArg[1]
    r1.r
    PhA.vArg[1]
    test_DY1.N
    PhA.vMag[1]
    PhC.vArg[1]
    PhC.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 PhA.i[1].im
    PhB.vMag[1]
    PhB.vArg[1]
    r1.r
    PhA.vArg[1]
    test_DY1.N
    PhA.vMag[1]
    PhC.vArg[1]
    PhC.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 PhA.i[2].re
    PhA.vArg[2]
    PhA.vMag[2]
    r1.r
    test_DY1.N
    PhB.vMag[2]
    PhB.vArg[2]
    PhC.vMag[2]
    PhC.vArg[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
 PhA.i[2].im
    PhA.vArg[2]
    PhA.vMag[2]
    r1.r
    test_DY1.N
    PhB.vMag[2]
    PhB.vArg[2]
    PhC.vMag[2]
    PhC.vArg[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
 PhA.i[3].re
    PhA.vArg[3]
    PhB.vMag[3]
    r1.r
    test_DY1.N
    PhB.vArg[3]
    PhA.vMag[3]
    PhC.vMag[3]
    PhC.vArg[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 PhA.i[3].im
    PhA.vArg[3]
    PhB.vMag[3]
    r1.r
    test_DY1.N
    PhB.vArg[3]
    PhA.vMag[3]
    PhC.vMag[3]
    PhC.vArg[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 PhA.omega
    systemDef.fFund
 PhB.omega
    systemDef.fFund
 PhC.i[1].re
    PhC.vArg[1]
    PhB.vMag[1]
    PhB.vArg[1]
    r2.r
    PhC.vMag[1]
    test_DY1.N
    PhA.vArg[1]
    PhA.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 PhC.i[1].im
    PhC.vArg[1]
    PhB.vMag[1]
    PhB.vArg[1]
    r2.r
    PhC.vMag[1]
    test_DY1.N
    PhA.vArg[1]
    PhA.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 PhC.i[2].re
    r2.r
    PhC.vMag[2]
    PhC.vArg[2]
    test_DY1.N
    PhB.vMag[2]
    PhB.vArg[2]
    PhA.vArg[2]
    PhA.vMag[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
 PhC.i[2].im
    r2.r
    PhC.vMag[2]
    PhC.vArg[2]
    test_DY1.N
    PhB.vMag[2]
    PhB.vArg[2]
    PhA.vArg[2]
    PhA.vMag[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
 PhC.i[3].re
    PhB.vMag[3]
    r2.r
    PhC.vMag[3]
    test_DY1.N
    PhB.vArg[3]
    PhC.vArg[3]
    PhA.vArg[3]
    PhA.vMag[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 PhC.i[3].im
    PhB.vMag[3]
    r2.r
    PhC.vMag[3]
    test_DY1.N
    PhB.vArg[3]
    PhC.vArg[3]
    PhA.vArg[3]
    PhA.vMag[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 PhC.omega
    systemDef.fFund
 ground.pin.iIm[1]
    PhC.vArg[1]
    PhB.vMag[1]
    PhB.vArg[1]
    r2.r
    r1.r
    PhA.vArg[1]
    PhC.vMag[1]
    test_DY1.N
    PhA.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 ground.pin.iIm[2]
    PhA.vArg[2]
    r2.r
    PhA.vMag[2]
    r1.r
    PhC.vMag[2]
    PhC.vArg[2]
    test_DY1.N
    PhB.vMag[2]
    PhB.vArg[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
 ground.pin.iIm[3]
    PhA.vArg[3]
    PhB.vMag[3]
    r2.r
    r1.r
    PhC.vMag[3]
    test_DY1.N
    PhB.vArg[3]
    PhC.vArg[3]
    PhA.vMag[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 ground.pin.iRe[1]
    PhC.vArg[1]
    PhB.vMag[1]
    PhB.vArg[1]
    r2.r
    r1.r
    PhA.vArg[1]
    PhC.vMag[1]
    test_DY1.N
    PhA.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 ground.pin.iRe[2]
    PhA.vArg[2]
    r2.r
    PhA.vMag[2]
    r1.r
    PhC.vMag[2]
    PhC.vArg[2]
    test_DY1.N
    PhB.vMag[2]
    PhB.vArg[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
 ground.pin.iRe[3]
    PhA.vArg[3]
    PhB.vMag[3]
    r2.r
    r1.r
    PhC.vMag[3]
    test_DY1.N
    PhB.vArg[3]
    PhC.vArg[3]
    PhA.vMag[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 ground1.pin.iIm[1]
 ground1.pin.iIm[2]
 ground1.pin.iIm[3]
 ground1.pin.iRe[1]
 ground1.pin.iRe[2]
 ground1.pin.iRe[3]
 r1.omega
    systemDef.fFund
 r2.omega
    systemDef.fFund
 z.iFundAbs
    PhC.vArg[1]
    PhA.vArg[1]
    PhC.vMag[1]
    test_DY1.N
    PhA.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 z.iFundArg
    PhC.vArg[1]
    PhA.vArg[1]
    PhC.vMag[1]
    test_DY1.N
    PhA.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 z.i[1].re
    PhC.vArg[1]
    PhA.vArg[1]
    PhC.vMag[1]
    test_DY1.N
    PhA.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 z.i[1].im
    PhC.vArg[1]
    PhA.vArg[1]
    PhC.vMag[1]
    test_DY1.N
    PhA.vMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
 z.i[2].re
    PhA.vArg[2]
    PhA.vMag[2]
    PhC.vMag[2]
    PhC.vArg[2]
    test_DY1.N
    z.z.re
    z.z.im
    systemDef.hrms[2]
 z.i[2].im
    PhA.vArg[2]
    PhA.vMag[2]
    PhC.vMag[2]
    PhC.vArg[2]
    test_DY1.N
    z.z.re
    z.z.im
    systemDef.hrms[2]
 z.i[3].re
    PhA.vArg[3]
    PhC.vMag[3]
    test_DY1.N
    PhC.vArg[3]
    PhA.vMag[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 z.i[3].im
    PhA.vArg[3]
    PhC.vMag[3]
    test_DY1.N
    PhC.vArg[3]
    PhA.vMag[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
 z.omega
    systemDef.fFund



Connection sets: 133 sets
Connection set (flow): {ground1.pin.iIm[1:3] (i), r1.pin_n.iIm[1:3] (i), r2.pin_n.iIm[1:3] (i), test_DY1.hPin_N.iIm[1:3] (i), z.pin_n.iIm[1:3] (i)}
Connection set (flow): {ground1.pin.iRe[1:3] (i), r1.pin_n.iRe[1:3] (i), r2.pin_n.iRe[1:3] (i), test_DY1.hPin_N.iRe[1:3] (i), z.pin_n.iRe[1:3] (i)}
Connection set (potential): {ground1.pin.v[1].im (i), r1.pin_n.v[1].im (i), r2.pin_n.v[1].im (i), test_DY1.hPin_N.v[1].im (i), z.pin_n.v[1].im (i)}
Connection set (potential): {ground1.pin.v[1].re (i), r1.pin_n.v[1].re (i), r2.pin_n.v[1].re (i), test_DY1.hPin_N.v[1].re (i), z.pin_n.v[1].re (i)}
Connection set (potential): {ground1.pin.v[2].im (i), r1.pin_n.v[2].im (i), r2.pin_n.v[2].im (i), test_DY1.hPin_N.v[2].im (i), z.pin_n.v[2].im (i)}
Connection set (potential): {ground1.pin.v[2].re (i), r1.pin_n.v[2].re (i), r2.pin_n.v[2].re (i), test_DY1.hPin_N.v[2].re (i), z.pin_n.v[2].re (i)}
Connection set (potential): {ground1.pin.v[3].im (i), r1.pin_n.v[3].im (i), r2.pin_n.v[3].im (i), test_DY1.hPin_N.v[3].im (i), z.pin_n.v[3].im (i)}
Connection set (potential): {ground1.pin.v[3].re (i), r1.pin_n.v[3].re (i), r2.pin_n.v[3].re (i), test_DY1.hPin_N.v[3].re (i), z.pin_n.v[3].re (i)}
Connection set (flow): {PhA.pin_p.iIm[1:3] (i), test_DY1.pinPrim_A.iIm[1:3] (i)}
Connection set (flow): {PhA.pin_p.iRe[1:3] (i), test_DY1.pinPrim_A.iRe[1:3] (i)}
Connection set (potential): {PhA.pin_p.v[1].im (i), test_DY1.pinPrim_A.v[1].im (i)}
Connection set (potential): {PhA.pin_p.v[1].re (i), test_DY1.pinPrim_A.v[1].re (i)}
Connection set (potential): {PhA.pin_p.v[2].im (i), test_DY1.pinPrim_A.v[2].im (i)}
Connection set (potential): {PhA.pin_p.v[2].re (i), test_DY1.pinPrim_A.v[2].re (i)}
Connection set (potential): {PhA.pin_p.v[3].im (i), test_DY1.pinPrim_A.v[3].im (i)}
Connection set (potential): {PhA.pin_p.v[3].re (i), test_DY1.pinPrim_A.v[3].re (i)}
Connection set (flow): {PhB.pin_p.iIm[1:3] (i), test_DY1.pinPrim_B.iIm[1:3] (i)}
Connection set (flow): {PhB.pin_p.iRe[1:3] (i), test_DY1.pinPrim_B.iRe[1:3] (i)}
Connection set (potential): {PhB.pin_p.v[1].im (i), test_DY1.pinPrim_B.v[1].im (i)}
Connection set (potential): {PhB.pin_p.v[1].re (i), test_DY1.pinPrim_B.v[1].re (i)}
Connection set (potential): {PhB.pin_p.v[2].im (i), test_DY1.pinPrim_B.v[2].im (i)}
Connection set (potential): {PhB.pin_p.v[2].re (i), test_DY1.pinPrim_B.v[2].re (i)}
Connection set (potential): {PhB.pin_p.v[3].im (i), test_DY1.pinPrim_B.v[3].im (i)}
Connection set (potential): {PhB.pin_p.v[3].re (i), test_DY1.pinPrim_B.v[3].re (i)}
Connection set (flow): {PhC.pin_p.iIm[1:3] (i), test_DY1.pinPrim_C.iIm[1:3] (i)}
Connection set (flow): {PhC.pin_p.iRe[1:3] (i), test_DY1.pinPrim_C.iRe[1:3] (i)}
Connection set (potential): {PhC.pin_p.v[1].im (i), test_DY1.pinPrim_C.v[1].im (i)}
Connection set (potential): {PhC.pin_p.v[1].re (i), test_DY1.pinPrim_C.v[1].re (i)}
Connection set (potential): {PhC.pin_p.v[2].im (i), test_DY1.pinPrim_C.v[2].im (i)}
Connection set (potential): {PhC.pin_p.v[2].re (i), test_DY1.pinPrim_C.v[2].re (i)}
Connection set (potential): {PhC.pin_p.v[3].im (i), test_DY1.pinPrim_C.v[3].im (i)}
Connection set (potential): {PhC.pin_p.v[3].re (i), test_DY1.pinPrim_C.v[3].re (i)}
Connection set (flow): {PhA.pin_n.iIm[1:3] (i), PhB.pin_n.iIm[1:3] (i), PhC.pin_n.iIm[1:3] (i), ground.pin.iIm[1:3] (i)}
Connection set (flow): {PhA.pin_n.iRe[1:3] (i), PhB.pin_n.iRe[1:3] (i), PhC.pin_n.iRe[1:3] (i), ground.pin.iRe[1:3] (i)}
Connection set (potential): {PhA.pin_n.v[1].im (i), PhB.pin_n.v[1].im (i), PhC.pin_n.v[1].im (i), ground.pin.v[1].im (i)}
Connection set (potential): {PhA.pin_n.v[1].re (i), PhB.pin_n.v[1].re (i), PhC.pin_n.v[1].re (i), ground.pin.v[1].re (i)}
Connection set (potential): {PhA.pin_n.v[2].im (i), PhB.pin_n.v[2].im (i), PhC.pin_n.v[2].im (i), ground.pin.v[2].im (i)}
Connection set (potential): {PhA.pin_n.v[2].re (i), PhB.pin_n.v[2].re (i), PhC.pin_n.v[2].re (i), ground.pin.v[2].re (i)}
Connection set (potential): {PhA.pin_n.v[3].im (i), PhB.pin_n.v[3].im (i), PhC.pin_n.v[3].im (i), ground.pin.v[3].im (i)}
Connection set (potential): {PhA.pin_n.v[3].re (i), PhB.pin_n.v[3].re (i), PhC.pin_n.v[3].re (i), ground.pin.v[3].re (i)}
Connection set (flow): {r1.pin_p.iIm[1:3] (i), test_DY1.hPin_P2.iIm[1:3] (i)}
Connection set (flow): {r1.pin_p.iRe[1:3] (i), test_DY1.hPin_P2.iRe[1:3] (i)}
Connection set (potential): {r1.pin_p.v[1].im (i), test_DY1.hPin_P2.v[1].im (i)}
Connection set (potential): {r1.pin_p.v[1].re (i), test_DY1.hPin_P2.v[1].re (i)}
Connection set (potential): {r1.pin_p.v[2].im (i), test_DY1.hPin_P2.v[2].im (i)}
Connection set (potential): {r1.pin_p.v[2].re (i), test_DY1.hPin_P2.v[2].re (i)}
Connection set (potential): {r1.pin_p.v[3].im (i), test_DY1.hPin_P2.v[3].im (i)}
Connection set (potential): {r1.pin_p.v[3].re (i), test_DY1.hPin_P2.v[3].re (i)}
Connection set (flow): {r2.pin_p.iIm[1:3] (i), test_DY1.hPin_P3.iIm[1:3] (i)}
Connection set (flow): {r2.pin_p.iRe[1:3] (i), test_DY1.hPin_P3.iRe[1:3] (i)}
Connection set (potential): {r2.pin_p.v[1].im (i), test_DY1.hPin_P3.v[1].im (i)}
Connection set (potential): {r2.pin_p.v[1].re (i), test_DY1.hPin_P3.v[1].re (i)}
Connection set (potential): {r2.pin_p.v[2].im (i), test_DY1.hPin_P3.v[2].im (i)}
Connection set (potential): {r2.pin_p.v[2].re (i), test_DY1.hPin_P3.v[2].re (i)}
Connection set (potential): {r2.pin_p.v[3].im (i), test_DY1.hPin_P3.v[3].im (i)}
Connection set (potential): {r2.pin_p.v[3].re (i), test_DY1.hPin_P3.v[3].re (i)}
Connection set (flow): {test_DY1.hPin_P1.iIm[1:3] (i), z.pin_p.iIm[1:3] (i)}
Connection set (flow): {test_DY1.hPin_P1.iRe[1:3] (i), z.pin_p.iRe[1:3] (i)}
Connection set (potential): {test_DY1.hPin_P1.v[1].im (i), z.pin_p.v[1].im (i)}
Connection set (potential): {test_DY1.hPin_P1.v[1].re (i), z.pin_p.v[1].re (i)}
Connection set (potential): {test_DY1.hPin_P1.v[2].im (i), z.pin_p.v[2].im (i)}
Connection set (potential): {test_DY1.hPin_P1.v[2].re (i), z.pin_p.v[2].re (i)}
Connection set (potential): {test_DY1.hPin_P1.v[3].im (i), z.pin_p.v[3].im (i)}
Connection set (potential): {test_DY1.hPin_P1.v[3].re (i), z.pin_p.v[3].re (i)}
Connection set (flow): {test_DY1.idealTransformer1.pinP_Prim.iIm[1:3] (i), test_DY1.idealTransformer2.pinN_Prim.iIm[1:3] (i), test_DY1.pinPrim_A.iIm[1:3] (o)}
Connection set (flow): {test_DY1.idealTransformer1.pinP_Prim.iRe[1:3] (i), test_DY1.idealTransformer2.pinN_Prim.iRe[1:3] (i), test_DY1.pinPrim_A.iRe[1:3] (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinP_Prim.v[1].im (i), test_DY1.idealTransformer2.pinN_Prim.v[1].im (i), test_DY1.pinPrim_A.v[1].im (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinP_Prim.v[1].re (i), test_DY1.idealTransformer2.pinN_Prim.v[1].re (i), test_DY1.pinPrim_A.v[1].re (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinP_Prim.v[2].im (i), test_DY1.idealTransformer2.pinN_Prim.v[2].im (i), test_DY1.pinPrim_A.v[2].im (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinP_Prim.v[2].re (i), test_DY1.idealTransformer2.pinN_Prim.v[2].re (i), test_DY1.pinPrim_A.v[2].re (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinP_Prim.v[3].im (i), test_DY1.idealTransformer2.pinN_Prim.v[3].im (i), test_DY1.pinPrim_A.v[3].im (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinP_Prim.v[3].re (i), test_DY1.idealTransformer2.pinN_Prim.v[3].re (i), test_DY1.pinPrim_A.v[3].re (o)}
Connection set (flow): {test_DY1.idealTransformer1.pinN_Prim.iIm[1:3] (i), test_DY1.idealTransformer3.pinP_Prim.iIm[1:3] (i), test_DY1.pinPrim_C.iIm[1:3] (o)}
Connection set (flow): {test_DY1.idealTransformer1.pinN_Prim.iRe[1:3] (i), test_DY1.idealTransformer3.pinP_Prim.iRe[1:3] (i), test_DY1.pinPrim_C.iRe[1:3] (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinN_Prim.v[1].im (i), test_DY1.idealTransformer3.pinP_Prim.v[1].im (i), test_DY1.pinPrim_C.v[1].im (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinN_Prim.v[1].re (i), test_DY1.idealTransformer3.pinP_Prim.v[1].re (i), test_DY1.pinPrim_C.v[1].re (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinN_Prim.v[2].im (i), test_DY1.idealTransformer3.pinP_Prim.v[2].im (i), test_DY1.pinPrim_C.v[2].im (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinN_Prim.v[2].re (i), test_DY1.idealTransformer3.pinP_Prim.v[2].re (i), test_DY1.pinPrim_C.v[2].re (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinN_Prim.v[3].im (i), test_DY1.idealTransformer3.pinP_Prim.v[3].im (i), test_DY1.pinPrim_C.v[3].im (o)}
Connection set (potential): {test_DY1.idealTransformer1.pinN_Prim.v[3].re (i), test_DY1.idealTransformer3.pinP_Prim.v[3].re (i), test_DY1.pinPrim_C.v[3].re (o)}
Connection set (flow): {test_DY1.idealTransformer2.pinP_Prim.iIm[1:3] (i), test_DY1.idealTransformer3.pinN_Prim.iIm[1:3] (i), test_DY1.pinPrim_B.iIm[1:3] (o)}
Connection set (flow): {test_DY1.idealTransformer2.pinP_Prim.iRe[1:3] (i), test_DY1.idealTransformer3.pinN_Prim.iRe[1:3] (i), test_DY1.pinPrim_B.iRe[1:3] (o)}
Connection set (potential): {test_DY1.idealTransformer2.pinP_Prim.v[1].im (i), test_DY1.idealTransformer3.pinN_Prim.v[1].im (i), test_DY1.pinPrim_B.v[1].im (o)}
Connection set (potential): {test_DY1.idealTransformer2.pinP_Prim.v[1].re (i), test_DY1.idealTransformer3.pinN_Prim.v[1].re (i), test_DY1.pinPrim_B.v[1].re (o)}
Connection set (potential): {test_DY1.idealTransformer2.pinP_Prim.v[2].im (i), test_DY1.idealTransformer3.pinN_Prim.v[2].im (i), test_DY1.pinPrim_B.v[2].im (o)}
Connection set (potential): {test_DY1.idealTransformer2.pinP_Prim.v[2].re (i), test_DY1.idealTransformer3.pinN_Prim.v[2].re (i), test_DY1.pinPrim_B.v[2].re (o)}
Connection set (potential): {test_DY1.idealTransformer2.pinP_Prim.v[3].im (i), test_DY1.idealTransformer3.pinN_Prim.v[3].im (i), test_DY1.pinPrim_B.v[3].im (o)}
Connection set (potential): {test_DY1.idealTransformer2.pinP_Prim.v[3].re (i), test_DY1.idealTransformer3.pinN_Prim.v[3].re (i), test_DY1.pinPrim_B.v[3].re (o)}
Connection set (flow): {test_DY1.hPin_P1.iIm[1:3] (o), test_DY1.idealTransformer1.pinP_Sec.iIm[1:3] (i)}
Connection set (flow): {test_DY1.hPin_P1.iRe[1:3] (o), test_DY1.idealTransformer1.pinP_Sec.iRe[1:3] (i)}
Connection set (potential): {test_DY1.hPin_P1.v[1].im (o), test_DY1.idealTransformer1.pinP_Sec.v[1].im (i)}
Connection set (potential): {test_DY1.hPin_P1.v[1].re (o), test_DY1.idealTransformer1.pinP_Sec.v[1].re (i)}
Connection set (potential): {test_DY1.hPin_P1.v[2].im (o), test_DY1.idealTransformer1.pinP_Sec.v[2].im (i)}
Connection set (potential): {test_DY1.hPin_P1.v[2].re (o), test_DY1.idealTransformer1.pinP_Sec.v[2].re (i)}
Connection set (potential): {test_DY1.hPin_P1.v[3].im (o), test_DY1.idealTransformer1.pinP_Sec.v[3].im (i)}
Connection set (potential): {test_DY1.hPin_P1.v[3].re (o), test_DY1.idealTransformer1.pinP_Sec.v[3].re (i)}
Connection set (flow): {test_DY1.hPin_P2.iIm[1:3] (o), test_DY1.idealTransformer2.pinP_Sec.iIm[1:3] (i)}
Connection set (flow): {test_DY1.hPin_P2.iRe[1:3] (o), test_DY1.idealTransformer2.pinP_Sec.iRe[1:3] (i)}
Connection set (potential): {test_DY1.hPin_P2.v[1].im (o), test_DY1.idealTransformer2.pinP_Sec.v[1].im (i)}
Connection set (potential): {test_DY1.hPin_P2.v[1].re (o), test_DY1.idealTransformer2.pinP_Sec.v[1].re (i)}
Connection set (potential): {test_DY1.hPin_P2.v[2].im (o), test_DY1.idealTransformer2.pinP_Sec.v[2].im (i)}
Connection set (potential): {test_DY1.hPin_P2.v[2].re (o), test_DY1.idealTransformer2.pinP_Sec.v[2].re (i)}
Connection set (potential): {test_DY1.hPin_P2.v[3].im (o), test_DY1.idealTransformer2.pinP_Sec.v[3].im (i)}
Connection set (potential): {test_DY1.hPin_P2.v[3].re (o), test_DY1.idealTransformer2.pinP_Sec.v[3].re (i)}
Connection set (flow): {test_DY1.hPin_P3.iIm[1:3] (o), test_DY1.idealTransformer3.pinP_Sec.iIm[1:3] (i)}
Connection set (flow): {test_DY1.hPin_P3.iRe[1:3] (o), test_DY1.idealTransformer3.pinP_Sec.iRe[1:3] (i)}
Connection set (potential): {test_DY1.hPin_P3.v[1].im (o), test_DY1.idealTransformer3.pinP_Sec.v[1].im (i)}
Connection set (potential): {test_DY1.hPin_P3.v[1].re (o), test_DY1.idealTransformer3.pinP_Sec.v[1].re (i)}
Connection set (potential): {test_DY1.hPin_P3.v[2].im (o), test_DY1.idealTransformer3.pinP_Sec.v[2].im (i)}
Connection set (potential): {test_DY1.hPin_P3.v[2].re (o), test_DY1.idealTransformer3.pinP_Sec.v[2].re (i)}
Connection set (potential): {test_DY1.hPin_P3.v[3].im (o), test_DY1.idealTransformer3.pinP_Sec.v[3].im (i)}
Connection set (potential): {test_DY1.hPin_P3.v[3].re (o), test_DY1.idealTransformer3.pinP_Sec.v[3].re (i)}
Connection set (flow): {test_DY1.hPin_N.iIm[1:3] (o), test_DY1.idealTransformer1.pinN_Sec.iIm[1:3] (i), test_DY1.idealTransformer2.pinN_Sec.iIm[1:3] (i), test_DY1.idealTransformer3.pinN_Sec.iIm[1:3] (i)}
Connection set (flow): {test_DY1.hPin_N.iRe[1:3] (o), test_DY1.idealTransformer1.pinN_Sec.iRe[1:3] (i), test_DY1.idealTransformer2.pinN_Sec.iRe[1:3] (i), test_DY1.idealTransformer3.pinN_Sec.iRe[1:3] (i)}
Connection set (potential): {test_DY1.hPin_N.v[1].im (o), test_DY1.idealTransformer1.pinN_Sec.v[1].im (i), test_DY1.idealTransformer2.pinN_Sec.v[1].im (i), test_DY1.idealTransformer3.pinN_Sec.v[1].im (i)}
Connection set (potential): {test_DY1.hPin_N.v[1].re (o), test_DY1.idealTransformer1.pinN_Sec.v[1].re (i), test_DY1.idealTransformer2.pinN_Sec.v[1].re (i), test_DY1.idealTransformer3.pinN_Sec.v[1].re (i)}
Connection set (potential): {test_DY1.hPin_N.v[2].im (o), test_DY1.idealTransformer1.pinN_Sec.v[2].im (i), test_DY1.idealTransformer2.pinN_Sec.v[2].im (i), test_DY1.idealTransformer3.pinN_Sec.v[2].im (i)}
Connection set (potential): {test_DY1.hPin_N.v[2].re (o), test_DY1.idealTransformer1.pinN_Sec.v[2].re (i), test_DY1.idealTransformer2.pinN_Sec.v[2].re (i), test_DY1.idealTransformer3.pinN_Sec.v[2].re (i)}
Connection set (potential): {test_DY1.hPin_N.v[3].im (o), test_DY1.idealTransformer1.pinN_Sec.v[3].im (i), test_DY1.idealTransformer2.pinN_Sec.v[3].im (i), test_DY1.idealTransformer3.pinN_Sec.v[3].im (i)}
Connection set (potential): {test_DY1.hPin_N.v[3].re (o), test_DY1.idealTransformer1.pinN_Sec.v[3].re (i), test_DY1.idealTransformer2.pinN_Sec.v[3].re (i), test_DY1.idealTransformer3.pinN_Sec.v[3].re (i)}
Connection set (potential): {PhA.pin_p.reference.theta (i), test_DY1.pinPrim_A.reference.theta (i)}
Connection set (potential): {test_DY1.idealTransformer1.pinP_Prim.reference.theta (i), test_DY1.idealTransformer2.pinN_Prim.reference.theta (i), test_DY1.pinPrim_A.reference.theta (o)}
Connection set (potential): {PhA.pin_n.reference.theta (i), ground.pin.reference.theta (i)}
Connection set (potential): {test_DY1.idealTransformer1.pinN_Prim.reference.theta (i), test_DY1.idealTransformer3.pinP_Prim.reference.theta (i), test_DY1.pinPrim_C.reference.theta (o)}
Connection set (potential): {test_DY1.hPin_N.reference.theta (o), test_DY1.idealTransformer1.pinN_Sec.reference.theta (i)}
Connection set (potential): {test_DY1.hPin_P1.reference.theta (o), test_DY1.idealTransformer1.pinP_Sec.reference.theta (i)}
Connection set (potential): {test_DY1.idealTransformer2.pinP_Prim.reference.theta (i), test_DY1.pinPrim_B.reference.theta (o)}
Connection set (potential): {test_DY1.hPin_P2.reference.theta (o), test_DY1.idealTransformer2.pinP_Sec.reference.theta (i)}
Connection set (potential): {test_DY1.hPin_P3.reference.theta (o), test_DY1.idealTransformer3.pinP_Sec.reference.theta (i)}
Connection set (potential): {ground1.pin.reference.theta (i), test_DY1.hPin_N.reference.theta (i)}
Connection set (potential): {test_DY1.hPin_P1.reference.theta (i), z.pin_p.reference.theta (i)}
Connection set (potential): {r1.pin_p.reference.theta (i), test_DY1.hPin_P2.reference.theta (i)}
Connection set (potential): {r2.pin_p.reference.theta (i), test_DY1.hPin_P3.reference.theta (i)}

Transformed flattened model:
fclass HPF.Test.Multiphase_Transformer
 parameter Integer systemDef.hrms[1] = 1 "Harmonics to simulate" /* 1 */;
 parameter Integer systemDef.hrms[2] = 3 "Harmonics to simulate" /* 3 */;
 parameter Integer systemDef.hrms[3] = 5 "Harmonics to simulate" /* 5 */;
 structural parameter Integer systemDef.numHrm = 3 "Number of harmonics. (Automatically generated from hrms. Do not alter)" /* 3 */;
 parameter Integer systemDef.numHigherHrm = 2 /* 2 */;
 parameter Integer systemDef.numPh = 3 "Number of phases" /* 3 */;
 parameter Real systemDef.fFund = 60 "Fundamental frequency" /* 60 */;
 discrete Boolean systemDef.modeSelect(start = true);
 discrete Boolean systemDef.event1(start = false);
 discrete Boolean systemDef.event2(start = false);
 parameter Integer test_DY1.N = 4 "Turns ration" /* 4 */;
 parameter Real test_DY1.idealTransformer1.N "Turns ratio N1:N2 = N:1 (Subject to review!)";
 parameter Real test_DY1.idealTransformer2.N "Turns ratio N1:N2 = N:1 (Subject to review!)";
 parameter Real test_DY1.idealTransformer3.N "Turns ratio N1:N2 = N:1 (Subject to review!)";
 parameter Real PhA.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhA.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhA.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhA.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real test_DY1.idealTransformer1.iPrim[1].re "Real part of complex number";
 Real test_DY1.idealTransformer1.iPrim[1].im "Imaginary part of complex number";
 Real test_DY1.idealTransformer1.iPrim[2].re "Real part of complex number";
 Real test_DY1.idealTransformer1.iPrim[2].im "Imaginary part of complex number";
 Real test_DY1.idealTransformer1.iPrim[3].re "Real part of complex number";
 Real test_DY1.idealTransformer1.iPrim[3].im "Imaginary part of complex number";
 parameter Real PhA.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhA.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhB.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhB.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhB.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhC.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhC.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhC.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhC.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhC.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhC.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real temp_74;
 parameter Real temp_89;
 parameter Real temp_104;
 parameter Real temp_224;
 parameter Real temp_239;
 parameter Real temp_254;
 parameter Real temp_374;
 parameter Real temp_389;
 parameter Real temp_404;
 parameter Real test_DY1.idealTransformer2.vPrim[1].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer2.vPrim[2].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer2.vPrim[3].re "Real part of complex number";
 Real test_DY1.hPin_N.iIm[1];
 Real test_DY1.hPin_N.iIm[2];
 Real test_DY1.hPin_N.iIm[3];
 Real test_DY1.hPin_N.iRe[1];
 Real test_DY1.hPin_N.iRe[2];
 Real test_DY1.hPin_N.iRe[3];
 parameter Real PhA.vMag[1] = 392 "Voltage Magnitude" /* 392 */;
 parameter Real PhA.vMag[2] = 10 "Voltage Magnitude" /* 10 */;
 parameter Real PhA.vMag[3] = 3 "Voltage Magnitude" /* 3 */;
 parameter Real PhA.vArg[1] = 0 "Voltage angle" /* 0 */;
 parameter Real PhA.vArg[2] = 0.5 "Voltage angle" /* 0.5 */;
 parameter Real PhA.vArg[3] = 2.3 "Voltage angle" /* 2.3 */;
 Modelica.SIunits.Angle PhA.theta(start = 0);
 parameter Real test_DY1.idealTransformer2.vPrim[1].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer2.vPrim[2].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer2.vPrim[3].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[1].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer3.vPrim[1].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[2].re "Real part of complex number";
 Real PhA.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhA.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhA.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhA.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhA.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhA.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhA.omega;
 constant Real PhA.pin_n.v[1].re = 0.0 "Real part of complex number";
 constant Real PhA.pin_n.v[1].im = 0 "Imaginary part of complex number";
 parameter Real PhB.vMag[1] = 392 "Voltage Magnitude" /* 392 */;
 parameter Real PhB.vMag[2] = 11 "Voltage Magnitude" /* 11 */;
 parameter Real PhB.vMag[3] = 2.6 "Voltage Magnitude" /* 2.6 */;
 parameter Real PhB.vArg[1] = -2.0943951023931953 "Voltage angle" /* -2.0943951023931953 */;
 parameter Real PhB.vArg[2] = 0 "Voltage angle" /* 0 */;
 parameter Real PhB.vArg[3] = 1.2 "Voltage angle" /* 1.2 */;
 Modelica.SIunits.Angle PhB.theta(start = 0);
 parameter Real test_DY1.idealTransformer3.vPrim[2].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[3].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer3.vPrim[3].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[1].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.vPrim[1].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[2].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.vPrim[2].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer1.vPrim[3].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.vPrim[3].im "Imaginary part of complex number";
 parameter Real r1.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r1.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r1.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhB.omega;
 parameter Real PhC.vMag[1] = 392 "Voltage Magnitude" /* 392 */;
 parameter Real PhC.vMag[2] = 10 "Voltage Magnitude" /* 10 */;
 parameter Real PhC.vMag[3] = 3 "Voltage Magnitude" /* 3 */;
 parameter Real PhC.vArg[1] = 2.0943951023931953 "Voltage angle" /* 2.0943951023931953 */;
 parameter Real PhC.vArg[2] = 0.6 "Voltage angle" /* 0.6 */;
 parameter Real PhC.vArg[3] = 2.1 "Voltage angle" /* 2.1 */;
 Modelica.SIunits.Angle PhC.theta(start = 0);
 parameter Real r1.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r1.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r1.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real z.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r2.v[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real z.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhC.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhC.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhC.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhC.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhC.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 Real PhC.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real PhC.omega;
 Real ground.pin.iIm[1];
 Real ground.pin.iIm[2];
 Real ground.pin.iIm[3];
 Real ground.pin.iRe[1];
 Real ground.pin.iRe[2];
 Real ground.pin.iRe[3];
 Real ground1.pin.iIm[1];
 Real ground1.pin.iIm[2];
 Real ground1.pin.iIm[3];
 Real ground1.pin.iRe[1];
 Real ground1.pin.iRe[2];
 Real ground1.pin.iRe[3];
 parameter Real r1.r(start = 1) = 500 "Resistance (ohm)" /* 500 */;
 parameter Real r2.v[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real z.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r2.v[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real z.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.v[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real z.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.v[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real z.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.v[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r1.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r1.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r1.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r1.vFundAbs;
 parameter Real r1.vFundArg;
 parameter Real r1.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r1.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real r1.omega;
 parameter Real r2.r(start = 1) = 500 "Resistance (ohm)" /* 500 */;
 parameter Real r1.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r2.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real r2.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real z.vFundAbs;
 parameter Real z.vFundArg;
 parameter Real r2.vFundAbs;
 parameter Real r2.vFundArg;
 parameter Real r2.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real r2.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer2.iPrim[1].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer2.iPrim[2].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer2.iPrim[3].re "Real part of complex number";
 parameter Real r1.iFundAbs;
 parameter Real r1.iFundArg;
 Real r2.omega;
 parameter Real z.z.re(start = 1) = 500 "Real part of complex number" /* 500 */;
 parameter Real z.z.im(start = 0) = 20 "Imaginary part of complex number" /* 20 */;
 parameter Real test_DY1.idealTransformer2.iPrim[1].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer2.iPrim[2].im "Imaginary part of complex number";
 Real z.iFundAbs;
 Real z.iFundArg;
 parameter Real test_DY1.idealTransformer2.iPrim[3].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.iPrim[1].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer3.iPrim[2].re "Real part of complex number";
 parameter Real test_DY1.idealTransformer3.iPrim[3].re "Real part of complex number";
 parameter Real r2.iFundAbs;
 parameter Real r2.iFundArg;
 Real z.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 Real z.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real z.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 Real z.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real z.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 Real z.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
 Real z.omega;
 discrete Boolean temp_62;
 discrete Boolean temp_63;
 discrete Boolean temp_64;
 parameter Real test_DY1.idealTransformer3.iPrim[1].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.iPrim[2].im "Imaginary part of complex number";
 parameter Real test_DY1.idealTransformer3.iPrim[3].im "Imaginary part of complex number";
 parameter Real PhB.i[1].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.i[2].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.i[3].re(start = 0,nominal = 1) "Real part of complex number";
 parameter Real PhB.i[1].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhB.i[2].im(start = 0,nominal = 1) "Imaginary part of complex number";
 parameter Real PhB.i[3].im(start = 0,nominal = 1) "Imaginary part of complex number";
initial equation
 algorithm
  systemDef.modeSelect := false;
;
 PhA.theta = 0;
 PhB.theta = 0;
 PhC.theta = 0;
 pre(systemDef.event1) = false;
 pre(systemDef.event2) = false;
 pre(temp_62) = false;
 pre(temp_63) = false;
 pre(temp_64) = false;
parameter equation
 test_DY1.idealTransformer1.N = test_DY1.N;
 test_DY1.idealTransformer2.N = test_DY1.N;
 test_DY1.idealTransformer3.N = test_DY1.N;
 PhA.v[1].re = PhA.vMag[1] .* cos(PhA.vArg[1]);
 PhA.v[2].re = PhA.vMag[2] .* cos(PhA.vArg[2]);
 PhA.v[3].re = PhA.vMag[3] .* cos(PhA.vArg[3]);
 PhA.v[1].im = PhA.vMag[1] .* sin(PhA.vArg[1]);
 PhA.v[2].im = PhA.vMag[2] .* sin(PhA.vArg[2]);
 PhA.v[3].im = PhA.vMag[3] .* sin(PhA.vArg[3]);
 PhB.v[1].re = PhB.vMag[1] .* cos(PhB.vArg[1]);
 PhB.v[2].re = PhB.vMag[2] .* cos(PhB.vArg[2]);
 PhB.v[3].re = PhB.vMag[3] .* cos(PhB.vArg[3]);
 PhB.v[1].im = PhB.vMag[1] .* sin(PhB.vArg[1]);
 PhB.v[2].im = PhB.vMag[2] .* sin(PhB.vArg[2]);
 PhB.v[3].im = PhB.vMag[3] .* sin(PhB.vArg[3]);
 PhC.v[1].re = PhC.vMag[1] .* cos(PhC.vArg[1]);
 PhC.v[2].re = PhC.vMag[2] .* cos(PhC.vArg[2]);
 PhC.v[3].re = PhC.vMag[3] .* cos(PhC.vArg[3]);
 PhC.v[1].im = PhC.vMag[1] .* sin(PhC.vArg[1]);
 PhC.v[2].im = PhC.vMag[2] .* sin(PhC.vArg[2]);
 PhC.v[3].im = PhC.vMag[3] .* sin(PhC.vArg[3]);
 temp_74 = 1 / test_DY1.idealTransformer1.N;
 temp_89 = 1 / test_DY1.idealTransformer1.N;
 temp_104 = 1 / test_DY1.idealTransformer1.N;
 temp_224 = 1 / test_DY1.idealTransformer2.N;
 temp_239 = 1 / test_DY1.idealTransformer2.N;
 temp_254 = 1 / test_DY1.idealTransformer2.N;
 temp_374 = 1 / test_DY1.idealTransformer3.N;
 temp_389 = 1 / test_DY1.idealTransformer3.N;
 temp_404 = 1 / test_DY1.idealTransformer3.N;
 test_DY1.idealTransformer2.vPrim[1].re = PhB.v[1].re + (- PhA.v[1].re);
 test_DY1.idealTransformer2.vPrim[2].re = PhB.v[2].re + (- PhA.v[2].re);
 test_DY1.idealTransformer2.vPrim[3].re = PhB.v[3].re + (- PhA.v[3].re);
 test_DY1.idealTransformer2.vPrim[1].im = PhB.v[1].im + (- PhA.v[1].im);
 test_DY1.idealTransformer2.vPrim[2].im = PhB.v[2].im + (- PhA.v[2].im);
 test_DY1.idealTransformer2.vPrim[3].im = PhB.v[3].im + (- PhA.v[3].im);
 test_DY1.idealTransformer1.vPrim[1].re = PhA.v[1].re + (- PhC.v[1].re);
 test_DY1.idealTransformer3.vPrim[1].re = PhC.v[1].re + (- PhB.v[1].re);
 test_DY1.idealTransformer1.vPrim[2].re = PhA.v[2].re + (- PhC.v[2].re);
 test_DY1.idealTransformer3.vPrim[2].re = PhC.v[2].re + (- PhB.v[2].re);
 test_DY1.idealTransformer1.vPrim[3].re = PhA.v[3].re + (- PhC.v[3].re);
 test_DY1.idealTransformer3.vPrim[3].re = PhC.v[3].re + (- PhB.v[3].re);
 test_DY1.idealTransformer1.vPrim[1].im = PhA.v[1].im + (- PhC.v[1].im);
 test_DY1.idealTransformer3.vPrim[1].im = PhC.v[1].im + (- PhB.v[1].im);
 test_DY1.idealTransformer1.vPrim[2].im = PhA.v[2].im + (- PhC.v[2].im);
 test_DY1.idealTransformer3.vPrim[2].im = PhC.v[2].im + (- PhB.v[2].im);
 test_DY1.idealTransformer1.vPrim[3].im = PhA.v[3].im + (- PhC.v[3].im);
 test_DY1.idealTransformer3.vPrim[3].im = PhC.v[3].im + (- PhB.v[3].im);
 r1.v[1].re = temp_224 * test_DY1.idealTransformer2.vPrim[1].re;
 r1.v[2].re = temp_239 * test_DY1.idealTransformer2.vPrim[2].re;
 r1.v[3].re = temp_254 * test_DY1.idealTransformer2.vPrim[3].re;
 r1.v[1].im = temp_224 * test_DY1.idealTransformer2.vPrim[1].im;
 r1.v[2].im = temp_239 * test_DY1.idealTransformer2.vPrim[2].im;
 r1.v[3].im = temp_254 * test_DY1.idealTransformer2.vPrim[3].im;
 z.v[1].re = temp_74 * test_DY1.idealTransformer1.vPrim[1].re;
 r2.v[1].re = temp_374 * test_DY1.idealTransformer3.vPrim[1].re;
 z.v[2].re = temp_89 * test_DY1.idealTransformer1.vPrim[2].re;
 r2.v[2].re = temp_389 * test_DY1.idealTransformer3.vPrim[2].re;
 z.v[3].re = temp_104 * test_DY1.idealTransformer1.vPrim[3].re;
 r2.v[3].re = temp_404 * test_DY1.idealTransformer3.vPrim[3].re;
 z.v[1].im = temp_74 * test_DY1.idealTransformer1.vPrim[1].im;
 r2.v[1].im = temp_374 * test_DY1.idealTransformer3.vPrim[1].im;
 z.v[2].im = temp_89 * test_DY1.idealTransformer1.vPrim[2].im;
 r2.v[2].im = temp_389 * test_DY1.idealTransformer3.vPrim[2].im;
 z.v[3].im = temp_104 * test_DY1.idealTransformer1.vPrim[3].im;
 r2.v[3].im = temp_404 * test_DY1.idealTransformer3.vPrim[3].im;
 r1.i[1].re = (- r1.v[1].re) / (- r1.r);
 r1.i[2].re = (- r1.v[2].re) / (- r1.r);
 r1.i[3].re = (- r1.v[3].re) / (- r1.r);
 r1.vFundAbs = (r1.v[1].re ^ 2 + r1.v[1].im ^ 2) ^ 0.5;
 r1.vFundArg = Modelica.Math.atan3(r1.v[1].im, r1.v[1].re, 0);
 r1.i[1].im = (- r1.v[1].im) / (- r1.r);
 r1.i[2].im = (- r1.v[2].im) / (- r1.r);
 r1.i[3].im = (- r1.v[3].im) / (- r1.r);
 r2.i[1].re = (- r2.v[1].re) / (- r2.r);
 r2.i[2].re = (- r2.v[2].re) / (- r2.r);
 r2.i[3].re = (- r2.v[3].re) / (- r2.r);
 z.vFundAbs = (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5;
 z.vFundArg = Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0);
 r2.vFundAbs = (r2.v[1].re ^ 2 + r2.v[1].im ^ 2) ^ 0.5;
 r2.vFundArg = Modelica.Math.atan3(r2.v[1].im, r2.v[1].re, 0);
 r2.i[1].im = (- r2.v[1].im) / (- r2.r);
 r2.i[2].im = (- r2.v[2].im) / (- r2.r);
 r2.i[3].im = (- r2.v[3].im) / (- r2.r);
 test_DY1.idealTransformer2.iPrim[1].re = r1.i[1].re / (- test_DY1.idealTransformer2.N);
 test_DY1.idealTransformer2.iPrim[2].re = r1.i[2].re / (- test_DY1.idealTransformer2.N);
 test_DY1.idealTransformer2.iPrim[3].re = r1.i[3].re / (- test_DY1.idealTransformer2.N);
 r1.iFundAbs = (r1.i[1].re ^ 2 + r1.i[1].im ^ 2) ^ 0.5;
 r1.iFundArg = Modelica.Math.atan3(r1.i[1].im, r1.i[1].re, 0);
 test_DY1.idealTransformer2.iPrim[1].im = r1.i[1].im / (- test_DY1.idealTransformer2.N);
 test_DY1.idealTransformer2.iPrim[2].im = r1.i[2].im / (- test_DY1.idealTransformer2.N);
 test_DY1.idealTransformer2.iPrim[3].im = r1.i[3].im / (- test_DY1.idealTransformer2.N);
 test_DY1.idealTransformer3.iPrim[1].re = r2.i[1].re / (- test_DY1.idealTransformer3.N);
 test_DY1.idealTransformer3.iPrim[2].re = r2.i[2].re / (- test_DY1.idealTransformer3.N);
 test_DY1.idealTransformer3.iPrim[3].re = r2.i[3].re / (- test_DY1.idealTransformer3.N);
 r2.iFundAbs = (r2.i[1].re ^ 2 + r2.i[1].im ^ 2) ^ 0.5;
 r2.iFundArg = Modelica.Math.atan3(r2.i[1].im, r2.i[1].re, 0);
 test_DY1.idealTransformer3.iPrim[1].im = r2.i[1].im / (- test_DY1.idealTransformer3.N);
 test_DY1.idealTransformer3.iPrim[2].im = r2.i[2].im / (- test_DY1.idealTransformer3.N);
 test_DY1.idealTransformer3.iPrim[3].im = r2.i[3].im / (- test_DY1.idealTransformer3.N);
 PhB.i[1].re = - test_DY1.idealTransformer2.iPrim[1].re + test_DY1.idealTransformer3.iPrim[1].re;
 PhB.i[2].re = - test_DY1.idealTransformer2.iPrim[2].re + test_DY1.idealTransformer3.iPrim[2].re;
 PhB.i[3].re = - test_DY1.idealTransformer2.iPrim[3].re + test_DY1.idealTransformer3.iPrim[3].re;
 PhB.i[1].im = - test_DY1.idealTransformer2.iPrim[1].im + test_DY1.idealTransformer3.iPrim[1].im;
 PhB.i[2].im = - test_DY1.idealTransformer2.iPrim[2].im + test_DY1.idealTransformer3.iPrim[2].im;
 PhB.i[3].im = - test_DY1.idealTransformer2.iPrim[3].im + test_DY1.idealTransformer3.iPrim[3].im;
equation
 temp_62 = time > 0.5;
 temp_63 = time > 0.25;
 temp_64 = time > 0.4;
algorithm
 if temp_62 and not pre(temp_62) then
  systemDef.modeSelect := true;
 end if;
 if temp_63 and not pre(temp_63) then
  systemDef.event1 := true;
 end if;
 if temp_64 and not pre(temp_64) then
  systemDef.event2 := true;
 end if;
equation
 - z.i[1].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].re;
 - z.i[1].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[1].im;
 - z.i[2].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].re;
 - z.i[2].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[2].im;
 - z.i[3].re = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].re;
 - z.i[3].im = test_DY1.idealTransformer1.N * test_DY1.idealTransformer1.iPrim[3].im;
 der(PhA.theta) = 6.283185307179586 * systemDef.fFund;
 PhA.omega = der(PhA.theta);
 der(PhB.theta) = 6.283185307179586 * systemDef.fFund;
 PhB.omega = der(PhB.theta);
 der(PhC.theta) = 6.283185307179586 * systemDef.fFund;
 PhC.omega = der(PhC.theta);
 r1.omega = der(PhA.theta);
 r2.omega = der(PhA.theta);
 z.v[1].re = z.z.re .* z.i[1].re - z.z.im .* systemDef.hrms[1] .* z.i[1].im;
 z.v[2].re = z.z.re .* z.i[2].re - z.z.im .* systemDef.hrms[2] .* z.i[2].im;
 z.v[3].re = z.z.re .* z.i[3].re - z.z.im .* systemDef.hrms[3] .* z.i[3].im;
 z.v[1].im = z.z.re .* z.i[1].im + z.z.im .* systemDef.hrms[1] .* z.i[1].re;
 z.v[2].im = z.z.re .* z.i[2].im + z.z.im .* systemDef.hrms[2] .* z.i[2].re;
 z.v[3].im = z.z.re .* z.i[3].im + z.z.im .* systemDef.hrms[3] .* z.i[3].re;
 z.omega = der(PhA.theta);
 ground1.pin.iIm[1] + (- r1.i[1].im) + (- r2.i[1].im) + test_DY1.hPin_N.iIm[1] + (- z.i[1].im) = 0;
 ground1.pin.iIm[2] + (- r1.i[2].im) + (- r2.i[2].im) + test_DY1.hPin_N.iIm[2] + (- z.i[2].im) = 0;
 ground1.pin.iIm[3] + (- r1.i[3].im) + (- r2.i[3].im) + test_DY1.hPin_N.iIm[3] + (- z.i[3].im) = 0;
 ground1.pin.iRe[1] + (- r1.i[1].re) + (- r2.i[1].re) + test_DY1.hPin_N.iRe[1] + (- z.i[1].re) = 0;
 ground1.pin.iRe[2] + (- r1.i[2].re) + (- r2.i[2].re) + test_DY1.hPin_N.iRe[2] + (- z.i[2].re) = 0;
 ground1.pin.iRe[3] + (- r1.i[3].re) + (- r2.i[3].re) + test_DY1.hPin_N.iRe[3] + (- z.i[3].re) = 0;
 - PhA.i[1].im + (- PhB.i[1].im) + (- PhC.i[1].im) + ground.pin.iIm[1] = 0;
 - PhA.i[2].im + (- PhB.i[2].im) + (- PhC.i[2].im) + ground.pin.iIm[2] = 0;
 - PhA.i[3].im + (- PhB.i[3].im) + (- PhC.i[3].im) + ground.pin.iIm[3] = 0;
 - PhA.i[1].re + (- PhB.i[1].re) + (- PhC.i[1].re) + ground.pin.iRe[1] = 0;
 - PhA.i[2].re + (- PhB.i[2].re) + (- PhC.i[2].re) + ground.pin.iRe[2] = 0;
 - PhA.i[3].re + (- PhB.i[3].re) + (- PhC.i[3].re) + ground.pin.iRe[3] = 0;
 test_DY1.idealTransformer1.iPrim[1].im + (- test_DY1.idealTransformer2.iPrim[1].im) + PhA.i[1].im = 0;
 test_DY1.idealTransformer1.iPrim[2].im + (- test_DY1.idealTransformer2.iPrim[2].im) + PhA.i[2].im = 0;
 test_DY1.idealTransformer1.iPrim[3].im + (- test_DY1.idealTransformer2.iPrim[3].im) + PhA.i[3].im = 0;
 test_DY1.idealTransformer1.iPrim[1].re + (- test_DY1.idealTransformer2.iPrim[1].re) + PhA.i[1].re = 0;
 test_DY1.idealTransformer1.iPrim[2].re + (- test_DY1.idealTransformer2.iPrim[2].re) + PhA.i[2].re = 0;
 test_DY1.idealTransformer1.iPrim[3].re + (- test_DY1.idealTransformer2.iPrim[3].re) + PhA.i[3].re = 0;
 - test_DY1.idealTransformer1.iPrim[1].im + test_DY1.idealTransformer3.iPrim[1].im + PhC.i[1].im = 0;
 - test_DY1.idealTransformer1.iPrim[2].im + test_DY1.idealTransformer3.iPrim[2].im + PhC.i[2].im = 0;
 - test_DY1.idealTransformer1.iPrim[3].im + test_DY1.idealTransformer3.iPrim[3].im + PhC.i[3].im = 0;
 - test_DY1.idealTransformer1.iPrim[1].re + test_DY1.idealTransformer3.iPrim[1].re + PhC.i[1].re = 0;
 - test_DY1.idealTransformer1.iPrim[2].re + test_DY1.idealTransformer3.iPrim[2].re + PhC.i[2].re = 0;
 - test_DY1.idealTransformer1.iPrim[3].re + test_DY1.idealTransformer3.iPrim[3].re + PhC.i[3].re = 0;
 0 = ground1.pin.iIm[1];
 0 = ground1.pin.iIm[2];
 0 = ground1.pin.iIm[3];
 0 = ground1.pin.iRe[1];
 0 = ground1.pin.iRe[2];
 0 = ground1.pin.iRe[3];
 HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhC.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint(HPF.Types.Reference(PhB.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhC.theta));
 HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint(HPF.Types.Reference(PhA.theta), HPF.Types.Reference(PhA.theta));
 z.iFundAbs = (z.i[1].re ^ 2 + z.i[1].im ^ 2) ^ 0.5;
 z.iFundArg = Modelica.Math.atan3(z.i[1].im, z.i[1].re, 0);

public
 function Modelica.Math.atan3
  input Real u1;
  input Real u2;
  input Real y0;
  output Real y;
  Real w;
 algorithm
  w := atan2(u1, u2);
  if y0 == 0 then
   y := w;
  else
   y := w + 6.283185307179586 * integer((3.141592653589793 + y0 - w) / 6.283185307179586);
  end if;
  return;
 end Modelica.Math.atan3;

 function HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer2.pinN_Sec.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Sec.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.PhC.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.PhB.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.idealTransformer3.pinN_Prim.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.PhB.pin_p.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.test_DY1.pinPrim_C.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.r2.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.r1.pin_n.reference.equalityConstraint;

 function HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Multiphase_Transformer.z.pin_n.reference.equalityConstraint;

 record HPF.Types.Reference
  Modelica.SIunits.Angle theta;
 end HPF.Types.Reference;

 type Modelica.SIunits.Angle = Real(final quantity = "Angle",final unit = "rad",displayUnit = "deg");
end HPF.Test.Multiphase_Transformer;

Generating code...
====== Model compiled successfully =======
make -f /home/avpreetsingh/programfiles/jModelica/Makefiles/MakeFile fmume20_
make[1]: Entering directory '/tmp/jmc2493939307725910787out'
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/avpreetsingh/programfiles/jModelica/include/RuntimeLibrary -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/FMI/2.0  -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/Sundials/include -c -o HPF_Test_Multiphase_Transformer_equ.o sources/HPF_Test_Multiphase_Transformer_equ.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/avpreetsingh/programfiles/jModelica/include/RuntimeLibrary -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/FMI/2.0  -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/Sundials/include -c -o HPF_Test_Multiphase_Transformer_base.o sources/HPF_Test_Multiphase_Transformer_base.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/avpreetsingh/programfiles/jModelica/include/RuntimeLibrary -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/FMI/2.0  -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/Sundials/include -c -o HPF_Test_Multiphase_Transformer_init_dependent.o sources/HPF_Test_Multiphase_Transformer_init_dependent.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/avpreetsingh/programfiles/jModelica/include/RuntimeLibrary -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/FMI/2.0  -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/Sundials/include -c -o HPF_Test_Multiphase_Transformer_init_independent.o sources/HPF_Test_Multiphase_Transformer_init_independent.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -O1 -I/home/avpreetsingh/programfiles/jModelica/include/RuntimeLibrary -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/FMI/2.0  -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/Sundials/include -c -o HPF_Test_Multiphase_Transformer_funcs.o sources/HPF_Test_Multiphase_Transformer_funcs.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/avpreetsingh/programfiles/jModelica/include/RuntimeLibrary -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/FMI/2.0  -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/Sundials/include -c -o HPF_Test_Multiphase_Transformer.o sources/HPF_Test_Multiphase_Transformer.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/avpreetsingh/programfiles/jModelica/include/RuntimeLibrary -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/FMI/2.0  -I/home/avpreetsingh/programfiles/jModelica/ThirdParty/Sundials/include -c -o HPF_Test_Multiphase_Transformer_equ_init.o sources/HPF_Test_Multiphase_Transformer_equ_init.c
mkdir -p binaries/linux64
g++ -shared -Wl,-rpath,'$ORIGIN',--no-undefined -pthread -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -o binaries/linux64/HPF_Test_Multiphase_Transformer.so  HPF_Test_Multiphase_Transformer_equ.o  HPF_Test_Multiphase_Transformer_base.o  HPF_Test_Multiphase_Transformer_init_dependent.o  HPF_Test_Multiphase_Transformer_init_independent.o  HPF_Test_Multiphase_Transformer_funcs.o  HPF_Test_Multiphase_Transformer.o  HPF_Test_Multiphase_Transformer_equ_init.o  -L/home/avpreetsingh/programfiles/jModelica/lib/RuntimeLibrary -lfmi2 -ljmi -ldl "-L/home/avpreetsingh/programfiles/jModelica/lib"  -ljmi_get_set_default -ljmi_get_set_default -llapack -lblas -lgfortran -lModelicaExternalC -lzlib -ljmi -L/home/avpreetsingh/programfiles/jModelica/ThirdParty/Sundials/lib -l:libsundials_kinsol.a -l:libsundials_nvecserial.a -L/home/avpreetsingh/programfiles/jModelica/ThirdParty/Minpack/lib -l:libcminpack.a -lstdc++ -lm -l:libsundials_cvode.a
rm -f  HPF_Test_Multiphase_Transformer_equ.o  HPF_Test_Multiphase_Transformer_base.o  HPF_Test_Multiphase_Transformer_init_dependent.o  HPF_Test_Multiphase_Transformer_init_independent.o  HPF_Test_Multiphase_Transformer_funcs.o  HPF_Test_Multiphase_Transformer.o  HPF_Test_Multiphase_Transformer_equ_init.o 
make[1]: Leaving directory '/tmp/jmc2493939307725910787out'

