Compiler arguments:
  -log=verbose: compile_log.txt,w|xml|stderr -target=me -version=2.0 -platform=linux64 -out=. -modelicapath=/home/linuxdev/jmodelica/ThirdParty/MSL ../../../HPF HPF.Test.Test_Rectifier 
Current working directory:
  /media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/Test/Test_Rectifier.pyjmi
Compiler version: r13863
Java version: 11.0.5-ea
OS name: Linux
OS architecture: amd64
MODELICAPATH    = 
JAVA_HOME       = /usr/lib/jvm/java-11-openjdk-amd64
JMODELICA_HOME  = /home/linuxdev/jmodelica
======= Compiling model =======
Parsing ../../../HPF/package.mo...
Checking for errors...
MODELICAPATH = /home/linuxdev/jmodelica/ThirdParty/MSL
extra_lib_dirs = 
Parsing ../../../HPF/package.mo...
Parsing ../../../HPF/Test/package.mo...
Parsing ../../../HPF/Test/Test_Rectifier.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/package.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Icons.mo...
Parsing ../../../HPF/SystemDef.mo...
Parsing ../../../HPF/SinglePhase/package.mo...
Parsing ../../../HPF/SinglePhase/Sources/package.mo...
Parsing ../../../HPF/SinglePhase/Sources/VoltageSource.mo...
Parsing ../../../HPF/SinglePhase/Interface.mo...
Parsing ../../../HPF/SinglePhase/Components/package.mo...
Parsing ../../../HPF/SinglePhase/Components/Ground.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Electrical/package.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Electrical/Analog/package.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Electrical/Analog/Basic.mo...
Parsing ../../../HPF/PowerElectronicsConverters/package.mo...
Parsing ../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo...
Parsing ../../../HPF/DC/package.mo...
Parsing ../../../HPF/DC/DC_Load.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Electrical/Analog/Interfaces.mo...
Parsing ../../../HPF/SinglePhase/Components/Impedance.mo...
Parsing ../../../HPF/Utilities.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/SIunits.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Complex.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/ComplexMath.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Math/package.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Constants.mo...
Parsing ../../../HPF/Types.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Blocks/package.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Blocks/Interfaces.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Electrical/Analog/Sources.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Utilities/package.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Utilities/Files.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Utilities/Internal.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/ModelicaServices/package.mo...
Parsing /home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Utilities/Streams.mo...
make -f /home/linuxdev/jmodelica/Makefiles/MakeFile ceval_
make[1]: Entering directory '/tmp/jmc17204345991466161181out'
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/linuxdev/jmodelica/include/RuntimeLibrary -I/home/linuxdev/jmodelica/ThirdParty/FMI/2.0  -I/home/linuxdev/jmodelica/ThirdParty/Sundials/include -c -o ModelicaIO_readMatrixSizes.o sources/ModelicaIO_readMatrixSizes.c
mkdir -p binaries
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -o binaries/ModelicaIO_readMatrixSizes  ModelicaIO_readMatrixSizes.o  -L/home/linuxdev/jmodelica/lib/RuntimeLibrary -ljmi_evaluator_util -ljmi -ldl "-L/home/linuxdev/jmodelica/lib" -L"/home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Resources/Library/linux64/gcc921-9ubuntu2" -L"/home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Resources/Library/linux64" -L"/home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Resources/Library" -lModelicaIO -lModelicaMatIO -lzlib -ljmi_get_set_default -lModelicaIO -lModelicaMatIO -lzlib -ljmi_get_set_default -llapack -lblas -lgfortran -lModelicaExternalC -lzlib -ljmi -lstdc++ -lm
/usr/bin/ld: /home/linuxdev/jmodelica/lib/RuntimeLibrary/libModelicaMatIO.a(ModelicaMatIO.c.o): in function `Mat_VarDelete':
/home/linuxdev/tmp/JModelica.org/ThirdParty/MSL/Modelica/Resources/C-Sources/ModelicaMatIO.c:8521: warning: the use of `mktemp' is dangerous, better use `mkstemp' or `mkdtemp'
rm -f  ModelicaIO_readMatrixSizes.o 
make[1]: Leaving directory '/tmp/jmc17204345991466161181out'
Flattening model...
make -f /home/linuxdev/jmodelica/Makefiles/MakeFile ceval_
make[1]: Entering directory '/tmp/jmc17204345991466161181out'
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/linuxdev/jmodelica/include/RuntimeLibrary -I/home/linuxdev/jmodelica/ThirdParty/FMI/2.0  -I/home/linuxdev/jmodelica/ThirdParty/Sundials/include -c -o ModelicaIO_readRealMatrix.o sources/ModelicaIO_readRealMatrix.c
mkdir -p binaries
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -o binaries/ModelicaIO_readRealMatrix  ModelicaIO_readRealMatrix.o  -L/home/linuxdev/jmodelica/lib/RuntimeLibrary -ljmi_evaluator_util -ljmi -ldl "-L/home/linuxdev/jmodelica/lib" -L"/home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Resources/Library/linux64/gcc921-9ubuntu2" -L"/home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Resources/Library/linux64" -L"/home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Resources/Library" -lModelicaIO -lModelicaMatIO -lzlib -ljmi_get_set_default -lModelicaIO -lModelicaMatIO -lzlib -ljmi_get_set_default -llapack -lblas -lgfortran -lModelicaExternalC -lzlib -ljmi -lstdc++ -lm
/usr/bin/ld: /home/linuxdev/jmodelica/lib/RuntimeLibrary/libModelicaMatIO.a(ModelicaMatIO.c.o): in function `Mat_VarDelete':
/home/linuxdev/tmp/JModelica.org/ThirdParty/MSL/Modelica/Resources/C-Sources/ModelicaMatIO.c:8521: warning: the use of `mktemp' is dangerous, better use `mkstemp' or `mkdtemp'
rm -f  ModelicaIO_readRealMatrix.o 
make[1]: Leaving directory '/tmp/jmc17204345991466161181out'
ModelicaMessage: <msg:... loading "arg" from "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat"
>
ModelicaMessage: <msg:... loading "mag" from "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat"
>
ModelicaMessage: <msg:... loading "mag" from "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat"
>
ModelicaMessage: <msg:... loading "arg" from "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat"
>
Raw flattened model:
fclass HPF.Test.Test_Rectifier
 parameter Integer systemDef.hrms[3] = {1, 3, 5} "Harmonics to simulate" /* { 1, 3, 5 } */;
 structural parameter Integer systemDef.numHrm = 3 "Number of harmonics. (Automatically generated from hrms.)" /* 3 */;
 parameter Real systemDef.fFund = 60 "Fundamental frequency (Hz)" /* 60 */;
 parameter Real systemDef.fs = 10000.0 "Sampling frequency (Hz)" /* 10000.0 */;
 parameter Integer systemDef.N = integer(floor(systemDef.fs / systemDef.fFund)) "Size of FFT";
 parameter Integer systemDef.numPh = 3 "Number of phases" /* 3 */;
 discrete HPF.Utilities.ComponentProperties v.properties(ComponentType = "VoltageSource");
 structural parameter Real v.vMag[3] = {120, 0.001, 0.001} "Voltage Magnitude (Volts rms)" /* { 120, 0.001, 0.001 } */;
 structural parameter Real v.vArg[3] = {0, 0, 0} "Voltage angle (rad)" /* { 0, 0, 0 } */;
 Real v.P = v.v[1].re * v.i[1].re + v.v[1].im * v.i[1].im "Real Power";
 Real v.P1 = Modelica.ComplexMath.real(Complex.'*'.multiply(v.v[1], Modelica.ComplexMath.conj(v.i[1])));
 Real v.iMag[3] = Modelica.ComplexMath.'abs'(v.i[1:3]);
 Real v.iArg[3] = Modelica.ComplexMath.arg(v.i[1:3], 0);
 Modelica.SIunits.Angle v.theta(start = 0) = v.pin_p.reference.theta;
 Complex v.v[3](each re(start = 0),each im(start = 0)) "Complex voltage";
 Complex v.i[3](each re(start = 0),each im(start = 0)) "Complex current";
 Real v.omega;
 HPF.Types.Reference v.pin_p.reference(theta(start = 0)) "Reference";
 structural parameter Integer v.pin_p.h = 3 "Numbder of harmonics" /* 3 */;
 Complex v.pin_p.v[3] "Complex potential at the node";
 Real v.pin_p.iIm[3];
 Real v.pin_p.iRe[3];
 HPF.Types.Reference v.pin_n.reference(theta(start = 0)) "Reference";
 structural parameter Integer v.pin_n.h = 3 "Numbder of harmonics" /* 3 */;
 Complex v.pin_n.v[3] "Complex potential at the node";
 Real v.pin_n.iIm[3];
 Real v.pin_n.iRe[3];
 discrete HPF.Utilities.ComponentProperties ground1.properties(ComponentType = "Ground");
 HPF.Types.Reference ground1.pin.reference(theta(start = 0)) "Reference";
 structural parameter Integer ground1.pin.h = 3 "Numbder of harmonics" /* 3 */;
 Complex ground1.pin.v[3] "Complex potential at the node";
 Real ground1.pin.iIm[3];
 Real ground1.pin.iRe[3];
 Modelica.SIunits.ElectricPotential ground2.p.v "Potential at the pin";
 Modelica.SIunits.ElectricCurrent ground2.p.i "Current flowing into the pin";
 discrete HPF.Utilities.ComponentProperties laptop_adapter.properties(ComponentType = "NonlinearLoad");
 Modelica.SIunits.ElectricPotential laptop_adapter.pin_p.v "Potential at the pin";
 Modelica.SIunits.ElectricCurrent laptop_adapter.pin_p.i "Current flowing into the pin";
 Modelica.SIunits.ElectricPotential laptop_adapter.pin_n.v "Potential at the pin";
 Modelica.SIunits.ElectricCurrent laptop_adapter.pin_n.i "Current flowing into the pin";
 HPF.Types.Reference laptop_adapter.hPin_P.reference(theta(start = 0)) "Reference";
 structural parameter Integer laptop_adapter.hPin_P.h = 3 "Numbder of harmonics" /* 3 */;
 Complex laptop_adapter.hPin_P.v[3] "Complex potential at the node";
 Real laptop_adapter.hPin_P.iIm[3];
 Real laptop_adapter.hPin_P.iRe[3];
 HPF.Types.Reference laptop_adapter.hPin_N.reference(theta(start = 0)) "Reference";
 structural parameter Integer laptop_adapter.hPin_N.h = 3 "Numbder of harmonics" /* 3 */;
 Complex laptop_adapter.hPin_N.v[3] "Complex potential at the node";
 Real laptop_adapter.hPin_N.iIm[3];
 Real laptop_adapter.hPin_N.iRe[3];
 Modelica.Blocks.Interfaces.RealOutput laptop_adapter.PLoss;
 parameter Real laptop_adapter.V_Rect(start = 0) = 24 "Rectifier DC output" /* 24 */;
 parameter Real laptop_adapter.efficiency(start = 1) = 0.9 "Rectifier efficiency (replace with efficiency model or curve)" /* 0.9 */;
 parameter Real laptop_adapter.rectifierModel = 0 "Rectifier model (Other model parameters passed as a record?)" /* 0 */;
 parameter Modelica.SIunits.ElectricPotential laptop_adapter.vDC.V(start = 1) = laptop_adapter.V_Rect "Value of constant voltage";
 Modelica.SIunits.ElectricPotential laptop_adapter.vDC.v "Voltage drop between the two pins (= p.v - n.v)";
 Modelica.SIunits.ElectricCurrent laptop_adapter.vDC.i "Current flowing from pin p to pin n";
 Modelica.SIunits.ElectricPotential laptop_adapter.vDC.p.v "Potential at the pin";
 Modelica.SIunits.ElectricCurrent laptop_adapter.vDC.p.i "Current flowing into the pin";
 Modelica.SIunits.ElectricPotential laptop_adapter.vDC.n.v "Potential at the pin";
 Modelica.SIunits.ElectricCurrent laptop_adapter.vDC.n.i "Current flowing into the pin";
 Complex laptop_adapter.loadBase.v[3](each re(start = 0),each im(start = 0)) "Complex voltage";
 Complex laptop_adapter.loadBase.i[3](each re(start = 0),each im(start = 0)) "Complex current";
 Real laptop_adapter.loadBase.omega;
 HPF.Types.Reference laptop_adapter.loadBase.pin_p.reference(theta(start = 0)) "Reference";
 structural parameter Integer laptop_adapter.loadBase.pin_p.h = 3 "Numbder of harmonics" /* 3 */;
 Complex laptop_adapter.loadBase.pin_p.v[3] "Complex potential at the node";
 Real laptop_adapter.loadBase.pin_p.iIm[3];
 Real laptop_adapter.loadBase.pin_p.iRe[3];
 HPF.Types.Reference laptop_adapter.loadBase.pin_n.reference(theta(start = 0)) "Reference";
 structural parameter Integer laptop_adapter.loadBase.pin_n.h = 3 "Numbder of harmonics" /* 3 */;
 Complex laptop_adapter.loadBase.pin_n.v[3] "Complex potential at the node";
 Real laptop_adapter.loadBase.pin_n.iIm[3];
 Real laptop_adapter.loadBase.pin_n.iRe[3];
 Real laptop_adapter.P = abs(laptop_adapter.efficiency * (laptop_adapter.vDC.v * laptop_adapter.vDC.i));
 Real laptop_adapter.I_mag[3] = Modelica.ComplexMath.'abs'(laptop_adapter.loadBase.i[1:3]);
 Real laptop_adapter.I_arg[3] = Modelica.ComplexMath.arg(laptop_adapter.loadBase.i[1:3], 0);
 Real laptop_adapter.V_mag[3] = Modelica.ComplexMath.'abs'(laptop_adapter.loadBase.v[1:3]);
 Real laptop_adapter.V_arg[3] = Modelica.ComplexMath.arg(laptop_adapter.loadBase.v[1:3], 0);
 Real laptop_adapter.S(start = 1) "Apparent power at fundamental";
 Real laptop_adapter.Q(start = 1) "Imaginary power at fundamental";
 structural (loadResource) parameter String laptop_adapter.modelFileName = "HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" "Rectifier harmonic model mat file" /* "HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" */;
 structural parameter String laptop_adapter.resourceRetValue = "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" /* "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" */;
 structural parameter Integer laptop_adapter.matDim[2] = {16, 1} /* { 16, 1 } */;
 structural parameter Real laptop_adapter.magDataMat[16,1] = {{0.9999999999999999}, {0.9486974344201337}, {0.9221155376813399}, {0.8849332521469448}, {0.8475867045468796}, {0.7944241839808487}, {0.7230242274654483}, {0.6688914048386135}, {0.5939253865608557}, {0.5280196623121391}, {0.4568186887780485}, {0.3861474201640431}, {0.3163533253631282}, {0.2534864723066213}, {0.1920046370077911}, {0.1442126307974456}} /* { { 0.9999999999999999 }, { 0.9486974344201337 }, { 0.9221155376813399 }, { 0.8849332521469448 }, { 0.8475867045468796 }, { 0.7944241839808487 }, { 0.7230242274654483 }, { 0.6688914048386135 }, { 0.5939253865608557 }, { 0.5280196623121391 }, { 0.4568186887780485 }, { 0.3861474201640431 }, { 0.3163533253631282 }, { 0.2534864723066213 }, { 0.1920046370077911 }, { 0.1442126307974456 } } */;
 structural parameter Real laptop_adapter.argDataMat[16,1] = {{0.3053419323150846}, {-2.8182357929499515}, {0.5364901833841553}, {-2.381193752481799}, {0.9688071004089418}, {-1.959495555161772}, {1.4013739855750704}, {-1.5329775105321843}, {1.8276649690040103}, {-1.1106883983886444}, {2.2426384598738585}, {-0.6809000975704675}, {2.648460001811645}, {-0.2835615514742411}, {3.0642644296286683}, {0.0716470412434909}} /* { { 0.3053419323150846 }, { -2.8182357929499515 }, { 0.5364901833841553 }, { -2.381193752481799 }, { 0.9688071004089418 }, { -1.959495555161772 }, { 1.4013739855750704 }, { -1.5329775105321843 }, { 1.8276649690040103 }, { -1.1106883983886444 }, { 2.2426384598738585 }, { -0.6809000975704675 }, { 2.648460001811645 }, { -0.2835615514742411 }, { 3.0642644296286683 }, { 0.0716470412434909 } } */;
 Real laptop_adapter.argS "Phase angle for fundamental apparent power";
 Real laptop_adapter.magScale = Modelica.ComplexMath.'abs'(laptop_adapter.loadBase.i[1]);
 Real laptop_adapter.argAdj[2] = {-2.8182357929499515, 0.5364901833841553} - Modelica.ComplexMath.arg(laptop_adapter.loadBase.v[1], 0) .* systemDef.hrms[2:3];
 Complex laptop_adapter.a[2] = {Complex.'constructor'.fromReal(cos(laptop_adapter.argAdj[1]), sin(laptop_adapter.argAdj[1])), Complex.'constructor'.fromReal(cos(laptop_adapter.argAdj[2]), sin(laptop_adapter.argAdj[2]))};
 Real laptop_adapter.c[2] = laptop_adapter.magScale * {0.9486974344201337, 0.9221155376813399};
 discrete HPF.Utilities.ComponentProperties laptop.properties(ComponentType = "DC_Load");
 parameter Real laptop.pwr(start = 1) = 50 "Power (watts)" /* 50 */;
 Modelica.SIunits.ElectricPotential laptop.v "Voltage drop between the two pins (= p.v - n.v)";
 Modelica.SIunits.ElectricCurrent laptop.i "Current flowing from pin p to pin n";
 Modelica.SIunits.ElectricPotential laptop.p.v "Potential at the pin";
 Modelica.SIunits.ElectricCurrent laptop.p.i "Current flowing into the pin";
 Modelica.SIunits.ElectricPotential laptop.n.v "Potential at the pin";
 Modelica.SIunits.ElectricCurrent laptop.n.i "Current flowing into the pin";
 discrete HPF.Utilities.ComponentProperties z.properties(ComponentType = "Impedance");
 parameter Complex z.z(re(start = 1),im(start = 0)) = Complex.'+'(Complex.'constructor'.fromReal(5, 0), Complex.'*'.multiply(Complex.'constructor'.fromReal(2, 0), Complex(0, 1))) "Impedance, R + jX";
 Real z.vFundAbs = Modelica.ComplexMath.'abs'(z.v[1]);
 Real z.vFundArg = Modelica.ComplexMath.arg(z.v[1], 0);
 Real z.iFundAbs = Modelica.ComplexMath.'abs'(z.i[1]);
 Real z.iFundArg = Modelica.ComplexMath.arg(z.i[1], 0);
 Complex z.v[3](each re(start = 0),each im(start = 0)) "Complex voltage";
 Complex z.i[3](each re(start = 0),each im(start = 0)) "Complex current";
 Real z.omega;
 HPF.Types.Reference z.pin_p.reference(theta(start = 0)) "Reference";
 structural parameter Integer z.pin_p.h = 3 "Numbder of harmonics" /* 3 */;
 Complex z.pin_p.v[3] "Complex potential at the node";
 Real z.pin_p.iIm[3];
 Real z.pin_p.iRe[3];
 HPF.Types.Reference z.pin_n.reference(theta(start = 0)) "Reference";
 structural parameter Integer z.pin_n.h = 3 "Numbder of harmonics" /* 3 */;
 Complex z.pin_n.v[3] "Complex potential at the node";
 Real z.pin_n.iIm[3];
 Real z.pin_n.iRe[3];
 discrete HPF.Utilities.ComponentProperties z1.properties(ComponentType = "Impedance");
 parameter Complex z1.z(re(start = 1),im(start = 0)) = Complex.'+'(Complex.'constructor'.fromReal(5, 0), Complex.'*'.multiply(Complex.'constructor'.fromReal(2, 0), Complex(0, 1))) "Impedance, R + jX";
 Real z1.vFundAbs = Modelica.ComplexMath.'abs'(z1.v[1]);
 Real z1.vFundArg = Modelica.ComplexMath.arg(z1.v[1], 0);
 Real z1.iFundAbs = Modelica.ComplexMath.'abs'(z1.i[1]);
 Real z1.iFundArg = Modelica.ComplexMath.arg(z1.i[1], 0);
 Complex z1.v[3](each re(start = 0),each im(start = 0)) "Complex voltage";
 Complex z1.i[3](each re(start = 0),each im(start = 0)) "Complex current";
 Real z1.omega;
 HPF.Types.Reference z1.pin_p.reference(theta(start = 0)) "Reference";
 structural parameter Integer z1.pin_p.h = 3 "Numbder of harmonics" /* 3 */;
 Complex z1.pin_p.v[3] "Complex potential at the node";
 Real z1.pin_p.iIm[3];
 Real z1.pin_p.iRe[3];
 HPF.Types.Reference z1.pin_n.reference(theta(start = 0)) "Reference";
 structural parameter Integer z1.pin_n.h = 3 "Numbder of harmonics" /* 3 */;
 Complex z1.pin_n.v[3] "Complex potential at the node";
 Real z1.pin_n.iIm[3];
 Real z1.pin_n.iRe[3];
initial equation
 algorithm
;
parameter equation
 assert({16, 1} == Modelica.Utilities.Streams.readMatrixSize("/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat", "mag"), "Error Error at line 50, column 39, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readMatrixSize' did not evaluate to same result as during compilation");
 assert({{0.9999999999999999}, {0.9486974344201337}, {0.9221155376813399}, {0.8849332521469448}, {0.8475867045468796}, {0.7944241839808487}, {0.7230242274654483}, {0.6688914048386135}, {0.5939253865608557}, {0.5280196623121391}, {0.4568186887780485}, {0.3861474201640431}, {0.3163533253631282}, {0.2534864723066213}, {0.1920046370077911}, {0.1442126307974456}} == Modelica.Utilities.Streams.readRealMatrix("/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat", "mag", 16, 1, true), "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert({{0.3053419323150846}, {-2.8182357929499515}, {0.5364901833841553}, {-2.381193752481799}, {0.9688071004089418}, {-1.959495555161772}, {1.4013739855750704}, {-1.5329775105321843}, {1.8276649690040103}, {-1.1106883983886444}, {2.2426384598738585}, {-0.6809000975704675}, {2.648460001811645}, {-0.2835615514742411}, {3.0642644296286683}, {0.0716470412434909}} == Modelica.Utilities.Streams.readRealMatrix("/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat", "arg", 16, 1, true), "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
algorithm
equation
 v.omega = 2 * 3.141592653589793 * systemDef.fFund;
 v.v[1:3].re = {120.0, 0.001, 0.001} .* cos({0.0, 0.0, 0.0});
 v.v[1:3].im = {120.0, 0.001, 0.001} .* sin({0.0, 0.0, 0.0});
 v.pin_p.reference.theta = v.pin_n.reference.theta;
 v.omega = der(v.pin_p.reference.theta);
 v.v[1:3] = {Complex.'-'.subtract(v.pin_p.v[1], v.pin_n.v[1]), Complex.'-'.subtract(v.pin_p.v[2], v.pin_n.v[2]), Complex.'-'.subtract(v.pin_p.v[3], v.pin_n.v[3])};
 v.i[1:3].re = v.pin_p.iRe[1:3];
 v.i[1:3].im = v.pin_p.iIm[1:3];
 v.pin_p.iRe[1:3] + v.pin_n.iRe[1:3] = {0.0, 0.0, 0.0};
 v.pin_p.iIm[1:3] + v.pin_n.iIm[1:3] = {0.0, 0.0, 0.0};
 if Connections.isRoot(ground1.pin.reference) then
  ground1.pin.reference.theta = 0;
 end if;
 ground1.pin.v[1:3] = {Complex.'constructor'.fromReal(0.0, 0), Complex.'constructor'.fromReal(0.0, 0), Complex.'constructor'.fromReal(0.0, 0)};
 ground2.p.v = 0;
 laptop_adapter.argS = -0.3053419323150846;
 laptop_adapter.P = laptop_adapter.S * cos(laptop_adapter.argS);
 laptop_adapter.Q = laptop_adapter.S * sin(laptop_adapter.argS);
 Complex.'constructor'.fromReal(laptop_adapter.P, laptop_adapter.Q) = Complex.'*'.multiply(laptop_adapter.loadBase.v[1], Modelica.ComplexMath.conj(laptop_adapter.loadBase.i[1]));
 laptop_adapter.loadBase.i[2:1:3] = {Complex.'*'.multiply(Complex.'constructor'.fromReal(laptop_adapter.c[1], 0), laptop_adapter.a[1]), Complex.'*'.multiply(Complex.'constructor'.fromReal(laptop_adapter.c[2], 0), laptop_adapter.a[2])};
 laptop_adapter.PLoss = laptop_adapter.P * (1 - laptop_adapter.efficiency) / laptop_adapter.efficiency;
algorithm
equation
 laptop_adapter.vDC.v = laptop_adapter.vDC.V;
 laptop_adapter.vDC.v = laptop_adapter.vDC.p.v - laptop_adapter.vDC.n.v;
 0 = laptop_adapter.vDC.p.i + laptop_adapter.vDC.n.i;
 laptop_adapter.vDC.i = laptop_adapter.vDC.p.i;
 laptop_adapter.loadBase.pin_p.reference.theta = laptop_adapter.loadBase.pin_n.reference.theta;
 laptop_adapter.loadBase.omega = der(laptop_adapter.loadBase.pin_p.reference.theta);
 laptop_adapter.loadBase.v[1:3] = {Complex.'-'.subtract(laptop_adapter.loadBase.pin_p.v[1], laptop_adapter.loadBase.pin_n.v[1]), Complex.'-'.subtract(laptop_adapter.loadBase.pin_p.v[2], laptop_adapter.loadBase.pin_n.v[2]), Complex.'-'.subtract(laptop_adapter.loadBase.pin_p.v[3], laptop_adapter.loadBase.pin_n.v[3])};
 laptop_adapter.loadBase.i[1:3].re = laptop_adapter.loadBase.pin_p.iRe[1:3];
 laptop_adapter.loadBase.i[1:3].im = laptop_adapter.loadBase.pin_p.iIm[1:3];
 laptop_adapter.loadBase.pin_p.iRe[1:3] + laptop_adapter.loadBase.pin_n.iRe[1:3] = {0.0, 0.0, 0.0};
 laptop_adapter.loadBase.pin_p.iIm[1:3] + laptop_adapter.loadBase.pin_n.iIm[1:3] = {0.0, 0.0, 0.0};
 laptop.i = laptop.pwr / laptop.v;
 laptop.v = laptop.p.v - laptop.n.v;
 0 = laptop.p.i + laptop.n.i;
 laptop.i = laptop.p.i;
 z.v[1:3].re = z.z.re .* z.i[1:3].re - z.z.im .* systemDef.hrms[1:3] .* z.i[1:3].im;
 z.v[1:3].im = z.z.re .* z.i[1:3].im + z.z.im .* systemDef.hrms[1:3] .* z.i[1:3].re;
 z.pin_p.reference.theta = z.pin_n.reference.theta;
 z.omega = der(z.pin_p.reference.theta);
 z.v[1:3] = {Complex.'-'.subtract(z.pin_p.v[1], z.pin_n.v[1]), Complex.'-'.subtract(z.pin_p.v[2], z.pin_n.v[2]), Complex.'-'.subtract(z.pin_p.v[3], z.pin_n.v[3])};
 z.i[1:3].re = z.pin_p.iRe[1:3];
 z.i[1:3].im = z.pin_p.iIm[1:3];
 z.pin_p.iRe[1:3] + z.pin_n.iRe[1:3] = {0.0, 0.0, 0.0};
 z.pin_p.iIm[1:3] + z.pin_n.iIm[1:3] = {0.0, 0.0, 0.0};
 z1.v[1:3].re = z1.z.re .* z1.i[1:3].re - z1.z.im .* systemDef.hrms[1:3] .* z1.i[1:3].im;
 z1.v[1:3].im = z1.z.re .* z1.i[1:3].im + z1.z.im .* systemDef.hrms[1:3] .* z1.i[1:3].re;
 z1.pin_p.reference.theta = z1.pin_n.reference.theta;
 z1.omega = der(z1.pin_p.reference.theta);
 z1.v[1:3] = {Complex.'-'.subtract(z1.pin_p.v[1], z1.pin_n.v[1]), Complex.'-'.subtract(z1.pin_p.v[2], z1.pin_n.v[2]), Complex.'-'.subtract(z1.pin_p.v[3], z1.pin_n.v[3])};
 z1.i[1:3].re = z1.pin_p.iRe[1:3];
 z1.i[1:3].im = z1.pin_p.iIm[1:3];
 z1.pin_p.iRe[1:3] + z1.pin_n.iRe[1:3] = {0.0, 0.0, 0.0};
 z1.pin_p.iIm[1:3] + z1.pin_n.iIm[1:3] = {0.0, 0.0, 0.0};
 ground1.pin.iIm[1:3] + laptop_adapter.hPin_N.iIm[1:3] + v.pin_n.iIm[1:3] + z1.pin_n.iIm[1:3] = zeros(3);
 ground1.pin.iRe[1:3] + laptop_adapter.hPin_N.iRe[1:3] + v.pin_n.iRe[1:3] + z1.pin_n.iRe[1:3] = zeros(3);
 ground1.pin.v[1].im = laptop_adapter.hPin_N.v[1].im;
 laptop_adapter.hPin_N.v[1].im = v.pin_n.v[1].im;
 v.pin_n.v[1].im = z1.pin_n.v[1].im;
 ground1.pin.v[1].re = laptop_adapter.hPin_N.v[1].re;
 laptop_adapter.hPin_N.v[1].re = v.pin_n.v[1].re;
 v.pin_n.v[1].re = z1.pin_n.v[1].re;
 ground1.pin.v[2].im = laptop_adapter.hPin_N.v[2].im;
 laptop_adapter.hPin_N.v[2].im = v.pin_n.v[2].im;
 v.pin_n.v[2].im = z1.pin_n.v[2].im;
 ground1.pin.v[2].re = laptop_adapter.hPin_N.v[2].re;
 laptop_adapter.hPin_N.v[2].re = v.pin_n.v[2].re;
 v.pin_n.v[2].re = z1.pin_n.v[2].re;
 ground1.pin.v[3].im = laptop_adapter.hPin_N.v[3].im;
 laptop_adapter.hPin_N.v[3].im = v.pin_n.v[3].im;
 v.pin_n.v[3].im = z1.pin_n.v[3].im;
 ground1.pin.v[3].re = laptop_adapter.hPin_N.v[3].re;
 laptop_adapter.hPin_N.v[3].re = v.pin_n.v[3].re;
 v.pin_n.v[3].re = z1.pin_n.v[3].re;
 ground2.p.i + laptop.n.i + laptop_adapter.pin_n.i = 0.0;
 ground2.p.v = laptop.n.v;
 laptop.n.v = laptop_adapter.pin_n.v;
 laptop.p.i + laptop_adapter.pin_p.i = 0.0;
 laptop.p.v = laptop_adapter.pin_p.v;
 laptop_adapter.hPin_P.iIm[1:3] + z.pin_n.iIm[1:3] + z1.pin_p.iIm[1:3] = zeros(3);
 laptop_adapter.hPin_P.iRe[1:3] + z.pin_n.iRe[1:3] + z1.pin_p.iRe[1:3] = zeros(3);
 laptop_adapter.hPin_P.v[1].im = z.pin_n.v[1].im;
 z.pin_n.v[1].im = z1.pin_p.v[1].im;
 laptop_adapter.hPin_P.v[1].re = z.pin_n.v[1].re;
 z.pin_n.v[1].re = z1.pin_p.v[1].re;
 laptop_adapter.hPin_P.v[2].im = z.pin_n.v[2].im;
 z.pin_n.v[2].im = z1.pin_p.v[2].im;
 laptop_adapter.hPin_P.v[2].re = z.pin_n.v[2].re;
 z.pin_n.v[2].re = z1.pin_p.v[2].re;
 laptop_adapter.hPin_P.v[3].im = z.pin_n.v[3].im;
 z.pin_n.v[3].im = z1.pin_p.v[3].im;
 laptop_adapter.hPin_P.v[3].re = z.pin_n.v[3].re;
 z.pin_n.v[3].re = z1.pin_p.v[3].re;
 v.pin_p.iIm[1:3] + z.pin_p.iIm[1:3] = zeros(3);
 v.pin_p.iRe[1:3] + z.pin_p.iRe[1:3] = zeros(3);
 v.pin_p.v[1].im = z.pin_p.v[1].im;
 v.pin_p.v[1].re = z.pin_p.v[1].re;
 v.pin_p.v[2].im = z.pin_p.v[2].im;
 v.pin_p.v[2].re = z.pin_p.v[2].re;
 v.pin_p.v[3].im = z.pin_p.v[3].im;
 v.pin_p.v[3].re = z.pin_p.v[3].re;
 - laptop_adapter.pin_p.i + laptop_adapter.vDC.p.i = 0.0;
 laptop_adapter.pin_p.v = laptop_adapter.vDC.p.v;
 - laptop_adapter.pin_n.i + laptop_adapter.vDC.n.i = 0.0;
 laptop_adapter.pin_n.v = laptop_adapter.vDC.n.v;
 - laptop_adapter.hPin_P.iIm[1:3] + laptop_adapter.loadBase.pin_p.iIm[1:3] = zeros(3);
 - laptop_adapter.hPin_P.iRe[1:3] + laptop_adapter.loadBase.pin_p.iRe[1:3] = zeros(3);
 laptop_adapter.hPin_P.v[1].im = laptop_adapter.loadBase.pin_p.v[1].im;
 laptop_adapter.hPin_P.v[1].re = laptop_adapter.loadBase.pin_p.v[1].re;
 laptop_adapter.hPin_P.v[2].im = laptop_adapter.loadBase.pin_p.v[2].im;
 laptop_adapter.hPin_P.v[2].re = laptop_adapter.loadBase.pin_p.v[2].re;
 laptop_adapter.hPin_P.v[3].im = laptop_adapter.loadBase.pin_p.v[3].im;
 laptop_adapter.hPin_P.v[3].re = laptop_adapter.loadBase.pin_p.v[3].re;
 - laptop_adapter.hPin_N.iIm[1:3] + laptop_adapter.loadBase.pin_n.iIm[1:3] = zeros(3);
 - laptop_adapter.hPin_N.iRe[1:3] + laptop_adapter.loadBase.pin_n.iRe[1:3] = zeros(3);
 laptop_adapter.hPin_N.v[1].im = laptop_adapter.loadBase.pin_n.v[1].im;
 laptop_adapter.hPin_N.v[1].re = laptop_adapter.loadBase.pin_n.v[1].re;
 laptop_adapter.hPin_N.v[2].im = laptop_adapter.loadBase.pin_n.v[2].im;
 laptop_adapter.hPin_N.v[2].re = laptop_adapter.loadBase.pin_n.v[2].re;
 laptop_adapter.hPin_N.v[3].im = laptop_adapter.loadBase.pin_n.v[3].im;
 laptop_adapter.hPin_N.v[3].re = laptop_adapter.loadBase.pin_n.v[3].re;
 v.pin_p.reference.theta = z.pin_p.reference.theta;
 laptop_adapter.hPin_P.reference.theta = z.pin_n.reference.theta;
 z.pin_n.reference.theta = z1.pin_p.reference.theta;
 ground1.pin.reference.theta = laptop_adapter.hPin_N.reference.theta;
 laptop_adapter.hPin_N.reference.theta = v.pin_n.reference.theta;
 laptop_adapter.hPin_P.reference.theta = laptop_adapter.loadBase.pin_p.reference.theta;
 HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(z1.pin_n.reference, ground1.pin.reference);
 HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(laptop_adapter.loadBase.pin_n.reference, laptop_adapter.hPin_N.reference);

public
 function Modelica.ComplexMath.real
  input Complex c;
  output Real r;
 algorithm
  r := c.re;
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.real;

 function Modelica.ComplexMath.conj
  input Complex c1;
  output Complex c2;
 algorithm
  (c2) := Complex.'constructor'.fromReal(c1.re, - c1.im);
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.conj;

 function Complex.'constructor'.fromReal
  input Real re;
  input Real im;
  output Complex result;
 algorithm
  result.re := re;
  result.im := im;
  return;
 annotation(Inline = true);
 end Complex.'constructor'.fromReal;

 function Complex.'*'.multiply
  input Complex c1;
  input Complex c2;
  output Complex c3;
 algorithm
  (c3) := Complex.'constructor'.fromReal(c1.re * c2.re - c1.im * c2.im, c1.re * c2.im + c1.im * c2.re);
  return;
 annotation(Inline = true);
 end Complex.'*'.multiply;

 function Modelica.ComplexMath.'abs'
  input Complex c;
  output Real result;
 algorithm
  result := (c.re ^ 2 + c.im ^ 2) ^ 0.5;
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.'abs';

 function Modelica.ComplexMath.arg
  input Complex c;
  input Real phi0;
  output Real phi;
 algorithm
  phi := Modelica.Math.atan3(c.im, c.re, phi0);
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.arg;

 function Modelica.Math.atan3
  input Real u1;
  input Real u2;
  input Real y0;
  output Real y;
  Real w;
 algorithm
  w := atan2(u1, u2);
  if y0 == 0 then
   y := w;
  else
   y := w + 6.283185307179586 * integer((3.141592653589793 + y0 - w) / 6.283185307179586);
  end if;
  return;
 end Modelica.Math.atan3;

 function Modelica.Utilities.Streams.readMatrixSize
  input String fileName;
  input String matrixName;
  output Integer[:] dim;
 algorithm
  init dim as Integer[2];
  external "C" ModelicaIO_readMatrixSizes(fileName, matrixName, dim);
  return;
 end Modelica.Utilities.Streams.readMatrixSize;

 function Modelica.Utilities.Streams.readRealMatrix
  input String fileName;
  input String matrixName;
  input Integer nrow;
  input Integer ncol;
  input Boolean verboseRead;
  output Real[:,:] matrix;
 algorithm
  init matrix as Real[nrow, ncol];
  external "C" ModelicaIO_readRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), verboseRead);
  return;
 end Modelica.Utilities.Streams.readRealMatrix;

 function Complex.'-'.subtract
  input Complex c1;
  input Complex c2;
  output Complex c3;
 algorithm
  (c3) := Complex.'constructor'.fromReal(c1.re - c2.re, c1.im - c2.im);
  return;
 annotation(Inline = true);
 end Complex.'-'.subtract;

 function Complex.'+'
  input Complex c1;
  input Complex c2;
  output Complex c3;
 algorithm
  (c3) := Complex.'constructor'.fromReal(c1.re + c2.re, c1.im + c2.im);
  return;
 annotation(Inline = true);
 end Complex.'+';

 function HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint;

 function HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint;

 record HPF.Utilities.ComponentProperties
  discrete String ComponentType "Type of the component";
 end HPF.Utilities.ComponentProperties;

 record Complex
  Real re "Real part of complex number";
  Real im "Imaginary part of complex number";
 end Complex;

 record HPF.Types.Reference
  Modelica.SIunits.Angle theta;
 end HPF.Types.Reference;

 type Modelica.SIunits.Angle = Real(final quantity = "Angle",final unit = "rad",displayUnit = "deg");
 type Modelica.SIunits.ElectricPotential = Real(final quantity = "ElectricPotential",final unit = "V");
 type Modelica.SIunits.ElectricCurrent = Real(final quantity = "ElectricCurrent",final unit = "A");
 type Modelica.Blocks.Interfaces.RealOutput = Real;
end HPF.Test.Test_Rectifier;

Applying transformation: enableIfEquationElimination...
Applying transformation: genInitArrayStatements...
Applying transformation: scalarize...
Applying transformation: MakeReinitedVarsStates...
Applying transformation: enableIfEquationElimination...
Applying transformation: enableStreamsRewrite...
Applying transformation: ExtractEventGeneratingExpressions...
Applying transformation: GenerateEventIndicators...
Applying transformation: convertWhenToIf...
Applying transformation: FunctionInliningIfSet...
Applying transformation: setFDerivativeVariables...
Applying transformation: addFPreVariables...
Applying transformation: enableIfEquationRewrite...
Applying transformation: aliasEliminationIfSet...
Applying transformation: variabilityPropagationIfSet...
Applying transformation: aliasEliminationIfSet...
Applying transformation: eliminateLinearEquations...
Applying transformation: aliasEliminationIfSet...
Applying transformation: enableExpandedInStreamRewrite...
Applying transformation: evaluateAsserts...
Applying transformation: enableSemiLinearRewrite...
Applying transformation: eliminateEqualSwitches...
Applying transformation: genInitialEquations...
Applying transformation: setFDerivativeVariablesPreBLT...
Applying transformation: indexReduction...
Applying transformation: LateFunctionInliningIfSet...
Applying transformation: commonSubexpressionEliminationIfSet...
Applying transformation: addFPreVariables...
Applying transformation: aliasEliminationIfSet...
Applying transformation: eliminateLinearEquations...
Applying transformation: sortDependentParameters...
Applying transformation: addRuntimeOptionParameters...
Applying transformation: computeMatchingsAndBLT...
Flat tree before matching and BLT:
fclass HPF.Test.Test_Rectifier
 parameter Integer systemDef.hrms[1] = 1 "Harmonics to simulate" /* 1 */;
 parameter Integer systemDef.hrms[2] = 3 "Harmonics to simulate" /* 3 */;
 parameter Integer systemDef.hrms[3] = 5 "Harmonics to simulate" /* 5 */;
 structural parameter Integer systemDef.numHrm = 3 "Number of harmonics. (Automatically generated from hrms.)" /* 3 */;
 parameter Real systemDef.fFund = 60 "Fundamental frequency (Hz)" /* 60 */;
 parameter Real systemDef.fs = 10000.0 "Sampling frequency (Hz)" /* 10000.0 */;
 parameter Integer temp_20[1];
 parameter Integer systemDef.numPh = 3 "Number of phases" /* 3 */;
 constant String v.properties.ComponentType = "VoltageSource" "Type of the component";
 structural parameter Real v.vMag[1] = 120 "Voltage Magnitude (Volts rms)" /* 120 */;
 structural parameter Real v.vArg[1] = 0 "Voltage angle (rad)" /* 0 */;
 Real v.P1;
 Real v.iMag[1];
 Real v.iMag[2];
 Real v.iMag[3];
 Real v.iArg[1];
 Real v.iArg[2];
 Real v.iArg[3];
 Modelica.SIunits.Angle v.theta(start = 0);
 constant Real v.v[1].re(start = 0) = 120.0 "Real part of complex number";
 constant Real v.v[1].im(start = 0) = 0.0 "Imaginary part of complex number";
 constant Real v.v[2].re(start = 0) = 0.001 "Real part of complex number";
 Real v.i[1].re(start = 0) "Real part of complex number";
 Real v.i[1].im(start = 0) "Imaginary part of complex number";
 Real v.i[2].re(start = 0) "Real part of complex number";
 Real v.i[2].im(start = 0) "Imaginary part of complex number";
 Real v.i[3].re(start = 0) "Real part of complex number";
 Real v.i[3].im(start = 0) "Imaginary part of complex number";
 Real v.omega;
 constant String ground1.properties.ComponentType = "Ground" "Type of the component";
 Real ground1.pin.iIm[1];
 Real ground1.pin.iIm[2];
 Real ground1.pin.iIm[3];
 Real ground1.pin.iRe[1];
 Real ground1.pin.iRe[2];
 Real ground1.pin.iRe[3];
 parameter Integer temp_20[2];
 constant String laptop_adapter.properties.ComponentType = "NonlinearLoad" "Type of the component";
 parameter Real temp_21[1,1];
 parameter Real laptop_adapter.V_Rect(start = 0) = 24 "Rectifier DC output" /* 24 */;
 parameter Real laptop_adapter.efficiency(start = 1) = 0.9 "Rectifier efficiency (replace with efficiency model or curve)" /* 0.9 */;
 parameter Real laptop_adapter.rectifierModel = 0 "Rectifier model (Other model parameters passed as a record?)" /* 0 */;
 parameter Real temp_21[2,1];
 Real laptop_adapter.loadBase.i[1].re(start = 0) "Real part of complex number";
 Real laptop_adapter.loadBase.i[1].im(start = 0) "Imaginary part of complex number";
 Real laptop_adapter.loadBase.i[2].re(start = 0) "Real part of complex number";
 Real laptop_adapter.loadBase.i[2].im(start = 0) "Imaginary part of complex number";
 Real laptop_adapter.loadBase.i[3].re(start = 0) "Real part of complex number";
 Real laptop_adapter.loadBase.i[3].im(start = 0) "Imaginary part of complex number";
 Real laptop_adapter.loadBase.omega;
 parameter Real temp_21[3,1];
 Real laptop_adapter.I_mag[1];
 Real laptop_adapter.I_mag[2];
 Real laptop_adapter.I_mag[3];
 Real laptop_adapter.I_arg[1];
 Real laptop_adapter.I_arg[2];
 Real laptop_adapter.I_arg[3];
 Real laptop_adapter.V_mag[1];
 Real laptop_adapter.V_mag[2];
 Real laptop_adapter.V_mag[3];
 Real laptop_adapter.V_arg[1];
 Real laptop_adapter.V_arg[2];
 Real laptop_adapter.V_arg[3];
 parameter Real temp_21[4,1];
 parameter Real temp_21[5,1];
 structural (loadResource) parameter String laptop_adapter.modelFileName = "HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" "Rectifier harmonic model mat file" /* "HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" */;
 structural parameter String laptop_adapter.resourceRetValue = "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" /* "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" */;
 structural parameter Integer laptop_adapter.matDim[1] = 16 /* 16 */;
 structural parameter Integer laptop_adapter.matDim[2] = 1 /* 1 */;
 structural parameter Real laptop_adapter.magDataMat[1,1] = 0.9999999999999999 /* 0.9999999999999999 */;
 structural parameter Real laptop_adapter.magDataMat[2,1] = 0.9486974344201337 /* 0.9486974344201337 */;
 structural parameter Real laptop_adapter.magDataMat[3,1] = 0.9221155376813399 /* 0.9221155376813399 */;
 structural parameter Real laptop_adapter.magDataMat[4,1] = 0.8849332521469448 /* 0.8849332521469448 */;
 structural parameter Real laptop_adapter.magDataMat[5,1] = 0.8475867045468796 /* 0.8475867045468796 */;
 structural parameter Real laptop_adapter.magDataMat[6,1] = 0.7944241839808487 /* 0.7944241839808487 */;
 structural parameter Real laptop_adapter.magDataMat[7,1] = 0.7230242274654483 /* 0.7230242274654483 */;
 structural parameter Real laptop_adapter.magDataMat[8,1] = 0.6688914048386135 /* 0.6688914048386135 */;
 structural parameter Real laptop_adapter.magDataMat[9,1] = 0.5939253865608557 /* 0.5939253865608557 */;
 structural parameter Real laptop_adapter.magDataMat[10,1] = 0.5280196623121391 /* 0.5280196623121391 */;
 structural parameter Real laptop_adapter.magDataMat[11,1] = 0.4568186887780485 /* 0.4568186887780485 */;
 structural parameter Real laptop_adapter.magDataMat[12,1] = 0.3861474201640431 /* 0.3861474201640431 */;
 structural parameter Real laptop_adapter.magDataMat[13,1] = 0.3163533253631282 /* 0.3163533253631282 */;
 structural parameter Real laptop_adapter.magDataMat[14,1] = 0.2534864723066213 /* 0.2534864723066213 */;
 structural parameter Real laptop_adapter.magDataMat[15,1] = 0.1920046370077911 /* 0.1920046370077911 */;
 structural parameter Real laptop_adapter.magDataMat[16,1] = 0.1442126307974456 /* 0.1442126307974456 */;
 structural parameter Real laptop_adapter.argDataMat[1,1] = 0.3053419323150846 /* 0.3053419323150846 */;
 structural parameter Real laptop_adapter.argDataMat[2,1] = -2.8182357929499515 /* -2.8182357929499515 */;
 structural parameter Real laptop_adapter.argDataMat[3,1] = 0.5364901833841553 /* 0.5364901833841553 */;
 structural parameter Real laptop_adapter.argDataMat[4,1] = -2.381193752481799 /* -2.381193752481799 */;
 structural parameter Real laptop_adapter.argDataMat[5,1] = 0.9688071004089418 /* 0.9688071004089418 */;
 structural parameter Real laptop_adapter.argDataMat[6,1] = -1.959495555161772 /* -1.959495555161772 */;
 structural parameter Real laptop_adapter.argDataMat[7,1] = 1.4013739855750704 /* 1.4013739855750704 */;
 structural parameter Real laptop_adapter.argDataMat[8,1] = -1.5329775105321843 /* -1.5329775105321843 */;
 structural parameter Real laptop_adapter.argDataMat[9,1] = 1.8276649690040103 /* 1.8276649690040103 */;
 structural parameter Real laptop_adapter.argDataMat[10,1] = -1.1106883983886444 /* -1.1106883983886444 */;
 structural parameter Real laptop_adapter.argDataMat[11,1] = 2.2426384598738585 /* 2.2426384598738585 */;
 structural parameter Real laptop_adapter.argDataMat[12,1] = -0.6809000975704675 /* -0.6809000975704675 */;
 structural parameter Real laptop_adapter.argDataMat[13,1] = 2.648460001811645 /* 2.648460001811645 */;
 structural parameter Real laptop_adapter.argDataMat[14,1] = -0.2835615514742411 /* -0.2835615514742411 */;
 structural parameter Real laptop_adapter.argDataMat[15,1] = 3.0642644296286683 /* 3.0642644296286683 */;
 structural parameter Real laptop_adapter.argDataMat[16,1] = 0.0716470412434909 /* 0.0716470412434909 */;
 constant Real laptop_adapter.argS = -0.3053419323150846 "Phase angle for fundamental apparent power";
 Real laptop_adapter.magScale;
 Real laptop_adapter.argAdj[1];
 Real laptop_adapter.argAdj[2];
 Real laptop_adapter.a[1].re "Real part of complex number";
 Real laptop_adapter.a[1].im "Imaginary part of complex number";
 Real laptop_adapter.a[2].re "Real part of complex number";
 Real laptop_adapter.a[2].im "Imaginary part of complex number";
 Real laptop_adapter.c[1];
 Real laptop_adapter.c[2];
 constant String laptop.properties.ComponentType = "DC_Load" "Type of the component";
 parameter Real laptop.pwr(start = 1) = 50 "Power (watts)" /* 50 */;
 parameter Real temp_21[6,1];
 constant String z.properties.ComponentType = "Impedance" "Type of the component";
 parameter Real z.z.re(start = 1) = 5.0 "Real part of complex number" /* 5.0 */;
 parameter Real z.z.im(start = 0) = 2.0 "Imaginary part of complex number" /* 2.0 */;
 Real z.vFundAbs;
 Real z.vFundArg;
 Real z.iFundAbs;
 Real z.iFundArg;
 Real z.v[1].re(start = 0) "Real part of complex number";
 Real z.v[1].im(start = 0) "Imaginary part of complex number";
 Real z.v[2].re(start = 0) "Real part of complex number";
 Real z.v[2].im(start = 0) "Imaginary part of complex number";
 Real z.v[3].re(start = 0) "Real part of complex number";
 Real z.v[3].im(start = 0) "Imaginary part of complex number";
 Real z.omega;
 parameter Real z1.z.re(start = 1) = 5.0 "Real part of complex number" /* 5.0 */;
 parameter Real z1.z.im(start = 0) = 2.0 "Imaginary part of complex number" /* 2.0 */;
 Real z1.vFundAbs;
 Real z1.iFundAbs;
 Real z1.iFundArg;
 Real z1.v[1].re(start = 0) "Real part of complex number";
 Real z1.v[2].re(start = 0) "Real part of complex number";
 Real z1.v[3].re(start = 0) "Real part of complex number";
 Real z1.i[1].re(start = 0) "Real part of complex number";
 Real z1.i[1].im(start = 0) "Imaginary part of complex number";
 Real z1.i[2].re(start = 0) "Real part of complex number";
 Real z1.i[2].im(start = 0) "Imaginary part of complex number";
 Real z1.i[3].re(start = 0) "Real part of complex number";
 Real z1.i[3].im(start = 0) "Imaginary part of complex number";
 Real z1.omega;
 parameter Real temp_21[7,1];
 parameter Real temp_21[8,1];
 parameter Real temp_21[9,1];
 parameter Real temp_21[10,1];
 parameter Real temp_21[11,1];
 parameter Real temp_21[12,1];
 parameter Real temp_21[13,1];
 parameter Real temp_21[14,1];
 parameter Real temp_21[15,1];
 parameter Real temp_21[16,1];
 parameter Real temp_22[1,1];
 parameter Real temp_22[2,1];
 parameter Real temp_22[3,1];
 parameter Real temp_22[4,1];
 parameter Real temp_22[5,1];
 parameter Real temp_22[6,1];
 parameter Real temp_22[7,1];
 parameter Real temp_22[8,1];
 parameter Real temp_22[9,1];
 parameter Real temp_22[10,1];
 parameter Real temp_22[11,1];
 parameter Real temp_22[12,1];
 parameter Real temp_22[13,1];
 parameter Real temp_22[14,1];
 parameter Real temp_22[15,1];
 parameter Real temp_22[16,1];
 parameter Integer systemDef.N "Size of FFT";
 parameter Modelica.SIunits.ElectricPotential laptop_adapter.vDC.V(start = 1) "Value of constant voltage";
 parameter Modelica.SIunits.ElectricCurrent laptop.i "Current flowing from pin p to pin n";
 parameter Modelica.SIunits.ElectricCurrent ground2.p.i "Current flowing into the pin";
 parameter Real laptop_adapter.P;
 parameter Real laptop_adapter.S(start = 1) "Apparent power at fundamental";
 parameter Modelica.Blocks.Interfaces.RealOutput laptop_adapter.PLoss;
 parameter Real laptop_adapter.Q(start = 1) "Imaginary power at fundamental";
initial equation
 algorithm
;
parameter equation
 ({temp_20[1], temp_20[2]}) = Modelica.Utilities.Streams.readMatrixSize("/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat", "mag");
 ({{temp_21[1,1]}, {temp_21[2,1]}, {temp_21[3,1]}, {temp_21[4,1]}, {temp_21[5,1]}, {temp_21[6,1]}, {temp_21[7,1]}, {temp_21[8,1]}, {temp_21[9,1]}, {temp_21[10,1]}, {temp_21[11,1]}, {temp_21[12,1]}, {temp_21[13,1]}, {temp_21[14,1]}, {temp_21[15,1]}, {temp_21[16,1]}}) = Modelica.Utilities.Streams.readRealMatrix("/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat", "mag", 16, 1, true);
 ({{temp_22[1,1]}, {temp_22[2,1]}, {temp_22[3,1]}, {temp_22[4,1]}, {temp_22[5,1]}, {temp_22[6,1]}, {temp_22[7,1]}, {temp_22[8,1]}, {temp_22[9,1]}, {temp_22[10,1]}, {temp_22[11,1]}, {temp_22[12,1]}, {temp_22[13,1]}, {temp_22[14,1]}, {temp_22[15,1]}, {temp_22[16,1]}}) = Modelica.Utilities.Streams.readRealMatrix("/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat", "arg", 16, 1, true);
 systemDef.N = integer(floor(systemDef.fs / systemDef.fFund));
 laptop_adapter.vDC.V = laptop_adapter.V_Rect;
 assert(16 == temp_20[1], "Error Error at line 50, column 39, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readMatrixSize' did not evaluate to same result as during compilation");
 assert(1 == temp_20[2], "Error Error at line 50, column 39, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readMatrixSize' did not evaluate to same result as during compilation");
 assert(0.9999999999999999 == temp_21[1,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.9486974344201337 == temp_21[2,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.9221155376813399 == temp_21[3,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.8849332521469448 == temp_21[4,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.8475867045468796 == temp_21[5,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.7944241839808487 == temp_21[6,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.7230242274654483 == temp_21[7,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.6688914048386135 == temp_21[8,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.5939253865608557 == temp_21[9,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.5280196623121391 == temp_21[10,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.4568186887780485 == temp_21[11,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.3861474201640431 == temp_21[12,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.3163533253631282 == temp_21[13,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.2534864723066213 == temp_21[14,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.1920046370077911 == temp_21[15,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.1442126307974456 == temp_21[16,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.3053419323150846 == temp_22[1,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-2.8182357929499515 == temp_22[2,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.5364901833841553 == temp_22[3,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-2.381193752481799 == temp_22[4,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.9688071004089418 == temp_22[5,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-1.959495555161772 == temp_22[6,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(1.4013739855750704 == temp_22[7,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-1.5329775105321843 == temp_22[8,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(1.8276649690040103 == temp_22[9,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-1.1106883983886444 == temp_22[10,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(2.2426384598738585 == temp_22[11,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-0.6809000975704675 == temp_22[12,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(2.648460001811645 == temp_22[13,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-0.2835615514742411 == temp_22[14,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(3.0642644296286683 == temp_22[15,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.0716470412434909 == temp_22[16,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 laptop.i = laptop.pwr / laptop_adapter.vDC.V;
 ground2.p.i = laptop.i + (- laptop.i);
 laptop_adapter.P = abs(laptop_adapter.efficiency * (laptop_adapter.vDC.V * (- laptop.i)));
 laptop_adapter.S = (- laptop_adapter.P) / -0.9537442168683252;
 laptop_adapter.PLoss = laptop_adapter.P * (1 - laptop_adapter.efficiency) / laptop_adapter.efficiency;
 laptop_adapter.Q = laptop_adapter.S * -0.3006193087448392;
algorithm
equation
 der(v.theta) = 6.283185307179586 * systemDef.fFund;
 v.omega = der(v.theta);
 laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im);
 laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re;
 laptop_adapter.loadBase.i[2].re = laptop_adapter.c[1] * laptop_adapter.a[1].re;
 laptop_adapter.loadBase.i[2].im = laptop_adapter.c[1] * laptop_adapter.a[1].im;
 laptop_adapter.loadBase.i[3].re = laptop_adapter.c[2] * laptop_adapter.a[2].re;
 laptop_adapter.loadBase.i[3].im = laptop_adapter.c[2] * laptop_adapter.a[2].im;
algorithm
equation
 laptop_adapter.loadBase.omega = der(v.theta);
 z.v[1].re = z.z.re .* (- v.i[1].re) - z.z.im .* systemDef.hrms[1] .* (- v.i[1].im);
 z.v[2].re = z.z.re .* (- v.i[2].re) - z.z.im .* systemDef.hrms[2] .* (- v.i[2].im);
 z.v[3].re = z.z.re .* (- v.i[3].re) - z.z.im .* systemDef.hrms[3] .* (- v.i[3].im);
 z.v[1].im = z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re);
 z.v[2].im = z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re);
 z.v[3].im = z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re);
 z.omega = der(v.theta);
 z.v[1].re = 120.0 - z1.v[1].re;
 z.v[2].re = 0.001 - z1.v[2].re;
 z.v[3].re = 0.001 - z1.v[3].re;
 z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im;
 z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im;
 z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im;
 - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re;
 - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re;
 - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re;
 z1.omega = der(v.theta);
 ground1.pin.iIm[1] + (- laptop_adapter.loadBase.i[1].im) + (- v.i[1].im) + (- z1.i[1].im) = 0;
 ground1.pin.iIm[2] + (- laptop_adapter.loadBase.i[2].im) + (- v.i[2].im) + (- z1.i[2].im) = 0;
 ground1.pin.iIm[3] + (- laptop_adapter.loadBase.i[3].im) + (- v.i[3].im) + (- z1.i[3].im) = 0;
 ground1.pin.iRe[1] + (- laptop_adapter.loadBase.i[1].re) + (- v.i[1].re) + (- z1.i[1].re) = 0;
 ground1.pin.iRe[2] + (- laptop_adapter.loadBase.i[2].re) + (- v.i[2].re) + (- z1.i[2].re) = 0;
 ground1.pin.iRe[3] + (- laptop_adapter.loadBase.i[3].re) + (- v.i[3].re) + (- z1.i[3].re) = 0;
 0 = ground1.pin.iIm[1];
 0 = ground1.pin.iIm[2];
 0 = ground1.pin.iIm[3];
 0 = ground1.pin.iRe[1];
 0 = ground1.pin.iRe[2];
 0 = ground1.pin.iRe[3];
 HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta));
 HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta));
 v.P1 = 120.0 * v.i[1].re;
 v.iMag[1] = (v.i[1].re ^ 2 + v.i[1].im ^ 2) ^ 0.5;
 v.iMag[2] = (v.i[2].re ^ 2 + v.i[2].im ^ 2) ^ 0.5;
 v.iMag[3] = (v.i[3].re ^ 2 + v.i[3].im ^ 2) ^ 0.5;
 v.iArg[1] = Modelica.Math.atan3(v.i[1].im, v.i[1].re, 0);
 v.iArg[2] = Modelica.Math.atan3(v.i[2].im, v.i[2].re, 0);
 v.iArg[3] = Modelica.Math.atan3(v.i[3].im, v.i[3].re, 0);
 laptop_adapter.I_mag[1] = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5;
 laptop_adapter.I_mag[2] = (laptop_adapter.loadBase.i[2].re ^ 2 + laptop_adapter.loadBase.i[2].im ^ 2) ^ 0.5;
 laptop_adapter.I_mag[3] = (laptop_adapter.loadBase.i[3].re ^ 2 + laptop_adapter.loadBase.i[3].im ^ 2) ^ 0.5;
 laptop_adapter.I_arg[1] = Modelica.Math.atan3(laptop_adapter.loadBase.i[1].im, laptop_adapter.loadBase.i[1].re, 0);
 laptop_adapter.I_arg[2] = Modelica.Math.atan3(laptop_adapter.loadBase.i[2].im, laptop_adapter.loadBase.i[2].re, 0);
 laptop_adapter.I_arg[3] = Modelica.Math.atan3(laptop_adapter.loadBase.i[3].im, laptop_adapter.loadBase.i[3].re, 0);
 laptop_adapter.V_mag[1] = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5;
 laptop_adapter.V_mag[2] = (z1.v[2].re ^ 2 + (- z.v[2].im) ^ 2) ^ 0.5;
 laptop_adapter.V_mag[3] = (z1.v[3].re ^ 2 + (- z.v[3].im) ^ 2) ^ 0.5;
 laptop_adapter.V_arg[2] = Modelica.Math.atan3(- z.v[2].im, z1.v[2].re, 0);
 laptop_adapter.V_arg[3] = Modelica.Math.atan3(- z.v[3].im, z1.v[3].re, 0);
 laptop_adapter.magScale = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5;
 laptop_adapter.argAdj[1] = -2.8182357929499515 - laptop_adapter.V_arg[1] .* systemDef.hrms[2];
 laptop_adapter.argAdj[2] = 0.5364901833841553 - laptop_adapter.V_arg[1] .* systemDef.hrms[3];
 laptop_adapter.a[1].re = cos(laptop_adapter.argAdj[1]);
 laptop_adapter.a[1].im = sin(laptop_adapter.argAdj[1]);
 laptop_adapter.a[2].re = cos(laptop_adapter.argAdj[2]);
 laptop_adapter.a[2].im = sin(laptop_adapter.argAdj[2]);
 laptop_adapter.c[1] = laptop_adapter.magScale * 0.9486974344201337;
 laptop_adapter.c[2] = laptop_adapter.magScale * 0.9221155376813399;
 z.vFundAbs = (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5;
 z.vFundArg = Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0);
 z.iFundAbs = ((- v.i[1].re) ^ 2 + (- v.i[1].im) ^ 2) ^ 0.5;
 z.iFundArg = Modelica.Math.atan3(- v.i[1].im, - v.i[1].re, 0);
 z1.vFundAbs = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5;
 z1.iFundAbs = (z1.i[1].re ^ 2 + z1.i[1].im ^ 2) ^ 0.5;
 z1.iFundArg = Modelica.Math.atan3(z1.i[1].im, z1.i[1].re, 0);
 laptop_adapter.V_arg[1] = Modelica.Math.atan3(- z.v[1].im, z1.v[1].re, 0);

public
 function Modelica.ComplexMath.real
  input Complex c;
  output Real r;
 algorithm
  r := c.re;
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.real;

 function Modelica.ComplexMath.conj
  input Complex c1;
  output Complex c2;
 algorithm
  (c2) := Complex.'constructor'.fromReal(c1.re, - c1.im);
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.conj;

 function Complex.'constructor'.fromReal
  input Real re;
  input Real im;
  output Complex result;
 algorithm
  result.re := re;
  result.im := im;
  return;
 annotation(Inline = true);
 end Complex.'constructor'.fromReal;

 function Complex.'*'.multiply
  input Complex c1;
  input Complex c2;
  output Complex c3;
 algorithm
  (c3) := Complex.'constructor'.fromReal(c1.re * c2.re - c1.im * c2.im, c1.re * c2.im + c1.im * c2.re);
  return;
 annotation(Inline = true);
 end Complex.'*'.multiply;

 function Modelica.ComplexMath.'abs'
  input Complex c;
  output Real result;
 algorithm
  result := (c.re ^ 2 + c.im ^ 2) ^ 0.5;
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.'abs';

 function Modelica.ComplexMath.arg
  input Complex c;
  input Real phi0;
  output Real phi;
 algorithm
  phi := Modelica.Math.atan3(c.im, c.re, phi0);
  return;
 annotation(Inline = true);
 end Modelica.ComplexMath.arg;

 function Modelica.Math.atan3
  input Real u1;
  input Real u2;
  input Real y0;
  output Real y;
  Real w;
 algorithm
  w := atan2(u1, u2);
  if y0 == 0 then
   y := w;
  else
   y := w + 6.283185307179586 * integer((3.141592653589793 + y0 - w) / 6.283185307179586);
  end if;
  return;
 end Modelica.Math.atan3;

 function Modelica.Utilities.Streams.readMatrixSize
  input String fileName;
  input String matrixName;
  output Integer[:] dim;
 algorithm
  init dim as Integer[2];
  external "C" ModelicaIO_readMatrixSizes(fileName, matrixName, dim);
  return;
 end Modelica.Utilities.Streams.readMatrixSize;

 function Modelica.Utilities.Streams.readRealMatrix
  input String fileName;
  input String matrixName;
  input Integer nrow;
  input Integer ncol;
  input Boolean verboseRead;
  output Real[:,:] matrix;
 algorithm
  init matrix as Real[nrow, ncol];
  external "C" ModelicaIO_readRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), verboseRead);
  return;
 end Modelica.Utilities.Streams.readRealMatrix;

 function Complex.'-'.subtract
  input Complex c1;
  input Complex c2;
  output Complex c3;
 algorithm
  (c3) := Complex.'constructor'.fromReal(c1.re - c2.re, c1.im - c2.im);
  return;
 annotation(Inline = true);
 end Complex.'-'.subtract;

 function Complex.'+'
  input Complex c1;
  input Complex c2;
  output Complex c3;
 algorithm
  (c3) := Complex.'constructor'.fromReal(c1.re + c2.re, c1.im + c2.im);
  return;
 annotation(Inline = true);
 end Complex.'+';

 function HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint;

 function HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint;

 record HPF.Utilities.ComponentProperties
  discrete String ComponentType "Type of the component";
 end HPF.Utilities.ComponentProperties;

 record Complex
  Real re "Real part of complex number";
  Real im "Imaginary part of complex number";
 end Complex;

 record HPF.Types.Reference
  Modelica.SIunits.Angle theta;
 end HPF.Types.Reference;

 type Modelica.SIunits.Angle = Real(final quantity = "Angle",final unit = "rad",displayUnit = "deg");
 type Modelica.SIunits.ElectricPotential = Real(final quantity = "ElectricPotential",final unit = "V");
 type Modelica.SIunits.ElectricCurrent = Real(final quantity = "ElectricCurrent",final unit = "A");
 type Modelica.Blocks.Interfaces.RealOutput = Real;
end HPF.Test.Test_Rectifier;

DAE BiPGraph
BiPGraph (77 equations, 73 variables)
Variables: {der(v.theta) v.P1 v.iMag[1] v.iMag[2] v.iMag[3] v.iArg[1] v.iArg[2] v.iArg[3] v.i[1].re v.i[1].im v.i[2].re v.i[2].im v.i[3].re v.i[3].im v.omega ground1.pin.iIm[1] ground1.pin.iIm[2] ground1.pin.iIm[3] ground1.pin.iRe[1] ground1.pin.iRe[2] ground1.pin.iRe[3] laptop_adapter.loadBase.i[1].re laptop_adapter.loadBase.i[1].im laptop_adapter.loadBase.i[2].re laptop_adapter.loadBase.i[2].im laptop_adapter.loadBase.i[3].re laptop_adapter.loadBase.i[3].im laptop_adapter.loadBase.omega laptop_adapter.I_mag[1] laptop_adapter.I_mag[2] laptop_adapter.I_mag[3] laptop_adapter.I_arg[1] laptop_adapter.I_arg[2] laptop_adapter.I_arg[3] laptop_adapter.V_mag[1] laptop_adapter.V_mag[2] laptop_adapter.V_mag[3] laptop_adapter.V_arg[1] laptop_adapter.V_arg[2] laptop_adapter.V_arg[3] laptop_adapter.magScale laptop_adapter.argAdj[1] laptop_adapter.argAdj[2] laptop_adapter.a[1].re laptop_adapter.a[1].im laptop_adapter.a[2].re laptop_adapter.a[2].im laptop_adapter.c[1] laptop_adapter.c[2] z.vFundAbs z.vFundArg z.iFundAbs z.iFundArg z.v[1].re z.v[1].im z.v[2].re z.v[2].im z.v[3].re z.v[3].im z.omega z1.vFundAbs z1.iFundAbs z1.iFundArg z1.v[1].re z1.v[2].re z1.v[3].re z1.i[1].re z1.i[1].im z1.i[2].re z1.i[2].im z1.i[3].re z1.i[3].im z1.omega }
eq_1 : // algorithm

eq_2 : der(v.theta)@M // der(v.theta) = 6.283185307179586 * systemDef.fFund
eq_3 : v.omega@M der(v.theta)@ // v.omega = der(v.theta)
eq_4 : z1.v[1].re@ laptop_adapter.loadBase.i[1].re@M z.v[1].im@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im)
eq_5 : z1.v[1].re@ laptop_adapter.loadBase.i[1].im@M z.v[1].im@ laptop_adapter.loadBase.i[1].re@ // laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re
eq_6 : laptop_adapter.loadBase.i[2].re@M laptop_adapter.c[1]@ laptop_adapter.a[1].re@ // laptop_adapter.loadBase.i[2].re = laptop_adapter.c[1] * laptop_adapter.a[1].re
eq_7 : laptop_adapter.loadBase.i[2].im@M laptop_adapter.c[1]@ laptop_adapter.a[1].im@ // laptop_adapter.loadBase.i[2].im = laptop_adapter.c[1] * laptop_adapter.a[1].im
eq_8 : laptop_adapter.loadBase.i[3].re@M laptop_adapter.c[2]@ laptop_adapter.a[2].re@ // laptop_adapter.loadBase.i[3].re = laptop_adapter.c[2] * laptop_adapter.a[2].re
eq_9 : laptop_adapter.loadBase.i[3].im@M laptop_adapter.c[2]@ laptop_adapter.a[2].im@ // laptop_adapter.loadBase.i[3].im = laptop_adapter.c[2] * laptop_adapter.a[2].im
eq_10 : // algorithm

eq_11 : laptop_adapter.loadBase.omega@M der(v.theta)@ // laptop_adapter.loadBase.omega = der(v.theta)
eq_12 : z.v[1].re@M v.i[1].re@ v.i[1].im@ // z.v[1].re = z.z.re .* (- v.i[1].re) - z.z.im .* systemDef.hrms[1] .* (- v.i[1].im)
eq_13 : z.v[2].re@M v.i[2].re@ v.i[2].im@ // z.v[2].re = z.z.re .* (- v.i[2].re) - z.z.im .* systemDef.hrms[2] .* (- v.i[2].im)
eq_14 : z.v[3].re@M v.i[3].re@ v.i[3].im@ // z.v[3].re = z.z.re .* (- v.i[3].re) - z.z.im .* systemDef.hrms[3] .* (- v.i[3].im)
eq_15 : z.v[1].im@M v.i[1].im@ v.i[1].re@ // z.v[1].im = z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re)
eq_16 : z.v[2].im@M v.i[2].im@ v.i[2].re@ // z.v[2].im = z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re)
eq_17 : z.v[3].im@M v.i[3].im@ v.i[3].re@ // z.v[3].im = z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re)
eq_18 : z.omega@M der(v.theta)@ // z.omega = der(v.theta)
eq_19 : z.v[1].re@ z1.v[1].re@M // z.v[1].re = 120.0 - z1.v[1].re
eq_20 : z.v[2].re@ z1.v[2].re@M // z.v[2].re = 0.001 - z1.v[2].re
eq_21 : z.v[3].re@ z1.v[3].re@M // z.v[3].re = 0.001 - z1.v[3].re
eq_22 : z1.v[1].re@ z1.i[1].re@M z1.i[1].im@ // z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im
eq_23 : z1.v[2].re@ z1.i[2].re@M z1.i[2].im@ // z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im
eq_24 : z1.v[3].re@ z1.i[3].re@M z1.i[3].im@ // z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im
eq_25 : z.v[1].im@ z1.i[1].im@M z1.i[1].re@ // - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re
eq_26 : z.v[2].im@ z1.i[2].im@M z1.i[2].re@ // - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re
eq_27 : z.v[3].im@ z1.i[3].im@M z1.i[3].re@ // - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re
eq_28 : z1.omega@M der(v.theta)@ // z1.omega = der(v.theta)
eq_29 : ground1.pin.iIm[1]@ laptop_adapter.loadBase.i[1].im@ v.i[1].im@M z1.i[1].im@ // ground1.pin.iIm[1] + (- laptop_adapter.loadBase.i[1].im) + (- v.i[1].im) + (- z1.i[1].im) = 0
eq_30 : ground1.pin.iIm[2]@ laptop_adapter.loadBase.i[2].im@ v.i[2].im@M z1.i[2].im@ // ground1.pin.iIm[2] + (- laptop_adapter.loadBase.i[2].im) + (- v.i[2].im) + (- z1.i[2].im) = 0
eq_31 : ground1.pin.iIm[3]@ laptop_adapter.loadBase.i[3].im@ v.i[3].im@M z1.i[3].im@ // ground1.pin.iIm[3] + (- laptop_adapter.loadBase.i[3].im) + (- v.i[3].im) + (- z1.i[3].im) = 0
eq_32 : ground1.pin.iRe[1]@ laptop_adapter.loadBase.i[1].re@ v.i[1].re@M z1.i[1].re@ // ground1.pin.iRe[1] + (- laptop_adapter.loadBase.i[1].re) + (- v.i[1].re) + (- z1.i[1].re) = 0
eq_33 : ground1.pin.iRe[2]@ laptop_adapter.loadBase.i[2].re@ v.i[2].re@M z1.i[2].re@ // ground1.pin.iRe[2] + (- laptop_adapter.loadBase.i[2].re) + (- v.i[2].re) + (- z1.i[2].re) = 0
eq_34 : ground1.pin.iRe[3]@ laptop_adapter.loadBase.i[3].re@ v.i[3].re@M z1.i[3].re@ // ground1.pin.iRe[3] + (- laptop_adapter.loadBase.i[3].re) + (- v.i[3].re) + (- z1.i[3].re) = 0
eq_35 : ground1.pin.iIm[1]@M // 0 = ground1.pin.iIm[1]
eq_36 : ground1.pin.iIm[2]@M // 0 = ground1.pin.iIm[2]
eq_37 : ground1.pin.iIm[3]@M // 0 = ground1.pin.iIm[3]
eq_38 : ground1.pin.iRe[1]@M // 0 = ground1.pin.iRe[1]
eq_39 : ground1.pin.iRe[2]@M // 0 = ground1.pin.iRe[2]
eq_40 : ground1.pin.iRe[3]@M // 0 = ground1.pin.iRe[3]
eq_41 : // HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))
eq_42 : // HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))
eq_43 : v.P1@M v.i[1].re@ // v.P1 = 120.0 * v.i[1].re
eq_44 : v.iMag[1]@M v.i[1].re@ v.i[1].im@ // v.iMag[1] = (v.i[1].re ^ 2 + v.i[1].im ^ 2) ^ 0.5
eq_45 : v.iMag[2]@M v.i[2].re@ v.i[2].im@ // v.iMag[2] = (v.i[2].re ^ 2 + v.i[2].im ^ 2) ^ 0.5
eq_46 : v.iMag[3]@M v.i[3].re@ v.i[3].im@ // v.iMag[3] = (v.i[3].re ^ 2 + v.i[3].im ^ 2) ^ 0.5
eq_47 : v.iArg[1]@M v.i[1].im@ v.i[1].re@ // v.iArg[1] = Modelica.Math.atan3(v.i[1].im, v.i[1].re, 0)
eq_48 : v.iArg[2]@M v.i[2].im@ v.i[2].re@ // v.iArg[2] = Modelica.Math.atan3(v.i[2].im, v.i[2].re, 0)
eq_49 : v.iArg[3]@M v.i[3].im@ v.i[3].re@ // v.iArg[3] = Modelica.Math.atan3(v.i[3].im, v.i[3].re, 0)
eq_50 : laptop_adapter.I_mag[1]@M laptop_adapter.loadBase.i[1].re@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.I_mag[1] = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5
eq_51 : laptop_adapter.I_mag[2]@M laptop_adapter.loadBase.i[2].re@ laptop_adapter.loadBase.i[2].im@ // laptop_adapter.I_mag[2] = (laptop_adapter.loadBase.i[2].re ^ 2 + laptop_adapter.loadBase.i[2].im ^ 2) ^ 0.5
eq_52 : laptop_adapter.I_mag[3]@M laptop_adapter.loadBase.i[3].re@ laptop_adapter.loadBase.i[3].im@ // laptop_adapter.I_mag[3] = (laptop_adapter.loadBase.i[3].re ^ 2 + laptop_adapter.loadBase.i[3].im ^ 2) ^ 0.5
eq_53 : laptop_adapter.I_arg[1]@M laptop_adapter.loadBase.i[1].im@ laptop_adapter.loadBase.i[1].re@ // laptop_adapter.I_arg[1] = Modelica.Math.atan3(laptop_adapter.loadBase.i[1].im, laptop_adapter.loadBase.i[1].re, 0)
eq_54 : laptop_adapter.I_arg[2]@M laptop_adapter.loadBase.i[2].im@ laptop_adapter.loadBase.i[2].re@ // laptop_adapter.I_arg[2] = Modelica.Math.atan3(laptop_adapter.loadBase.i[2].im, laptop_adapter.loadBase.i[2].re, 0)
eq_55 : laptop_adapter.I_arg[3]@M laptop_adapter.loadBase.i[3].im@ laptop_adapter.loadBase.i[3].re@ // laptop_adapter.I_arg[3] = Modelica.Math.atan3(laptop_adapter.loadBase.i[3].im, laptop_adapter.loadBase.i[3].re, 0)
eq_56 : laptop_adapter.V_mag[1]@M z1.v[1].re@ z.v[1].im@ // laptop_adapter.V_mag[1] = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5
eq_57 : laptop_adapter.V_mag[2]@M z1.v[2].re@ z.v[2].im@ // laptop_adapter.V_mag[2] = (z1.v[2].re ^ 2 + (- z.v[2].im) ^ 2) ^ 0.5
eq_58 : laptop_adapter.V_mag[3]@M z1.v[3].re@ z.v[3].im@ // laptop_adapter.V_mag[3] = (z1.v[3].re ^ 2 + (- z.v[3].im) ^ 2) ^ 0.5
eq_59 : laptop_adapter.V_arg[2]@M z.v[2].im@ z1.v[2].re@ // laptop_adapter.V_arg[2] = Modelica.Math.atan3(- z.v[2].im, z1.v[2].re, 0)
eq_60 : laptop_adapter.V_arg[3]@M z.v[3].im@ z1.v[3].re@ // laptop_adapter.V_arg[3] = Modelica.Math.atan3(- z.v[3].im, z1.v[3].re, 0)
eq_61 : laptop_adapter.magScale@M laptop_adapter.loadBase.i[1].re@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.magScale = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5
eq_62 : laptop_adapter.argAdj[1]@M laptop_adapter.V_arg[1]@ // laptop_adapter.argAdj[1] = -2.8182357929499515 - laptop_adapter.V_arg[1] .* systemDef.hrms[2]
eq_63 : laptop_adapter.argAdj[2]@M laptop_adapter.V_arg[1]@ // laptop_adapter.argAdj[2] = 0.5364901833841553 - laptop_adapter.V_arg[1] .* systemDef.hrms[3]
eq_64 : laptop_adapter.a[1].re@M laptop_adapter.argAdj[1]@ // laptop_adapter.a[1].re = cos(laptop_adapter.argAdj[1])
eq_65 : laptop_adapter.a[1].im@M laptop_adapter.argAdj[1]@ // laptop_adapter.a[1].im = sin(laptop_adapter.argAdj[1])
eq_66 : laptop_adapter.a[2].re@M laptop_adapter.argAdj[2]@ // laptop_adapter.a[2].re = cos(laptop_adapter.argAdj[2])
eq_67 : laptop_adapter.a[2].im@M laptop_adapter.argAdj[2]@ // laptop_adapter.a[2].im = sin(laptop_adapter.argAdj[2])
eq_68 : laptop_adapter.c[1]@M laptop_adapter.magScale@ // laptop_adapter.c[1] = laptop_adapter.magScale * 0.9486974344201337
eq_69 : laptop_adapter.c[2]@M laptop_adapter.magScale@ // laptop_adapter.c[2] = laptop_adapter.magScale * 0.9221155376813399
eq_70 : z.vFundAbs@M z.v[1].re@ z.v[1].im@ // z.vFundAbs = (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5
eq_71 : z.vFundArg@M z.v[1].im@ z.v[1].re@ // z.vFundArg = Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0)
eq_72 : z.iFundAbs@M v.i[1].re@ v.i[1].im@ // z.iFundAbs = ((- v.i[1].re) ^ 2 + (- v.i[1].im) ^ 2) ^ 0.5
eq_73 : z.iFundArg@M v.i[1].im@ v.i[1].re@ // z.iFundArg = Modelica.Math.atan3(- v.i[1].im, - v.i[1].re, 0)
eq_74 : z1.vFundAbs@M z1.v[1].re@ z.v[1].im@ // z1.vFundAbs = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5
eq_75 : z1.iFundAbs@M z1.i[1].re@ z1.i[1].im@ // z1.iFundAbs = (z1.i[1].re ^ 2 + z1.i[1].im ^ 2) ^ 0.5
eq_76 : z1.iFundArg@M z1.i[1].im@ z1.i[1].re@ // z1.iFundArg = Modelica.Math.atan3(z1.i[1].im, z1.i[1].re, 0)
eq_77 : laptop_adapter.V_arg[1]@M z.v[1].im@ z1.v[1].re@ // laptop_adapter.V_arg[1] = Modelica.Math.atan3(- z.v[1].im, z1.v[1].re, 0)

DAE BiPGraph matching
----------------------------------------
BiPGraph matching:
eq_2 : der(v.theta)
eq_3 : v.omega
eq_4 : laptop_adapter.loadBase.i[1].re
eq_5 : laptop_adapter.loadBase.i[1].im
eq_6 : laptop_adapter.loadBase.i[2].re
eq_7 : laptop_adapter.loadBase.i[2].im
eq_8 : laptop_adapter.loadBase.i[3].re
eq_9 : laptop_adapter.loadBase.i[3].im
eq_11 : laptop_adapter.loadBase.omega
eq_12 : z.v[1].re
eq_13 : z.v[2].re
eq_14 : z.v[3].re
eq_15 : z.v[1].im
eq_16 : z.v[2].im
eq_17 : z.v[3].im
eq_18 : z.omega
eq_19 : z1.v[1].re
eq_20 : z1.v[2].re
eq_21 : z1.v[3].re
eq_22 : z1.i[1].re
eq_23 : z1.i[2].re
eq_24 : z1.i[3].re
eq_25 : z1.i[1].im
eq_26 : z1.i[2].im
eq_27 : z1.i[3].im
eq_28 : z1.omega
eq_29 : v.i[1].im
eq_30 : v.i[2].im
eq_31 : v.i[3].im
eq_32 : v.i[1].re
eq_33 : v.i[2].re
eq_34 : v.i[3].re
eq_35 : ground1.pin.iIm[1]
eq_36 : ground1.pin.iIm[2]
eq_37 : ground1.pin.iIm[3]
eq_38 : ground1.pin.iRe[1]
eq_39 : ground1.pin.iRe[2]
eq_40 : ground1.pin.iRe[3]
eq_43 : v.P1
eq_44 : v.iMag[1]
eq_45 : v.iMag[2]
eq_46 : v.iMag[3]
eq_47 : v.iArg[1]
eq_48 : v.iArg[2]
eq_49 : v.iArg[3]
eq_50 : laptop_adapter.I_mag[1]
eq_51 : laptop_adapter.I_mag[2]
eq_52 : laptop_adapter.I_mag[3]
eq_53 : laptop_adapter.I_arg[1]
eq_54 : laptop_adapter.I_arg[2]
eq_55 : laptop_adapter.I_arg[3]
eq_56 : laptop_adapter.V_mag[1]
eq_57 : laptop_adapter.V_mag[2]
eq_58 : laptop_adapter.V_mag[3]
eq_59 : laptop_adapter.V_arg[2]
eq_60 : laptop_adapter.V_arg[3]
eq_61 : laptop_adapter.magScale
eq_62 : laptop_adapter.argAdj[1]
eq_63 : laptop_adapter.argAdj[2]
eq_64 : laptop_adapter.a[1].re
eq_65 : laptop_adapter.a[1].im
eq_66 : laptop_adapter.a[2].re
eq_67 : laptop_adapter.a[2].im
eq_68 : laptop_adapter.c[1]
eq_69 : laptop_adapter.c[2]
eq_70 : z.vFundAbs
eq_71 : z.vFundArg
eq_72 : z.iFundAbs
eq_73 : z.iFundArg
eq_74 : z1.vFundAbs
eq_75 : z1.iFundAbs
eq_76 : z1.iFundArg
eq_77 : laptop_adapter.V_arg[1]
Unmatched equations: {}
Unmatched variables: {}
----------------------------------------

BiPGraph (77 equations, 73 variables)
Variables: {der(v.theta) v.P1 v.iMag[1] v.iMag[2] v.iMag[3] v.iArg[1] v.iArg[2] v.iArg[3] v.i[1].re v.i[1].im v.i[2].re v.i[2].im v.i[3].re v.i[3].im v.omega ground1.pin.iIm[1] ground1.pin.iIm[2] ground1.pin.iIm[3] ground1.pin.iRe[1] ground1.pin.iRe[2] ground1.pin.iRe[3] laptop_adapter.loadBase.i[1].re laptop_adapter.loadBase.i[1].im laptop_adapter.loadBase.i[2].re laptop_adapter.loadBase.i[2].im laptop_adapter.loadBase.i[3].re laptop_adapter.loadBase.i[3].im laptop_adapter.loadBase.omega laptop_adapter.I_mag[1] laptop_adapter.I_mag[2] laptop_adapter.I_mag[3] laptop_adapter.I_arg[1] laptop_adapter.I_arg[2] laptop_adapter.I_arg[3] laptop_adapter.V_mag[1] laptop_adapter.V_mag[2] laptop_adapter.V_mag[3] laptop_adapter.V_arg[1] laptop_adapter.V_arg[2] laptop_adapter.V_arg[3] laptop_adapter.magScale laptop_adapter.argAdj[1] laptop_adapter.argAdj[2] laptop_adapter.a[1].re laptop_adapter.a[1].im laptop_adapter.a[2].re laptop_adapter.a[2].im laptop_adapter.c[1] laptop_adapter.c[2] z.vFundAbs z.vFundArg z.iFundAbs z.iFundArg z.v[1].re z.v[1].im z.v[2].re z.v[2].im z.v[3].re z.v[3].im z.omega z1.vFundAbs z1.iFundAbs z1.iFundArg z1.v[1].re z1.v[2].re z1.v[3].re z1.i[1].re z1.i[1].im z1.i[2].re z1.i[2].im z1.i[3].re z1.i[3].im z1.omega }
eq_1 : // algorithm

eq_2 : der(v.theta)@M // der(v.theta) = 6.283185307179586 * systemDef.fFund
eq_3 : v.omega@M der(v.theta)@ // v.omega = der(v.theta)
eq_4 : z1.v[1].re@ laptop_adapter.loadBase.i[1].re@M z.v[1].im@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im)
eq_5 : z1.v[1].re@ laptop_adapter.loadBase.i[1].im@M z.v[1].im@ laptop_adapter.loadBase.i[1].re@ // laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re
eq_6 : laptop_adapter.loadBase.i[2].re@M laptop_adapter.c[1]@ laptop_adapter.a[1].re@ // laptop_adapter.loadBase.i[2].re = laptop_adapter.c[1] * laptop_adapter.a[1].re
eq_7 : laptop_adapter.loadBase.i[2].im@M laptop_adapter.c[1]@ laptop_adapter.a[1].im@ // laptop_adapter.loadBase.i[2].im = laptop_adapter.c[1] * laptop_adapter.a[1].im
eq_8 : laptop_adapter.loadBase.i[3].re@M laptop_adapter.c[2]@ laptop_adapter.a[2].re@ // laptop_adapter.loadBase.i[3].re = laptop_adapter.c[2] * laptop_adapter.a[2].re
eq_9 : laptop_adapter.loadBase.i[3].im@M laptop_adapter.c[2]@ laptop_adapter.a[2].im@ // laptop_adapter.loadBase.i[3].im = laptop_adapter.c[2] * laptop_adapter.a[2].im
eq_10 : // algorithm

eq_11 : laptop_adapter.loadBase.omega@M der(v.theta)@ // laptop_adapter.loadBase.omega = der(v.theta)
eq_12 : z.v[1].re@M v.i[1].re@ v.i[1].im@ // z.v[1].re = z.z.re .* (- v.i[1].re) - z.z.im .* systemDef.hrms[1] .* (- v.i[1].im)
eq_13 : z.v[2].re@M v.i[2].re@ v.i[2].im@ // z.v[2].re = z.z.re .* (- v.i[2].re) - z.z.im .* systemDef.hrms[2] .* (- v.i[2].im)
eq_14 : z.v[3].re@M v.i[3].re@ v.i[3].im@ // z.v[3].re = z.z.re .* (- v.i[3].re) - z.z.im .* systemDef.hrms[3] .* (- v.i[3].im)
eq_15 : z.v[1].im@M v.i[1].im@ v.i[1].re@ // z.v[1].im = z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re)
eq_16 : z.v[2].im@M v.i[2].im@ v.i[2].re@ // z.v[2].im = z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re)
eq_17 : z.v[3].im@M v.i[3].im@ v.i[3].re@ // z.v[3].im = z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re)
eq_18 : z.omega@M der(v.theta)@ // z.omega = der(v.theta)
eq_19 : z.v[1].re@ z1.v[1].re@M // z.v[1].re = 120.0 - z1.v[1].re
eq_20 : z.v[2].re@ z1.v[2].re@M // z.v[2].re = 0.001 - z1.v[2].re
eq_21 : z.v[3].re@ z1.v[3].re@M // z.v[3].re = 0.001 - z1.v[3].re
eq_22 : z1.v[1].re@ z1.i[1].re@M z1.i[1].im@ // z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im
eq_23 : z1.v[2].re@ z1.i[2].re@M z1.i[2].im@ // z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im
eq_24 : z1.v[3].re@ z1.i[3].re@M z1.i[3].im@ // z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im
eq_25 : z.v[1].im@ z1.i[1].im@M z1.i[1].re@ // - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re
eq_26 : z.v[2].im@ z1.i[2].im@M z1.i[2].re@ // - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re
eq_27 : z.v[3].im@ z1.i[3].im@M z1.i[3].re@ // - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re
eq_28 : z1.omega@M der(v.theta)@ // z1.omega = der(v.theta)
eq_29 : ground1.pin.iIm[1]@ laptop_adapter.loadBase.i[1].im@ v.i[1].im@M z1.i[1].im@ // ground1.pin.iIm[1] + (- laptop_adapter.loadBase.i[1].im) + (- v.i[1].im) + (- z1.i[1].im) = 0
eq_30 : ground1.pin.iIm[2]@ laptop_adapter.loadBase.i[2].im@ v.i[2].im@M z1.i[2].im@ // ground1.pin.iIm[2] + (- laptop_adapter.loadBase.i[2].im) + (- v.i[2].im) + (- z1.i[2].im) = 0
eq_31 : ground1.pin.iIm[3]@ laptop_adapter.loadBase.i[3].im@ v.i[3].im@M z1.i[3].im@ // ground1.pin.iIm[3] + (- laptop_adapter.loadBase.i[3].im) + (- v.i[3].im) + (- z1.i[3].im) = 0
eq_32 : ground1.pin.iRe[1]@ laptop_adapter.loadBase.i[1].re@ v.i[1].re@M z1.i[1].re@ // ground1.pin.iRe[1] + (- laptop_adapter.loadBase.i[1].re) + (- v.i[1].re) + (- z1.i[1].re) = 0
eq_33 : ground1.pin.iRe[2]@ laptop_adapter.loadBase.i[2].re@ v.i[2].re@M z1.i[2].re@ // ground1.pin.iRe[2] + (- laptop_adapter.loadBase.i[2].re) + (- v.i[2].re) + (- z1.i[2].re) = 0
eq_34 : ground1.pin.iRe[3]@ laptop_adapter.loadBase.i[3].re@ v.i[3].re@M z1.i[3].re@ // ground1.pin.iRe[3] + (- laptop_adapter.loadBase.i[3].re) + (- v.i[3].re) + (- z1.i[3].re) = 0
eq_35 : ground1.pin.iIm[1]@M // 0 = ground1.pin.iIm[1]
eq_36 : ground1.pin.iIm[2]@M // 0 = ground1.pin.iIm[2]
eq_37 : ground1.pin.iIm[3]@M // 0 = ground1.pin.iIm[3]
eq_38 : ground1.pin.iRe[1]@M // 0 = ground1.pin.iRe[1]
eq_39 : ground1.pin.iRe[2]@M // 0 = ground1.pin.iRe[2]
eq_40 : ground1.pin.iRe[3]@M // 0 = ground1.pin.iRe[3]
eq_41 : // HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))
eq_42 : // HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))
eq_43 : v.P1@M v.i[1].re@ // v.P1 = 120.0 * v.i[1].re
eq_44 : v.iMag[1]@M v.i[1].re@ v.i[1].im@ // v.iMag[1] = (v.i[1].re ^ 2 + v.i[1].im ^ 2) ^ 0.5
eq_45 : v.iMag[2]@M v.i[2].re@ v.i[2].im@ // v.iMag[2] = (v.i[2].re ^ 2 + v.i[2].im ^ 2) ^ 0.5
eq_46 : v.iMag[3]@M v.i[3].re@ v.i[3].im@ // v.iMag[3] = (v.i[3].re ^ 2 + v.i[3].im ^ 2) ^ 0.5
eq_47 : v.iArg[1]@M v.i[1].im@ v.i[1].re@ // v.iArg[1] = Modelica.Math.atan3(v.i[1].im, v.i[1].re, 0)
eq_48 : v.iArg[2]@M v.i[2].im@ v.i[2].re@ // v.iArg[2] = Modelica.Math.atan3(v.i[2].im, v.i[2].re, 0)
eq_49 : v.iArg[3]@M v.i[3].im@ v.i[3].re@ // v.iArg[3] = Modelica.Math.atan3(v.i[3].im, v.i[3].re, 0)
eq_50 : laptop_adapter.I_mag[1]@M laptop_adapter.loadBase.i[1].re@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.I_mag[1] = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5
eq_51 : laptop_adapter.I_mag[2]@M laptop_adapter.loadBase.i[2].re@ laptop_adapter.loadBase.i[2].im@ // laptop_adapter.I_mag[2] = (laptop_adapter.loadBase.i[2].re ^ 2 + laptop_adapter.loadBase.i[2].im ^ 2) ^ 0.5
eq_52 : laptop_adapter.I_mag[3]@M laptop_adapter.loadBase.i[3].re@ laptop_adapter.loadBase.i[3].im@ // laptop_adapter.I_mag[3] = (laptop_adapter.loadBase.i[3].re ^ 2 + laptop_adapter.loadBase.i[3].im ^ 2) ^ 0.5
eq_53 : laptop_adapter.I_arg[1]@M laptop_adapter.loadBase.i[1].im@ laptop_adapter.loadBase.i[1].re@ // laptop_adapter.I_arg[1] = Modelica.Math.atan3(laptop_adapter.loadBase.i[1].im, laptop_adapter.loadBase.i[1].re, 0)
eq_54 : laptop_adapter.I_arg[2]@M laptop_adapter.loadBase.i[2].im@ laptop_adapter.loadBase.i[2].re@ // laptop_adapter.I_arg[2] = Modelica.Math.atan3(laptop_adapter.loadBase.i[2].im, laptop_adapter.loadBase.i[2].re, 0)
eq_55 : laptop_adapter.I_arg[3]@M laptop_adapter.loadBase.i[3].im@ laptop_adapter.loadBase.i[3].re@ // laptop_adapter.I_arg[3] = Modelica.Math.atan3(laptop_adapter.loadBase.i[3].im, laptop_adapter.loadBase.i[3].re, 0)
eq_56 : laptop_adapter.V_mag[1]@M z1.v[1].re@ z.v[1].im@ // laptop_adapter.V_mag[1] = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5
eq_57 : laptop_adapter.V_mag[2]@M z1.v[2].re@ z.v[2].im@ // laptop_adapter.V_mag[2] = (z1.v[2].re ^ 2 + (- z.v[2].im) ^ 2) ^ 0.5
eq_58 : laptop_adapter.V_mag[3]@M z1.v[3].re@ z.v[3].im@ // laptop_adapter.V_mag[3] = (z1.v[3].re ^ 2 + (- z.v[3].im) ^ 2) ^ 0.5
eq_59 : laptop_adapter.V_arg[2]@M z.v[2].im@ z1.v[2].re@ // laptop_adapter.V_arg[2] = Modelica.Math.atan3(- z.v[2].im, z1.v[2].re, 0)
eq_60 : laptop_adapter.V_arg[3]@M z.v[3].im@ z1.v[3].re@ // laptop_adapter.V_arg[3] = Modelica.Math.atan3(- z.v[3].im, z1.v[3].re, 0)
eq_61 : laptop_adapter.magScale@M laptop_adapter.loadBase.i[1].re@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.magScale = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5
eq_62 : laptop_adapter.argAdj[1]@M laptop_adapter.V_arg[1]@ // laptop_adapter.argAdj[1] = -2.8182357929499515 - laptop_adapter.V_arg[1] .* systemDef.hrms[2]
eq_63 : laptop_adapter.argAdj[2]@M laptop_adapter.V_arg[1]@ // laptop_adapter.argAdj[2] = 0.5364901833841553 - laptop_adapter.V_arg[1] .* systemDef.hrms[3]
eq_64 : laptop_adapter.a[1].re@M laptop_adapter.argAdj[1]@ // laptop_adapter.a[1].re = cos(laptop_adapter.argAdj[1])
eq_65 : laptop_adapter.a[1].im@M laptop_adapter.argAdj[1]@ // laptop_adapter.a[1].im = sin(laptop_adapter.argAdj[1])
eq_66 : laptop_adapter.a[2].re@M laptop_adapter.argAdj[2]@ // laptop_adapter.a[2].re = cos(laptop_adapter.argAdj[2])
eq_67 : laptop_adapter.a[2].im@M laptop_adapter.argAdj[2]@ // laptop_adapter.a[2].im = sin(laptop_adapter.argAdj[2])
eq_68 : laptop_adapter.c[1]@M laptop_adapter.magScale@ // laptop_adapter.c[1] = laptop_adapter.magScale * 0.9486974344201337
eq_69 : laptop_adapter.c[2]@M laptop_adapter.magScale@ // laptop_adapter.c[2] = laptop_adapter.magScale * 0.9221155376813399
eq_70 : z.vFundAbs@M z.v[1].re@ z.v[1].im@ // z.vFundAbs = (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5
eq_71 : z.vFundArg@M z.v[1].im@ z.v[1].re@ // z.vFundArg = Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0)
eq_72 : z.iFundAbs@M v.i[1].re@ v.i[1].im@ // z.iFundAbs = ((- v.i[1].re) ^ 2 + (- v.i[1].im) ^ 2) ^ 0.5
eq_73 : z.iFundArg@M v.i[1].im@ v.i[1].re@ // z.iFundArg = Modelica.Math.atan3(- v.i[1].im, - v.i[1].re, 0)
eq_74 : z1.vFundAbs@M z1.v[1].re@ z.v[1].im@ // z1.vFundAbs = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5
eq_75 : z1.iFundAbs@M z1.i[1].re@ z1.i[1].im@ // z1.iFundAbs = (z1.i[1].re ^ 2 + z1.i[1].im ^ 2) ^ 0.5
eq_76 : z1.iFundArg@M z1.i[1].im@ z1.i[1].re@ // z1.iFundArg = Modelica.Math.atan3(z1.i[1].im, z1.i[1].re, 0)
eq_77 : laptop_adapter.V_arg[1]@M z.v[1].im@ z1.v[1].re@ // laptop_adapter.V_arg[1] = Modelica.Math.atan3(- z.v[1].im, z1.v[1].re, 0)

Starting automatic tearing
BiPGraph (9 equations, 9 variables)
Variables: {laptop_adapter.loadBase.i[1].im v.i[1].im z.v[1].im z1.i[1].im z1.i[1].re v.i[1].re z.v[1].re z1.v[1].re laptop_adapter.loadBase.i[1].re }
eq_5 : z1.v[1].re# laptop_adapter.loadBase.i[1].im# z.v[1].im# laptop_adapter.loadBase.i[1].re# // laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re
eq_29 : laptop_adapter.loadBase.i[1].im@ v.i[1].im@M z1.i[1].im@ // ground1.pin.iIm[1] + (- laptop_adapter.loadBase.i[1].im) + (- v.i[1].im) + (- z1.i[1].im) = 0
eq_15 : z.v[1].im@M v.i[1].im# v.i[1].re# // z.v[1].im = z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re)
eq_25 : z.v[1].im@ z1.i[1].im# z1.i[1].re# // - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re
eq_22 : z1.v[1].re@ z1.i[1].re# z1.i[1].im# // z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im
eq_32 : laptop_adapter.loadBase.i[1].re@ v.i[1].re@M z1.i[1].re@ // ground1.pin.iRe[1] + (- laptop_adapter.loadBase.i[1].re) + (- v.i[1].re) + (- z1.i[1].re) = 0
eq_12 : z.v[1].re@M v.i[1].re# v.i[1].im# // z.v[1].re = z.z.re .* (- v.i[1].re) - z.z.im .* systemDef.hrms[1] .* (- v.i[1].im)
eq_19 : z.v[1].re@ z1.v[1].re@M // z.v[1].re = 120.0 - z1.v[1].re
eq_4 : z1.v[1].re# laptop_adapter.loadBase.i[1].re# z.v[1].im# laptop_adapter.loadBase.i[1].im# // laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im)

Initial matching
----------------------------------------
BiPGraph matching:
eq_29 : v.i[1].im
eq_15 : z.v[1].im
eq_32 : v.i[1].re
eq_12 : z.v[1].re
eq_19 : z1.v[1].re
Unmatched equations: {eq_5 eq_25 eq_22 eq_4 }
Unmatched variables: {laptop_adapter.loadBase.i[1].im z1.i[1].im z1.i[1].re laptop_adapter.loadBase.i[1].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
eq_29 : v.i[1].im
eq_15 : z.v[1].im
eq_32 : v.i[1].re
eq_12 : z.v[1].re
eq_19 : z1.v[1].re
Unmatched equations: {eq_5 eq_25 eq_22 eq_4 }
Unmatched variables: {laptop_adapter.loadBase.i[1].im z1.i[1].im z1.i[1].re laptop_adapter.loadBase.i[1].re }
----------------------------------------

Automatic tearing pair, equation: laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re, tearing with variable: laptop_adapter.loadBase.i[1].im
Automatic tearing pair, equation: - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re, tearing with variable: z1.i[1].im
Automatic tearing pair, equation: z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im, tearing with variable: laptop_adapter.loadBase.i[1].re
Automatic tearing pair, equation: laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im), tearing with variable: z1.i[1].re
Starting automatic tearing
BiPGraph (7 equations, 7 variables)
Variables: {v.i[2].im z.v[2].im z1.i[2].im z1.v[2].re z1.i[2].re v.i[2].re z.v[2].re }
eq_30 : v.i[2].im@M z1.i[2].im@ // ground1.pin.iIm[2] + (- laptop_adapter.loadBase.i[2].im) + (- v.i[2].im) + (- z1.i[2].im) = 0
eq_16 : z.v[2].im@M v.i[2].im# v.i[2].re# // z.v[2].im = z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re)
eq_26 : z.v[2].im@ z1.i[2].im# z1.i[2].re# // - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re
eq_20 : z.v[2].re@ z1.v[2].re@M // z.v[2].re = 0.001 - z1.v[2].re
eq_23 : z1.v[2].re@ z1.i[2].re# z1.i[2].im# // z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im
eq_33 : v.i[2].re@M z1.i[2].re@ // ground1.pin.iRe[2] + (- laptop_adapter.loadBase.i[2].re) + (- v.i[2].re) + (- z1.i[2].re) = 0
eq_13 : z.v[2].re@M v.i[2].re# v.i[2].im# // z.v[2].re = z.z.re .* (- v.i[2].re) - z.z.im .* systemDef.hrms[2] .* (- v.i[2].im)

Initial matching
----------------------------------------
BiPGraph matching:
eq_30 : v.i[2].im
eq_16 : z.v[2].im
eq_20 : z1.v[2].re
eq_33 : v.i[2].re
eq_13 : z.v[2].re
Unmatched equations: {eq_26 eq_23 }
Unmatched variables: {z1.i[2].im z1.i[2].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
eq_30 : v.i[2].im
eq_16 : z.v[2].im
eq_20 : z1.v[2].re
eq_33 : v.i[2].re
eq_13 : z.v[2].re
Unmatched equations: {eq_26 eq_23 }
Unmatched variables: {z1.i[2].im z1.i[2].re }
----------------------------------------

Automatic tearing pair, equation: - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re, tearing with variable: z1.i[2].im
Automatic tearing pair, equation: z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im, tearing with variable: z1.i[2].re
Starting automatic tearing
BiPGraph (7 equations, 7 variables)
Variables: {v.i[3].im z.v[3].im z1.i[3].im z1.v[3].re z1.i[3].re v.i[3].re z.v[3].re }
eq_31 : v.i[3].im@M z1.i[3].im@ // ground1.pin.iIm[3] + (- laptop_adapter.loadBase.i[3].im) + (- v.i[3].im) + (- z1.i[3].im) = 0
eq_17 : z.v[3].im@M v.i[3].im# v.i[3].re# // z.v[3].im = z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re)
eq_27 : z.v[3].im@ z1.i[3].im# z1.i[3].re# // - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re
eq_21 : z.v[3].re@ z1.v[3].re@M // z.v[3].re = 0.001 - z1.v[3].re
eq_24 : z1.v[3].re@ z1.i[3].re# z1.i[3].im# // z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im
eq_34 : v.i[3].re@M z1.i[3].re@ // ground1.pin.iRe[3] + (- laptop_adapter.loadBase.i[3].re) + (- v.i[3].re) + (- z1.i[3].re) = 0
eq_14 : z.v[3].re@M v.i[3].re# v.i[3].im# // z.v[3].re = z.z.re .* (- v.i[3].re) - z.z.im .* systemDef.hrms[3] .* (- v.i[3].im)

Initial matching
----------------------------------------
BiPGraph matching:
eq_31 : v.i[3].im
eq_17 : z.v[3].im
eq_21 : z1.v[3].re
eq_34 : v.i[3].re
eq_14 : z.v[3].re
Unmatched equations: {eq_27 eq_24 }
Unmatched variables: {z1.i[3].im z1.i[3].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
eq_31 : v.i[3].im
eq_17 : z.v[3].im
eq_21 : z1.v[3].re
eq_34 : v.i[3].re
eq_14 : z.v[3].re
Unmatched equations: {eq_27 eq_24 }
Unmatched variables: {z1.i[3].im z1.i[3].re }
----------------------------------------

Automatic tearing pair, equation: - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re, tearing with variable: z1.i[3].im
Automatic tearing pair, equation: z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im, tearing with variable: z1.i[3].re
***********************************
*********** ODE section ***********
***********************************

--- Solved equation ---
der(v.theta) := 6.283185307179586 * systemDef.fFund

***********************************
*********** Real outputs **********
***********************************

***********************************
*** Integer and boolean outputs ***
***********************************

***********************************
********* Other variables *********
***********************************

--- Solved equation ---
ground1.pin.iIm[1] := 0

--- Solved equation ---
ground1.pin.iRe[1] := 0

--- Torn system (Block 1) of 4 iteration variables and 5 solved variables ---
Torn variables:
  v.i[1].im
  v.i[1].re
  z.v[1].im
  z.v[1].re
  z1.v[1].re

Iteration variables:
  laptop_adapter.loadBase.i[1].im (start=0)
  z1.i[1].im (start=0)
  laptop_adapter.loadBase.i[1].re (start=0)
  z1.i[1].re (start=0)

Torn equations:
  v.i[1].im := ground1.pin.iIm[1] - laptop_adapter.loadBase.i[1].im - z1.i[1].im
  v.i[1].re := ground1.pin.iRe[1] - laptop_adapter.loadBase.i[1].re - z1.i[1].re
  z.v[1].im := z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re)
  z.v[1].re := z.z.re .* (- v.i[1].re) + (- z.z.im .* systemDef.hrms[1] .* (- v.i[1].im))
  z1.v[1].re := - z.v[1].re + 120.0

Residual equations:
  laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re
    Iteration variables: laptop_adapter.loadBase.i[1].im
  - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re
    Iteration variables: z1.i[1].im
  z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im
    Iteration variables: laptop_adapter.loadBase.i[1].re
  laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im)
    Iteration variables: z1.i[1].re

--- Solved equation ---
v.P1 := 120.0 * v.i[1].re

--- Solved equation ---
v.iMag[1] := (v.i[1].re ^ 2 + v.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
ground1.pin.iIm[2] := 0

--- Solved equation ---
laptop_adapter.magScale := (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.c[1] := laptop_adapter.magScale * 0.9486974344201337

--- Solved equation ---
laptop_adapter.V_arg[1] := Modelica.Math.atan3(- z.v[1].im, z1.v[1].re, 0)

--- Solved equation ---
laptop_adapter.argAdj[1] := -2.8182357929499515 + (- laptop_adapter.V_arg[1] .* systemDef.hrms[2])

--- Solved equation ---
laptop_adapter.a[1].im := sin(laptop_adapter.argAdj[1])

--- Solved equation ---
laptop_adapter.loadBase.i[2].im := laptop_adapter.c[1] * laptop_adapter.a[1].im

--- Solved equation ---
ground1.pin.iRe[2] := 0

--- Solved equation ---
laptop_adapter.a[1].re := cos(laptop_adapter.argAdj[1])

--- Solved equation ---
laptop_adapter.loadBase.i[2].re := laptop_adapter.c[1] * laptop_adapter.a[1].re

--- Torn linear system (Block 2) of 2 iteration variables and 5 solved variables ---
Coefficient variability: parameter
Torn variables:
  v.i[2].im
  v.i[2].re
  z.v[2].im
  z.v[2].re
  z1.v[2].re

Iteration variables:
  z1.i[2].im
  z1.i[2].re

Torn equations:
  v.i[2].im := ground1.pin.iIm[2] - laptop_adapter.loadBase.i[2].im - z1.i[2].im
  v.i[2].re := ground1.pin.iRe[2] - laptop_adapter.loadBase.i[2].re - z1.i[2].re
  z.v[2].im := z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re)
  z.v[2].re := z.z.re .* (- v.i[2].re) + (- z.z.im .* systemDef.hrms[2] .* (- v.i[2].im))
  z1.v[2].re := - z.v[2].re + 0.001

Residual equations:
  - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re
    Iteration variables: z1.i[2].im
  z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im
    Iteration variables: z1.i[2].re

Jacobian:
  |-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0|
  |0.0, -1.0, 0.0, 0.0, 0.0, 0.0, -1.0|
  |z.z.re, z.z.im .* systemDef.hrms[2], 1.0, 0.0, 0.0, 0.0, 0.0|
  |- z.z.im .* systemDef.hrms[2], z.z.re, 0.0, 1.0, 0.0, 0.0, 0.0|
  |0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0|
  |0.0, 0.0, -1.0, 0.0, 0.0, - z1.z.re, - z1.z.im .* systemDef.hrms[2]|
  |0.0, 0.0, 0.0, 0.0, 1.0, z1.z.im .* systemDef.hrms[2], - z1.z.re|

--- Solved equation ---
v.iMag[2] := (v.i[2].re ^ 2 + v.i[2].im ^ 2) ^ 0.5

--- Solved equation ---
ground1.pin.iIm[3] := 0

--- Solved equation ---
laptop_adapter.c[2] := laptop_adapter.magScale * 0.9221155376813399

--- Solved equation ---
laptop_adapter.argAdj[2] := 0.5364901833841553 + (- laptop_adapter.V_arg[1] .* systemDef.hrms[3])

--- Solved equation ---
laptop_adapter.a[2].im := sin(laptop_adapter.argAdj[2])

--- Solved equation ---
laptop_adapter.loadBase.i[3].im := laptop_adapter.c[2] * laptop_adapter.a[2].im

--- Solved equation ---
ground1.pin.iRe[3] := 0

--- Solved equation ---
laptop_adapter.a[2].re := cos(laptop_adapter.argAdj[2])

--- Solved equation ---
laptop_adapter.loadBase.i[3].re := laptop_adapter.c[2] * laptop_adapter.a[2].re

--- Torn linear system (Block 3) of 2 iteration variables and 5 solved variables ---
Coefficient variability: parameter
Torn variables:
  v.i[3].im
  v.i[3].re
  z.v[3].im
  z.v[3].re
  z1.v[3].re

Iteration variables:
  z1.i[3].im
  z1.i[3].re

Torn equations:
  v.i[3].im := ground1.pin.iIm[3] - laptop_adapter.loadBase.i[3].im - z1.i[3].im
  v.i[3].re := ground1.pin.iRe[3] - laptop_adapter.loadBase.i[3].re - z1.i[3].re
  z.v[3].im := z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re)
  z.v[3].re := z.z.re .* (- v.i[3].re) + (- z.z.im .* systemDef.hrms[3] .* (- v.i[3].im))
  z1.v[3].re := - z.v[3].re + 0.001

Residual equations:
  - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re
    Iteration variables: z1.i[3].im
  z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im
    Iteration variables: z1.i[3].re

Jacobian:
  |-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0|
  |0.0, -1.0, 0.0, 0.0, 0.0, 0.0, -1.0|
  |z.z.re, z.z.im .* systemDef.hrms[3], 1.0, 0.0, 0.0, 0.0, 0.0|
  |- z.z.im .* systemDef.hrms[3], z.z.re, 0.0, 1.0, 0.0, 0.0, 0.0|
  |0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0|
  |0.0, 0.0, -1.0, 0.0, 0.0, - z1.z.re, - z1.z.im .* systemDef.hrms[3]|
  |0.0, 0.0, 0.0, 0.0, 1.0, z1.z.im .* systemDef.hrms[3], - z1.z.re|

--- Solved equation ---
v.iMag[3] := (v.i[3].re ^ 2 + v.i[3].im ^ 2) ^ 0.5

--- Solved equation ---
v.iArg[1] := Modelica.Math.atan3(v.i[1].im, v.i[1].re, 0)

--- Solved equation ---
v.iArg[2] := Modelica.Math.atan3(v.i[2].im, v.i[2].re, 0)

--- Solved equation ---
v.iArg[3] := Modelica.Math.atan3(v.i[3].im, v.i[3].re, 0)

--- Solved equation ---
v.omega := der(v.theta)

--- Solved equation ---
laptop_adapter.loadBase.omega := der(v.theta)

--- Solved equation ---
laptop_adapter.I_mag[1] := (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.I_mag[2] := (laptop_adapter.loadBase.i[2].re ^ 2 + laptop_adapter.loadBase.i[2].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.I_mag[3] := (laptop_adapter.loadBase.i[3].re ^ 2 + laptop_adapter.loadBase.i[3].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.I_arg[1] := Modelica.Math.atan3(laptop_adapter.loadBase.i[1].im, laptop_adapter.loadBase.i[1].re, 0)

--- Solved equation ---
laptop_adapter.I_arg[2] := Modelica.Math.atan3(laptop_adapter.loadBase.i[2].im, laptop_adapter.loadBase.i[2].re, 0)

--- Solved equation ---
laptop_adapter.I_arg[3] := Modelica.Math.atan3(laptop_adapter.loadBase.i[3].im, laptop_adapter.loadBase.i[3].re, 0)

--- Solved equation ---
laptop_adapter.V_mag[1] := (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.V_mag[2] := (z1.v[2].re ^ 2 + (- z.v[2].im) ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.V_mag[3] := (z1.v[3].re ^ 2 + (- z.v[3].im) ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.V_arg[2] := Modelica.Math.atan3(- z.v[2].im, z1.v[2].re, 0)

--- Solved equation ---
laptop_adapter.V_arg[3] := Modelica.Math.atan3(- z.v[3].im, z1.v[3].re, 0)

--- Solved equation ---
z.vFundAbs := (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5

--- Solved equation ---
z.vFundArg := Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0)

--- Solved equation ---
z.iFundAbs := ((- v.i[1].re) ^ 2 + (- v.i[1].im) ^ 2) ^ 0.5

--- Solved equation ---
z.iFundArg := Modelica.Math.atan3(- v.i[1].im, - v.i[1].re, 0)

--- Solved equation ---
z.omega := der(v.theta)

--- Solved equation ---
z1.vFundAbs := (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5

--- Solved equation ---
z1.iFundAbs := (z1.i[1].re ^ 2 + z1.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
z1.iFundArg := Modelica.Math.atan3(z1.i[1].im, z1.i[1].re, 0)

--- Solved equation ---
z1.omega := der(v.theta)

--- Meta equation block ---
algorithm


--- Meta equation block ---
algorithm


--- Meta equation block ---
HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))

--- Meta equation block ---
HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))

***********************************

--- Meta equation block ---
algorithm


--- Solved equation ---
der(v.theta) := 6.283185307179586 * systemDef.fFund

--- Solved equation ---
v.omega := der(v.theta)

--- Solved equation ---
ground1.pin.iRe[1] := 0

--- Solved equation ---
ground1.pin.iIm[1] := 0

--- Torn system (Block 1) of 4 iteration variables and 5 solved variables ---
Torn variables:
  v.i[1].im
  v.i[1].re
  z.v[1].im
  z.v[1].re
  z1.v[1].re

Iteration variables:
  laptop_adapter.loadBase.i[1].im (start=0)
  z1.i[1].im (start=0)
  laptop_adapter.loadBase.i[1].re (start=0)
  z1.i[1].re (start=0)

Torn equations:
  v.i[1].im := ground1.pin.iIm[1] - laptop_adapter.loadBase.i[1].im - z1.i[1].im
  v.i[1].re := ground1.pin.iRe[1] - laptop_adapter.loadBase.i[1].re - z1.i[1].re
  z.v[1].im := z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re)
  z.v[1].re := z.z.re .* (- v.i[1].re) + (- z.z.im .* systemDef.hrms[1] .* (- v.i[1].im))
  z1.v[1].re := - z.v[1].re + 120.0

Residual equations:
  laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re
    Iteration variables: laptop_adapter.loadBase.i[1].im
  - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re
    Iteration variables: z1.i[1].im
  z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im
    Iteration variables: laptop_adapter.loadBase.i[1].re
  laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im)
    Iteration variables: z1.i[1].re

--- Solved equation ---
laptop_adapter.magScale := (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.c[1] := laptop_adapter.magScale * 0.9486974344201337

--- Solved equation ---
laptop_adapter.V_arg[1] := Modelica.Math.atan3(- z.v[1].im, z1.v[1].re, 0)

--- Solved equation ---
laptop_adapter.argAdj[1] := -2.8182357929499515 + (- laptop_adapter.V_arg[1] .* systemDef.hrms[2])

--- Solved equation ---
laptop_adapter.a[1].re := cos(laptop_adapter.argAdj[1])

--- Solved equation ---
laptop_adapter.loadBase.i[2].re := laptop_adapter.c[1] * laptop_adapter.a[1].re

--- Solved equation ---
laptop_adapter.a[1].im := sin(laptop_adapter.argAdj[1])

--- Solved equation ---
laptop_adapter.loadBase.i[2].im := laptop_adapter.c[1] * laptop_adapter.a[1].im

--- Solved equation ---
laptop_adapter.c[2] := laptop_adapter.magScale * 0.9221155376813399

--- Solved equation ---
laptop_adapter.argAdj[2] := 0.5364901833841553 + (- laptop_adapter.V_arg[1] .* systemDef.hrms[3])

--- Solved equation ---
laptop_adapter.a[2].re := cos(laptop_adapter.argAdj[2])

--- Solved equation ---
laptop_adapter.loadBase.i[3].re := laptop_adapter.c[2] * laptop_adapter.a[2].re

--- Solved equation ---
laptop_adapter.a[2].im := sin(laptop_adapter.argAdj[2])

--- Solved equation ---
laptop_adapter.loadBase.i[3].im := laptop_adapter.c[2] * laptop_adapter.a[2].im

--- Meta equation block ---
algorithm


--- Solved equation ---
laptop_adapter.loadBase.omega := der(v.theta)

--- Solved equation ---
ground1.pin.iRe[2] := 0

--- Solved equation ---
ground1.pin.iIm[2] := 0

--- Torn linear system (Block 2) of 2 iteration variables and 5 solved variables ---
Coefficient variability: parameter
Torn variables:
  v.i[2].im
  v.i[2].re
  z.v[2].im
  z.v[2].re
  z1.v[2].re

Iteration variables:
  z1.i[2].im
  z1.i[2].re

Torn equations:
  v.i[2].im := ground1.pin.iIm[2] - laptop_adapter.loadBase.i[2].im - z1.i[2].im
  v.i[2].re := ground1.pin.iRe[2] - laptop_adapter.loadBase.i[2].re - z1.i[2].re
  z.v[2].im := z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re)
  z.v[2].re := z.z.re .* (- v.i[2].re) + (- z.z.im .* systemDef.hrms[2] .* (- v.i[2].im))
  z1.v[2].re := - z.v[2].re + 0.001

Residual equations:
  - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re
    Iteration variables: z1.i[2].im
  z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im
    Iteration variables: z1.i[2].re

Jacobian:
  |-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0|
  |0.0, -1.0, 0.0, 0.0, 0.0, 0.0, -1.0|
  |z.z.re, z.z.im .* systemDef.hrms[2], 1.0, 0.0, 0.0, 0.0, 0.0|
  |- z.z.im .* systemDef.hrms[2], z.z.re, 0.0, 1.0, 0.0, 0.0, 0.0|
  |0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0|
  |0.0, 0.0, -1.0, 0.0, 0.0, - z1.z.re, - z1.z.im .* systemDef.hrms[2]|
  |0.0, 0.0, 0.0, 0.0, 1.0, z1.z.im .* systemDef.hrms[2], - z1.z.re|

--- Solved equation ---
ground1.pin.iRe[3] := 0

--- Solved equation ---
ground1.pin.iIm[3] := 0

--- Torn linear system (Block 3) of 2 iteration variables and 5 solved variables ---
Coefficient variability: parameter
Torn variables:
  v.i[3].im
  v.i[3].re
  z.v[3].im
  z.v[3].re
  z1.v[3].re

Iteration variables:
  z1.i[3].im
  z1.i[3].re

Torn equations:
  v.i[3].im := ground1.pin.iIm[3] - laptop_adapter.loadBase.i[3].im - z1.i[3].im
  v.i[3].re := ground1.pin.iRe[3] - laptop_adapter.loadBase.i[3].re - z1.i[3].re
  z.v[3].im := z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re)
  z.v[3].re := z.z.re .* (- v.i[3].re) + (- z.z.im .* systemDef.hrms[3] .* (- v.i[3].im))
  z1.v[3].re := - z.v[3].re + 0.001

Residual equations:
  - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re
    Iteration variables: z1.i[3].im
  z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im
    Iteration variables: z1.i[3].re

Jacobian:
  |-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0|
  |0.0, -1.0, 0.0, 0.0, 0.0, 0.0, -1.0|
  |z.z.re, z.z.im .* systemDef.hrms[3], 1.0, 0.0, 0.0, 0.0, 0.0|
  |- z.z.im .* systemDef.hrms[3], z.z.re, 0.0, 1.0, 0.0, 0.0, 0.0|
  |0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0|
  |0.0, 0.0, -1.0, 0.0, 0.0, - z1.z.re, - z1.z.im .* systemDef.hrms[3]|
  |0.0, 0.0, 0.0, 0.0, 1.0, z1.z.im .* systemDef.hrms[3], - z1.z.re|

--- Solved equation ---
z.omega := der(v.theta)

--- Solved equation ---
z1.omega := der(v.theta)

--- Meta equation block ---
HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))

--- Meta equation block ---
HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))

--- Solved equation ---
v.P1 := 120.0 * v.i[1].re

--- Solved equation ---
v.iMag[1] := (v.i[1].re ^ 2 + v.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
v.iMag[2] := (v.i[2].re ^ 2 + v.i[2].im ^ 2) ^ 0.5

--- Solved equation ---
v.iMag[3] := (v.i[3].re ^ 2 + v.i[3].im ^ 2) ^ 0.5

--- Solved equation ---
v.iArg[1] := Modelica.Math.atan3(v.i[1].im, v.i[1].re, 0)

--- Solved equation ---
v.iArg[2] := Modelica.Math.atan3(v.i[2].im, v.i[2].re, 0)

--- Solved equation ---
v.iArg[3] := Modelica.Math.atan3(v.i[3].im, v.i[3].re, 0)

--- Solved equation ---
laptop_adapter.I_mag[1] := (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.I_mag[2] := (laptop_adapter.loadBase.i[2].re ^ 2 + laptop_adapter.loadBase.i[2].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.I_mag[3] := (laptop_adapter.loadBase.i[3].re ^ 2 + laptop_adapter.loadBase.i[3].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.I_arg[1] := Modelica.Math.atan3(laptop_adapter.loadBase.i[1].im, laptop_adapter.loadBase.i[1].re, 0)

--- Solved equation ---
laptop_adapter.I_arg[2] := Modelica.Math.atan3(laptop_adapter.loadBase.i[2].im, laptop_adapter.loadBase.i[2].re, 0)

--- Solved equation ---
laptop_adapter.I_arg[3] := Modelica.Math.atan3(laptop_adapter.loadBase.i[3].im, laptop_adapter.loadBase.i[3].re, 0)

--- Solved equation ---
laptop_adapter.V_mag[1] := (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.V_mag[2] := (z1.v[2].re ^ 2 + (- z.v[2].im) ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.V_mag[3] := (z1.v[3].re ^ 2 + (- z.v[3].im) ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.V_arg[2] := Modelica.Math.atan3(- z.v[2].im, z1.v[2].re, 0)

--- Solved equation ---
laptop_adapter.V_arg[3] := Modelica.Math.atan3(- z.v[3].im, z1.v[3].re, 0)

--- Solved equation ---
z.vFundAbs := (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5

--- Solved equation ---
z.vFundArg := Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0)

--- Solved equation ---
z.iFundAbs := ((- v.i[1].re) ^ 2 + (- v.i[1].im) ^ 2) ^ 0.5

--- Solved equation ---
z.iFundArg := Modelica.Math.atan3(- v.i[1].im, - v.i[1].re, 0)

--- Solved equation ---
z1.vFundAbs := (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5

--- Solved equation ---
z1.iFundAbs := (z1.i[1].re ^ 2 + z1.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
z1.iFundArg := Modelica.Math.atan3(z1.i[1].im, z1.i[1].re, 0)
-------------------------------

BiPGraph (77 equations, 74 variables)
Variables: {der(v.theta) v.P1 v.iMag[1] v.iMag[2] v.iMag[3] v.iArg[1] v.iArg[2] v.iArg[3] v.i[1].re v.i[1].im v.i[2].re v.i[2].im v.i[3].re v.i[3].im v.omega ground1.pin.iIm[1] ground1.pin.iIm[2] ground1.pin.iIm[3] ground1.pin.iRe[1] ground1.pin.iRe[2] ground1.pin.iRe[3] laptop_adapter.loadBase.i[1].re laptop_adapter.loadBase.i[1].im laptop_adapter.loadBase.i[2].re laptop_adapter.loadBase.i[2].im laptop_adapter.loadBase.i[3].re laptop_adapter.loadBase.i[3].im laptop_adapter.loadBase.omega laptop_adapter.I_mag[1] laptop_adapter.I_mag[2] laptop_adapter.I_mag[3] laptop_adapter.I_arg[1] laptop_adapter.I_arg[2] laptop_adapter.I_arg[3] laptop_adapter.V_mag[1] laptop_adapter.V_mag[2] laptop_adapter.V_mag[3] laptop_adapter.V_arg[1] laptop_adapter.V_arg[2] laptop_adapter.V_arg[3] laptop_adapter.magScale laptop_adapter.argAdj[1] laptop_adapter.argAdj[2] laptop_adapter.a[1].re laptop_adapter.a[1].im laptop_adapter.a[2].re laptop_adapter.a[2].im laptop_adapter.c[1] laptop_adapter.c[2] z.vFundAbs z.vFundArg z.iFundAbs z.iFundArg z.v[1].re z.v[1].im z.v[2].re z.v[2].im z.v[3].re z.v[3].im z.omega z1.vFundAbs z1.iFundAbs z1.iFundArg z1.v[1].re z1.v[2].re z1.v[3].re z1.i[1].re z1.i[1].im z1.i[2].re z1.i[2].im z1.i[3].re z1.i[3].im z1.omega v.theta }
eq_1 : // algorithm

eq_2 : der(v.theta)@M // der(v.theta) = 6.283185307179586 * systemDef.fFund
eq_3 : v.omega@M der(v.theta)@ // v.omega = der(v.theta)
eq_4 : z1.v[1].re@ laptop_adapter.loadBase.i[1].re@M z.v[1].im@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im)
eq_5 : z1.v[1].re@ laptop_adapter.loadBase.i[1].im@M z.v[1].im@ laptop_adapter.loadBase.i[1].re@ // laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re
eq_6 : laptop_adapter.loadBase.i[2].re@M laptop_adapter.c[1]@ laptop_adapter.a[1].re@ // laptop_adapter.loadBase.i[2].re = laptop_adapter.c[1] * laptop_adapter.a[1].re
eq_7 : laptop_adapter.loadBase.i[2].im@M laptop_adapter.c[1]@ laptop_adapter.a[1].im@ // laptop_adapter.loadBase.i[2].im = laptop_adapter.c[1] * laptop_adapter.a[1].im
eq_8 : laptop_adapter.loadBase.i[3].re@M laptop_adapter.c[2]@ laptop_adapter.a[2].re@ // laptop_adapter.loadBase.i[3].re = laptop_adapter.c[2] * laptop_adapter.a[2].re
eq_9 : laptop_adapter.loadBase.i[3].im@M laptop_adapter.c[2]@ laptop_adapter.a[2].im@ // laptop_adapter.loadBase.i[3].im = laptop_adapter.c[2] * laptop_adapter.a[2].im
eq_10 : // algorithm

eq_11 : laptop_adapter.loadBase.omega@M der(v.theta)@ // laptop_adapter.loadBase.omega = der(v.theta)
eq_12 : z.v[1].re@M v.i[1].re@ v.i[1].im@ // z.v[1].re = z.z.re .* (- v.i[1].re) - z.z.im .* systemDef.hrms[1] .* (- v.i[1].im)
eq_13 : z.v[2].re@M v.i[2].re@ v.i[2].im@ // z.v[2].re = z.z.re .* (- v.i[2].re) - z.z.im .* systemDef.hrms[2] .* (- v.i[2].im)
eq_14 : z.v[3].re@M v.i[3].re@ v.i[3].im@ // z.v[3].re = z.z.re .* (- v.i[3].re) - z.z.im .* systemDef.hrms[3] .* (- v.i[3].im)
eq_15 : z.v[1].im@M v.i[1].im@ v.i[1].re@ // z.v[1].im = z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re)
eq_16 : z.v[2].im@M v.i[2].im@ v.i[2].re@ // z.v[2].im = z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re)
eq_17 : z.v[3].im@M v.i[3].im@ v.i[3].re@ // z.v[3].im = z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re)
eq_18 : z.omega@M der(v.theta)@ // z.omega = der(v.theta)
eq_19 : z.v[1].re@ z1.v[1].re@M // z.v[1].re = 120.0 - z1.v[1].re
eq_20 : z.v[2].re@ z1.v[2].re@M // z.v[2].re = 0.001 - z1.v[2].re
eq_21 : z.v[3].re@ z1.v[3].re@M // z.v[3].re = 0.001 - z1.v[3].re
eq_22 : z1.v[1].re@ z1.i[1].re@M z1.i[1].im@ // z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im
eq_23 : z1.v[2].re@ z1.i[2].re@M z1.i[2].im@ // z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im
eq_24 : z1.v[3].re@ z1.i[3].re@M z1.i[3].im@ // z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im
eq_25 : z.v[1].im@ z1.i[1].im@M z1.i[1].re@ // - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re
eq_26 : z.v[2].im@ z1.i[2].im@M z1.i[2].re@ // - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re
eq_27 : z.v[3].im@ z1.i[3].im@M z1.i[3].re@ // - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re
eq_28 : z1.omega@M der(v.theta)@ // z1.omega = der(v.theta)
eq_29 : ground1.pin.iIm[1]@ laptop_adapter.loadBase.i[1].im@ v.i[1].im@M z1.i[1].im@ // ground1.pin.iIm[1] + (- laptop_adapter.loadBase.i[1].im) + (- v.i[1].im) + (- z1.i[1].im) = 0
eq_30 : ground1.pin.iIm[2]@ laptop_adapter.loadBase.i[2].im@ v.i[2].im@M z1.i[2].im@ // ground1.pin.iIm[2] + (- laptop_adapter.loadBase.i[2].im) + (- v.i[2].im) + (- z1.i[2].im) = 0
eq_31 : ground1.pin.iIm[3]@ laptop_adapter.loadBase.i[3].im@ v.i[3].im@M z1.i[3].im@ // ground1.pin.iIm[3] + (- laptop_adapter.loadBase.i[3].im) + (- v.i[3].im) + (- z1.i[3].im) = 0
eq_32 : ground1.pin.iRe[1]@ laptop_adapter.loadBase.i[1].re@ v.i[1].re@M z1.i[1].re@ // ground1.pin.iRe[1] + (- laptop_adapter.loadBase.i[1].re) + (- v.i[1].re) + (- z1.i[1].re) = 0
eq_33 : ground1.pin.iRe[2]@ laptop_adapter.loadBase.i[2].re@ v.i[2].re@M z1.i[2].re@ // ground1.pin.iRe[2] + (- laptop_adapter.loadBase.i[2].re) + (- v.i[2].re) + (- z1.i[2].re) = 0
eq_34 : ground1.pin.iRe[3]@ laptop_adapter.loadBase.i[3].re@ v.i[3].re@M z1.i[3].re@ // ground1.pin.iRe[3] + (- laptop_adapter.loadBase.i[3].re) + (- v.i[3].re) + (- z1.i[3].re) = 0
eq_35 : ground1.pin.iIm[1]@M // 0 = ground1.pin.iIm[1]
eq_36 : ground1.pin.iIm[2]@M // 0 = ground1.pin.iIm[2]
eq_37 : ground1.pin.iIm[3]@M // 0 = ground1.pin.iIm[3]
eq_38 : ground1.pin.iRe[1]@M // 0 = ground1.pin.iRe[1]
eq_39 : ground1.pin.iRe[2]@M // 0 = ground1.pin.iRe[2]
eq_40 : ground1.pin.iRe[3]@M // 0 = ground1.pin.iRe[3]
eq_41 : v.theta# // HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))
eq_42 : v.theta# // HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))
eq_43 : v.P1@M v.i[1].re@ // v.P1 = 120.0 * v.i[1].re
eq_44 : v.iMag[1]@M v.i[1].re@ v.i[1].im@ // v.iMag[1] = (v.i[1].re ^ 2 + v.i[1].im ^ 2) ^ 0.5
eq_45 : v.iMag[2]@M v.i[2].re@ v.i[2].im@ // v.iMag[2] = (v.i[2].re ^ 2 + v.i[2].im ^ 2) ^ 0.5
eq_46 : v.iMag[3]@M v.i[3].re@ v.i[3].im@ // v.iMag[3] = (v.i[3].re ^ 2 + v.i[3].im ^ 2) ^ 0.5
eq_47 : v.iArg[1]@M v.i[1].im@ v.i[1].re@ // v.iArg[1] = Modelica.Math.atan3(v.i[1].im, v.i[1].re, 0)
eq_48 : v.iArg[2]@M v.i[2].im@ v.i[2].re@ // v.iArg[2] = Modelica.Math.atan3(v.i[2].im, v.i[2].re, 0)
eq_49 : v.iArg[3]@M v.i[3].im@ v.i[3].re@ // v.iArg[3] = Modelica.Math.atan3(v.i[3].im, v.i[3].re, 0)
eq_50 : laptop_adapter.I_mag[1]@M laptop_adapter.loadBase.i[1].re@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.I_mag[1] = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5
eq_51 : laptop_adapter.I_mag[2]@M laptop_adapter.loadBase.i[2].re@ laptop_adapter.loadBase.i[2].im@ // laptop_adapter.I_mag[2] = (laptop_adapter.loadBase.i[2].re ^ 2 + laptop_adapter.loadBase.i[2].im ^ 2) ^ 0.5
eq_52 : laptop_adapter.I_mag[3]@M laptop_adapter.loadBase.i[3].re@ laptop_adapter.loadBase.i[3].im@ // laptop_adapter.I_mag[3] = (laptop_adapter.loadBase.i[3].re ^ 2 + laptop_adapter.loadBase.i[3].im ^ 2) ^ 0.5
eq_53 : laptop_adapter.I_arg[1]@M laptop_adapter.loadBase.i[1].im@ laptop_adapter.loadBase.i[1].re@ // laptop_adapter.I_arg[1] = Modelica.Math.atan3(laptop_adapter.loadBase.i[1].im, laptop_adapter.loadBase.i[1].re, 0)
eq_54 : laptop_adapter.I_arg[2]@M laptop_adapter.loadBase.i[2].im@ laptop_adapter.loadBase.i[2].re@ // laptop_adapter.I_arg[2] = Modelica.Math.atan3(laptop_adapter.loadBase.i[2].im, laptop_adapter.loadBase.i[2].re, 0)
eq_55 : laptop_adapter.I_arg[3]@M laptop_adapter.loadBase.i[3].im@ laptop_adapter.loadBase.i[3].re@ // laptop_adapter.I_arg[3] = Modelica.Math.atan3(laptop_adapter.loadBase.i[3].im, laptop_adapter.loadBase.i[3].re, 0)
eq_56 : laptop_adapter.V_mag[1]@M z1.v[1].re@ z.v[1].im@ // laptop_adapter.V_mag[1] = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5
eq_57 : laptop_adapter.V_mag[2]@M z1.v[2].re@ z.v[2].im@ // laptop_adapter.V_mag[2] = (z1.v[2].re ^ 2 + (- z.v[2].im) ^ 2) ^ 0.5
eq_58 : laptop_adapter.V_mag[3]@M z1.v[3].re@ z.v[3].im@ // laptop_adapter.V_mag[3] = (z1.v[3].re ^ 2 + (- z.v[3].im) ^ 2) ^ 0.5
eq_59 : laptop_adapter.V_arg[2]@M z.v[2].im@ z1.v[2].re@ // laptop_adapter.V_arg[2] = Modelica.Math.atan3(- z.v[2].im, z1.v[2].re, 0)
eq_60 : laptop_adapter.V_arg[3]@M z.v[3].im@ z1.v[3].re@ // laptop_adapter.V_arg[3] = Modelica.Math.atan3(- z.v[3].im, z1.v[3].re, 0)
eq_61 : laptop_adapter.magScale@M laptop_adapter.loadBase.i[1].re@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.magScale = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5
eq_62 : laptop_adapter.argAdj[1]@M laptop_adapter.V_arg[1]@ // laptop_adapter.argAdj[1] = -2.8182357929499515 - laptop_adapter.V_arg[1] .* systemDef.hrms[2]
eq_63 : laptop_adapter.argAdj[2]@M laptop_adapter.V_arg[1]@ // laptop_adapter.argAdj[2] = 0.5364901833841553 - laptop_adapter.V_arg[1] .* systemDef.hrms[3]
eq_64 : laptop_adapter.a[1].re@M laptop_adapter.argAdj[1]@ // laptop_adapter.a[1].re = cos(laptop_adapter.argAdj[1])
eq_65 : laptop_adapter.a[1].im@M laptop_adapter.argAdj[1]@ // laptop_adapter.a[1].im = sin(laptop_adapter.argAdj[1])
eq_66 : laptop_adapter.a[2].re@M laptop_adapter.argAdj[2]@ // laptop_adapter.a[2].re = cos(laptop_adapter.argAdj[2])
eq_67 : laptop_adapter.a[2].im@M laptop_adapter.argAdj[2]@ // laptop_adapter.a[2].im = sin(laptop_adapter.argAdj[2])
eq_68 : laptop_adapter.c[1]@M laptop_adapter.magScale@ // laptop_adapter.c[1] = laptop_adapter.magScale * 0.9486974344201337
eq_69 : laptop_adapter.c[2]@M laptop_adapter.magScale@ // laptop_adapter.c[2] = laptop_adapter.magScale * 0.9221155376813399
eq_70 : z.vFundAbs@M z.v[1].re@ z.v[1].im@ // z.vFundAbs = (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5
eq_71 : z.vFundArg@M z.v[1].im@ z.v[1].re@ // z.vFundArg = Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0)
eq_72 : z.iFundAbs@M v.i[1].re@ v.i[1].im@ // z.iFundAbs = ((- v.i[1].re) ^ 2 + (- v.i[1].im) ^ 2) ^ 0.5
eq_73 : z.iFundArg@M v.i[1].im@ v.i[1].re@ // z.iFundArg = Modelica.Math.atan3(- v.i[1].im, - v.i[1].re, 0)
eq_74 : z1.vFundAbs@M z1.v[1].re@ z.v[1].im@ // z1.vFundAbs = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5
eq_75 : z1.iFundAbs@M z1.i[1].re@ z1.i[1].im@ // z1.iFundAbs = (z1.i[1].re ^ 2 + z1.i[1].im ^ 2) ^ 0.5
eq_76 : z1.iFundArg@M z1.i[1].im@ z1.i[1].re@ // z1.iFundArg = Modelica.Math.atan3(z1.i[1].im, z1.i[1].re, 0)
eq_77 : laptop_adapter.V_arg[1]@M z.v[1].im@ z1.v[1].re@ // laptop_adapter.V_arg[1] = Modelica.Math.atan3(- z.v[1].im, z1.v[1].re, 0)

Init DAE BiPGraph
BiPGraph (78 equations, 74 variables)
Variables: {der(v.theta) v.P1 v.iMag[1] v.iMag[2] v.iMag[3] v.iArg[1] v.iArg[2] v.iArg[3] v.i[1].re v.i[1].im v.i[2].re v.i[2].im v.i[3].re v.i[3].im v.omega ground1.pin.iIm[1] ground1.pin.iIm[2] ground1.pin.iIm[3] ground1.pin.iRe[1] ground1.pin.iRe[2] ground1.pin.iRe[3] laptop_adapter.loadBase.i[1].re laptop_adapter.loadBase.i[1].im laptop_adapter.loadBase.i[2].re laptop_adapter.loadBase.i[2].im laptop_adapter.loadBase.i[3].re laptop_adapter.loadBase.i[3].im laptop_adapter.loadBase.omega laptop_adapter.I_mag[1] laptop_adapter.I_mag[2] laptop_adapter.I_mag[3] laptop_adapter.I_arg[1] laptop_adapter.I_arg[2] laptop_adapter.I_arg[3] laptop_adapter.V_mag[1] laptop_adapter.V_mag[2] laptop_adapter.V_mag[3] laptop_adapter.V_arg[1] laptop_adapter.V_arg[2] laptop_adapter.V_arg[3] laptop_adapter.magScale laptop_adapter.argAdj[1] laptop_adapter.argAdj[2] laptop_adapter.a[1].re laptop_adapter.a[1].im laptop_adapter.a[2].re laptop_adapter.a[2].im laptop_adapter.c[1] laptop_adapter.c[2] z.vFundAbs z.vFundArg z.iFundAbs z.iFundArg z.v[1].re z.v[1].im z.v[2].re z.v[2].im z.v[3].re z.v[3].im z.omega z1.vFundAbs z1.iFundAbs z1.iFundArg z1.v[1].re z1.v[2].re z1.v[3].re z1.i[1].re z1.i[1].im z1.i[2].re z1.i[2].im z1.i[3].re z1.i[3].im z1.omega v.theta }
eq_1 : // algorithm

eq_2 : der(v.theta)@M // der(v.theta) = 6.283185307179586 * systemDef.fFund
eq_3 : v.omega@M der(v.theta)@ // v.omega = der(v.theta)
eq_4 : z1.v[1].re@ laptop_adapter.loadBase.i[1].re@M z.v[1].im@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im)
eq_5 : z1.v[1].re@ laptop_adapter.loadBase.i[1].im@M z.v[1].im@ laptop_adapter.loadBase.i[1].re@ // laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re
eq_6 : laptop_adapter.loadBase.i[2].re@M laptop_adapter.c[1]@ laptop_adapter.a[1].re@ // laptop_adapter.loadBase.i[2].re = laptop_adapter.c[1] * laptop_adapter.a[1].re
eq_7 : laptop_adapter.loadBase.i[2].im@M laptop_adapter.c[1]@ laptop_adapter.a[1].im@ // laptop_adapter.loadBase.i[2].im = laptop_adapter.c[1] * laptop_adapter.a[1].im
eq_8 : laptop_adapter.loadBase.i[3].re@M laptop_adapter.c[2]@ laptop_adapter.a[2].re@ // laptop_adapter.loadBase.i[3].re = laptop_adapter.c[2] * laptop_adapter.a[2].re
eq_9 : laptop_adapter.loadBase.i[3].im@M laptop_adapter.c[2]@ laptop_adapter.a[2].im@ // laptop_adapter.loadBase.i[3].im = laptop_adapter.c[2] * laptop_adapter.a[2].im
eq_10 : // algorithm

eq_11 : laptop_adapter.loadBase.omega@M der(v.theta)@ // laptop_adapter.loadBase.omega = der(v.theta)
eq_12 : z.v[1].re@M v.i[1].re@ v.i[1].im@ // z.v[1].re = z.z.re .* (- v.i[1].re) - z.z.im .* systemDef.hrms[1] .* (- v.i[1].im)
eq_13 : z.v[2].re@M v.i[2].re@ v.i[2].im@ // z.v[2].re = z.z.re .* (- v.i[2].re) - z.z.im .* systemDef.hrms[2] .* (- v.i[2].im)
eq_14 : z.v[3].re@M v.i[3].re@ v.i[3].im@ // z.v[3].re = z.z.re .* (- v.i[3].re) - z.z.im .* systemDef.hrms[3] .* (- v.i[3].im)
eq_15 : z.v[1].im@M v.i[1].im@ v.i[1].re@ // z.v[1].im = z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re)
eq_16 : z.v[2].im@M v.i[2].im@ v.i[2].re@ // z.v[2].im = z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re)
eq_17 : z.v[3].im@M v.i[3].im@ v.i[3].re@ // z.v[3].im = z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re)
eq_18 : z.omega@M der(v.theta)@ // z.omega = der(v.theta)
eq_19 : z.v[1].re@ z1.v[1].re@M // z.v[1].re = 120.0 - z1.v[1].re
eq_20 : z.v[2].re@ z1.v[2].re@M // z.v[2].re = 0.001 - z1.v[2].re
eq_21 : z.v[3].re@ z1.v[3].re@M // z.v[3].re = 0.001 - z1.v[3].re
eq_22 : z1.v[1].re@ z1.i[1].re@M z1.i[1].im@ // z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im
eq_23 : z1.v[2].re@ z1.i[2].re@M z1.i[2].im@ // z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im
eq_24 : z1.v[3].re@ z1.i[3].re@M z1.i[3].im@ // z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im
eq_25 : z.v[1].im@ z1.i[1].im@M z1.i[1].re@ // - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re
eq_26 : z.v[2].im@ z1.i[2].im@M z1.i[2].re@ // - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re
eq_27 : z.v[3].im@ z1.i[3].im@M z1.i[3].re@ // - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re
eq_28 : z1.omega@M der(v.theta)@ // z1.omega = der(v.theta)
eq_29 : ground1.pin.iIm[1]@ laptop_adapter.loadBase.i[1].im@ v.i[1].im@M z1.i[1].im@ // ground1.pin.iIm[1] + (- laptop_adapter.loadBase.i[1].im) + (- v.i[1].im) + (- z1.i[1].im) = 0
eq_30 : ground1.pin.iIm[2]@ laptop_adapter.loadBase.i[2].im@ v.i[2].im@M z1.i[2].im@ // ground1.pin.iIm[2] + (- laptop_adapter.loadBase.i[2].im) + (- v.i[2].im) + (- z1.i[2].im) = 0
eq_31 : ground1.pin.iIm[3]@ laptop_adapter.loadBase.i[3].im@ v.i[3].im@M z1.i[3].im@ // ground1.pin.iIm[3] + (- laptop_adapter.loadBase.i[3].im) + (- v.i[3].im) + (- z1.i[3].im) = 0
eq_32 : ground1.pin.iRe[1]@ laptop_adapter.loadBase.i[1].re@ v.i[1].re@M z1.i[1].re@ // ground1.pin.iRe[1] + (- laptop_adapter.loadBase.i[1].re) + (- v.i[1].re) + (- z1.i[1].re) = 0
eq_33 : ground1.pin.iRe[2]@ laptop_adapter.loadBase.i[2].re@ v.i[2].re@M z1.i[2].re@ // ground1.pin.iRe[2] + (- laptop_adapter.loadBase.i[2].re) + (- v.i[2].re) + (- z1.i[2].re) = 0
eq_34 : ground1.pin.iRe[3]@ laptop_adapter.loadBase.i[3].re@ v.i[3].re@M z1.i[3].re@ // ground1.pin.iRe[3] + (- laptop_adapter.loadBase.i[3].re) + (- v.i[3].re) + (- z1.i[3].re) = 0
eq_35 : ground1.pin.iIm[1]@M // 0 = ground1.pin.iIm[1]
eq_36 : ground1.pin.iIm[2]@M // 0 = ground1.pin.iIm[2]
eq_37 : ground1.pin.iIm[3]@M // 0 = ground1.pin.iIm[3]
eq_38 : ground1.pin.iRe[1]@M // 0 = ground1.pin.iRe[1]
eq_39 : ground1.pin.iRe[2]@M // 0 = ground1.pin.iRe[2]
eq_40 : ground1.pin.iRe[3]@M // 0 = ground1.pin.iRe[3]
eq_41 : v.theta# // HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))
eq_42 : v.theta# // HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))
eq_43 : v.P1@M v.i[1].re@ // v.P1 = 120.0 * v.i[1].re
eq_44 : v.iMag[1]@M v.i[1].re@ v.i[1].im@ // v.iMag[1] = (v.i[1].re ^ 2 + v.i[1].im ^ 2) ^ 0.5
eq_45 : v.iMag[2]@M v.i[2].re@ v.i[2].im@ // v.iMag[2] = (v.i[2].re ^ 2 + v.i[2].im ^ 2) ^ 0.5
eq_46 : v.iMag[3]@M v.i[3].re@ v.i[3].im@ // v.iMag[3] = (v.i[3].re ^ 2 + v.i[3].im ^ 2) ^ 0.5
eq_47 : v.iArg[1]@M v.i[1].im@ v.i[1].re@ // v.iArg[1] = Modelica.Math.atan3(v.i[1].im, v.i[1].re, 0)
eq_48 : v.iArg[2]@M v.i[2].im@ v.i[2].re@ // v.iArg[2] = Modelica.Math.atan3(v.i[2].im, v.i[2].re, 0)
eq_49 : v.iArg[3]@M v.i[3].im@ v.i[3].re@ // v.iArg[3] = Modelica.Math.atan3(v.i[3].im, v.i[3].re, 0)
eq_50 : laptop_adapter.I_mag[1]@M laptop_adapter.loadBase.i[1].re@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.I_mag[1] = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5
eq_51 : laptop_adapter.I_mag[2]@M laptop_adapter.loadBase.i[2].re@ laptop_adapter.loadBase.i[2].im@ // laptop_adapter.I_mag[2] = (laptop_adapter.loadBase.i[2].re ^ 2 + laptop_adapter.loadBase.i[2].im ^ 2) ^ 0.5
eq_52 : laptop_adapter.I_mag[3]@M laptop_adapter.loadBase.i[3].re@ laptop_adapter.loadBase.i[3].im@ // laptop_adapter.I_mag[3] = (laptop_adapter.loadBase.i[3].re ^ 2 + laptop_adapter.loadBase.i[3].im ^ 2) ^ 0.5
eq_53 : laptop_adapter.I_arg[1]@M laptop_adapter.loadBase.i[1].im@ laptop_adapter.loadBase.i[1].re@ // laptop_adapter.I_arg[1] = Modelica.Math.atan3(laptop_adapter.loadBase.i[1].im, laptop_adapter.loadBase.i[1].re, 0)
eq_54 : laptop_adapter.I_arg[2]@M laptop_adapter.loadBase.i[2].im@ laptop_adapter.loadBase.i[2].re@ // laptop_adapter.I_arg[2] = Modelica.Math.atan3(laptop_adapter.loadBase.i[2].im, laptop_adapter.loadBase.i[2].re, 0)
eq_55 : laptop_adapter.I_arg[3]@M laptop_adapter.loadBase.i[3].im@ laptop_adapter.loadBase.i[3].re@ // laptop_adapter.I_arg[3] = Modelica.Math.atan3(laptop_adapter.loadBase.i[3].im, laptop_adapter.loadBase.i[3].re, 0)
eq_56 : laptop_adapter.V_mag[1]@M z1.v[1].re@ z.v[1].im@ // laptop_adapter.V_mag[1] = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5
eq_57 : laptop_adapter.V_mag[2]@M z1.v[2].re@ z.v[2].im@ // laptop_adapter.V_mag[2] = (z1.v[2].re ^ 2 + (- z.v[2].im) ^ 2) ^ 0.5
eq_58 : laptop_adapter.V_mag[3]@M z1.v[3].re@ z.v[3].im@ // laptop_adapter.V_mag[3] = (z1.v[3].re ^ 2 + (- z.v[3].im) ^ 2) ^ 0.5
eq_59 : laptop_adapter.V_arg[2]@M z.v[2].im@ z1.v[2].re@ // laptop_adapter.V_arg[2] = Modelica.Math.atan3(- z.v[2].im, z1.v[2].re, 0)
eq_60 : laptop_adapter.V_arg[3]@M z.v[3].im@ z1.v[3].re@ // laptop_adapter.V_arg[3] = Modelica.Math.atan3(- z.v[3].im, z1.v[3].re, 0)
eq_61 : laptop_adapter.magScale@M laptop_adapter.loadBase.i[1].re@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.magScale = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5
eq_62 : laptop_adapter.argAdj[1]@M laptop_adapter.V_arg[1]@ // laptop_adapter.argAdj[1] = -2.8182357929499515 - laptop_adapter.V_arg[1] .* systemDef.hrms[2]
eq_63 : laptop_adapter.argAdj[2]@M laptop_adapter.V_arg[1]@ // laptop_adapter.argAdj[2] = 0.5364901833841553 - laptop_adapter.V_arg[1] .* systemDef.hrms[3]
eq_64 : laptop_adapter.a[1].re@M laptop_adapter.argAdj[1]@ // laptop_adapter.a[1].re = cos(laptop_adapter.argAdj[1])
eq_65 : laptop_adapter.a[1].im@M laptop_adapter.argAdj[1]@ // laptop_adapter.a[1].im = sin(laptop_adapter.argAdj[1])
eq_66 : laptop_adapter.a[2].re@M laptop_adapter.argAdj[2]@ // laptop_adapter.a[2].re = cos(laptop_adapter.argAdj[2])
eq_67 : laptop_adapter.a[2].im@M laptop_adapter.argAdj[2]@ // laptop_adapter.a[2].im = sin(laptop_adapter.argAdj[2])
eq_68 : laptop_adapter.c[1]@M laptop_adapter.magScale@ // laptop_adapter.c[1] = laptop_adapter.magScale * 0.9486974344201337
eq_69 : laptop_adapter.c[2]@M laptop_adapter.magScale@ // laptop_adapter.c[2] = laptop_adapter.magScale * 0.9221155376813399
eq_70 : z.vFundAbs@M z.v[1].re@ z.v[1].im@ // z.vFundAbs = (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5
eq_71 : z.vFundArg@M z.v[1].im@ z.v[1].re@ // z.vFundArg = Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0)
eq_72 : z.iFundAbs@M v.i[1].re@ v.i[1].im@ // z.iFundAbs = ((- v.i[1].re) ^ 2 + (- v.i[1].im) ^ 2) ^ 0.5
eq_73 : z.iFundArg@M v.i[1].im@ v.i[1].re@ // z.iFundArg = Modelica.Math.atan3(- v.i[1].im, - v.i[1].re, 0)
eq_74 : z1.vFundAbs@M z1.v[1].re@ z.v[1].im@ // z1.vFundAbs = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5
eq_75 : z1.iFundAbs@M z1.i[1].re@ z1.i[1].im@ // z1.iFundAbs = (z1.i[1].re ^ 2 + z1.i[1].im ^ 2) ^ 0.5
eq_76 : z1.iFundArg@M z1.i[1].im@ z1.i[1].re@ // z1.iFundArg = Modelica.Math.atan3(z1.i[1].im, z1.i[1].re, 0)
eq_77 : laptop_adapter.V_arg[1]@M z.v[1].im@ z1.v[1].re@ // laptop_adapter.V_arg[1] = Modelica.Math.atan3(- z.v[1].im, z1.v[1].re, 0)
eq_78 : // algorithm


Init BiPGraph matching
----------------------------------------
BiPGraph matching:
eq_2 : der(v.theta)
eq_3 : v.omega
eq_4 : laptop_adapter.loadBase.i[1].re
eq_5 : laptop_adapter.loadBase.i[1].im
eq_6 : laptop_adapter.loadBase.i[2].re
eq_7 : laptop_adapter.loadBase.i[2].im
eq_8 : laptop_adapter.loadBase.i[3].re
eq_9 : laptop_adapter.loadBase.i[3].im
eq_11 : laptop_adapter.loadBase.omega
eq_12 : z.v[1].re
eq_13 : z.v[2].re
eq_14 : z.v[3].re
eq_15 : z.v[1].im
eq_16 : z.v[2].im
eq_17 : z.v[3].im
eq_18 : z.omega
eq_19 : z1.v[1].re
eq_20 : z1.v[2].re
eq_21 : z1.v[3].re
eq_22 : z1.i[1].re
eq_23 : z1.i[2].re
eq_24 : z1.i[3].re
eq_25 : z1.i[1].im
eq_26 : z1.i[2].im
eq_27 : z1.i[3].im
eq_28 : z1.omega
eq_29 : v.i[1].im
eq_30 : v.i[2].im
eq_31 : v.i[3].im
eq_32 : v.i[1].re
eq_33 : v.i[2].re
eq_34 : v.i[3].re
eq_35 : ground1.pin.iIm[1]
eq_36 : ground1.pin.iIm[2]
eq_37 : ground1.pin.iIm[3]
eq_38 : ground1.pin.iRe[1]
eq_39 : ground1.pin.iRe[2]
eq_40 : ground1.pin.iRe[3]
eq_43 : v.P1
eq_44 : v.iMag[1]
eq_45 : v.iMag[2]
eq_46 : v.iMag[3]
eq_47 : v.iArg[1]
eq_48 : v.iArg[2]
eq_49 : v.iArg[3]
eq_50 : laptop_adapter.I_mag[1]
eq_51 : laptop_adapter.I_mag[2]
eq_52 : laptop_adapter.I_mag[3]
eq_53 : laptop_adapter.I_arg[1]
eq_54 : laptop_adapter.I_arg[2]
eq_55 : laptop_adapter.I_arg[3]
eq_56 : laptop_adapter.V_mag[1]
eq_57 : laptop_adapter.V_mag[2]
eq_58 : laptop_adapter.V_mag[3]
eq_59 : laptop_adapter.V_arg[2]
eq_60 : laptop_adapter.V_arg[3]
eq_61 : laptop_adapter.magScale
eq_62 : laptop_adapter.argAdj[1]
eq_63 : laptop_adapter.argAdj[2]
eq_64 : laptop_adapter.a[1].re
eq_65 : laptop_adapter.a[1].im
eq_66 : laptop_adapter.a[2].re
eq_67 : laptop_adapter.a[2].im
eq_68 : laptop_adapter.c[1]
eq_69 : laptop_adapter.c[2]
eq_70 : z.vFundAbs
eq_71 : z.vFundArg
eq_72 : z.iFundAbs
eq_73 : z.iFundArg
eq_74 : z1.vFundAbs
eq_75 : z1.iFundAbs
eq_76 : z1.iFundArg
eq_77 : laptop_adapter.V_arg[1]
Unmatched equations: {}
Unmatched variables: {v.theta }
----------------------------------------

Analysing initial system for redundant equations to remove.
All seems to be ok!
Init DAE BiPGraph after addition of initial equations
BiPGraph (79 equations, 74 variables)
Variables: {der(v.theta) v.P1 v.iMag[1] v.iMag[2] v.iMag[3] v.iArg[1] v.iArg[2] v.iArg[3] v.i[1].re v.i[1].im v.i[2].re v.i[2].im v.i[3].re v.i[3].im v.omega ground1.pin.iIm[1] ground1.pin.iIm[2] ground1.pin.iIm[3] ground1.pin.iRe[1] ground1.pin.iRe[2] ground1.pin.iRe[3] laptop_adapter.loadBase.i[1].re laptop_adapter.loadBase.i[1].im laptop_adapter.loadBase.i[2].re laptop_adapter.loadBase.i[2].im laptop_adapter.loadBase.i[3].re laptop_adapter.loadBase.i[3].im laptop_adapter.loadBase.omega laptop_adapter.I_mag[1] laptop_adapter.I_mag[2] laptop_adapter.I_mag[3] laptop_adapter.I_arg[1] laptop_adapter.I_arg[2] laptop_adapter.I_arg[3] laptop_adapter.V_mag[1] laptop_adapter.V_mag[2] laptop_adapter.V_mag[3] laptop_adapter.V_arg[1] laptop_adapter.V_arg[2] laptop_adapter.V_arg[3] laptop_adapter.magScale laptop_adapter.argAdj[1] laptop_adapter.argAdj[2] laptop_adapter.a[1].re laptop_adapter.a[1].im laptop_adapter.a[2].re laptop_adapter.a[2].im laptop_adapter.c[1] laptop_adapter.c[2] z.vFundAbs z.vFundArg z.iFundAbs z.iFundArg z.v[1].re z.v[1].im z.v[2].re z.v[2].im z.v[3].re z.v[3].im z.omega z1.vFundAbs z1.iFundAbs z1.iFundArg z1.v[1].re z1.v[2].re z1.v[3].re z1.i[1].re z1.i[1].im z1.i[2].re z1.i[2].im z1.i[3].re z1.i[3].im z1.omega v.theta }
eq_1 : // algorithm

eq_2 : der(v.theta)@M // der(v.theta) = 6.283185307179586 * systemDef.fFund
eq_3 : v.omega@M der(v.theta)@ // v.omega = der(v.theta)
eq_4 : z1.v[1].re@ laptop_adapter.loadBase.i[1].re@M z.v[1].im@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im)
eq_5 : z1.v[1].re@ laptop_adapter.loadBase.i[1].im@M z.v[1].im@ laptop_adapter.loadBase.i[1].re@ // laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re
eq_6 : laptop_adapter.loadBase.i[2].re@M laptop_adapter.c[1]@ laptop_adapter.a[1].re@ // laptop_adapter.loadBase.i[2].re = laptop_adapter.c[1] * laptop_adapter.a[1].re
eq_7 : laptop_adapter.loadBase.i[2].im@M laptop_adapter.c[1]@ laptop_adapter.a[1].im@ // laptop_adapter.loadBase.i[2].im = laptop_adapter.c[1] * laptop_adapter.a[1].im
eq_8 : laptop_adapter.loadBase.i[3].re@M laptop_adapter.c[2]@ laptop_adapter.a[2].re@ // laptop_adapter.loadBase.i[3].re = laptop_adapter.c[2] * laptop_adapter.a[2].re
eq_9 : laptop_adapter.loadBase.i[3].im@M laptop_adapter.c[2]@ laptop_adapter.a[2].im@ // laptop_adapter.loadBase.i[3].im = laptop_adapter.c[2] * laptop_adapter.a[2].im
eq_10 : // algorithm

eq_11 : laptop_adapter.loadBase.omega@M der(v.theta)@ // laptop_adapter.loadBase.omega = der(v.theta)
eq_12 : z.v[1].re@M v.i[1].re@ v.i[1].im@ // z.v[1].re = z.z.re .* (- v.i[1].re) - z.z.im .* systemDef.hrms[1] .* (- v.i[1].im)
eq_13 : z.v[2].re@M v.i[2].re@ v.i[2].im@ // z.v[2].re = z.z.re .* (- v.i[2].re) - z.z.im .* systemDef.hrms[2] .* (- v.i[2].im)
eq_14 : z.v[3].re@M v.i[3].re@ v.i[3].im@ // z.v[3].re = z.z.re .* (- v.i[3].re) - z.z.im .* systemDef.hrms[3] .* (- v.i[3].im)
eq_15 : z.v[1].im@M v.i[1].im@ v.i[1].re@ // z.v[1].im = z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re)
eq_16 : z.v[2].im@M v.i[2].im@ v.i[2].re@ // z.v[2].im = z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re)
eq_17 : z.v[3].im@M v.i[3].im@ v.i[3].re@ // z.v[3].im = z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re)
eq_18 : z.omega@M der(v.theta)@ // z.omega = der(v.theta)
eq_19 : z.v[1].re@ z1.v[1].re@M // z.v[1].re = 120.0 - z1.v[1].re
eq_20 : z.v[2].re@ z1.v[2].re@M // z.v[2].re = 0.001 - z1.v[2].re
eq_21 : z.v[3].re@ z1.v[3].re@M // z.v[3].re = 0.001 - z1.v[3].re
eq_22 : z1.v[1].re@ z1.i[1].re@M z1.i[1].im@ // z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im
eq_23 : z1.v[2].re@ z1.i[2].re@M z1.i[2].im@ // z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im
eq_24 : z1.v[3].re@ z1.i[3].re@M z1.i[3].im@ // z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im
eq_25 : z.v[1].im@ z1.i[1].im@M z1.i[1].re@ // - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re
eq_26 : z.v[2].im@ z1.i[2].im@M z1.i[2].re@ // - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re
eq_27 : z.v[3].im@ z1.i[3].im@M z1.i[3].re@ // - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re
eq_28 : z1.omega@M der(v.theta)@ // z1.omega = der(v.theta)
eq_29 : ground1.pin.iIm[1]@ laptop_adapter.loadBase.i[1].im@ v.i[1].im@M z1.i[1].im@ // ground1.pin.iIm[1] + (- laptop_adapter.loadBase.i[1].im) + (- v.i[1].im) + (- z1.i[1].im) = 0
eq_30 : ground1.pin.iIm[2]@ laptop_adapter.loadBase.i[2].im@ v.i[2].im@M z1.i[2].im@ // ground1.pin.iIm[2] + (- laptop_adapter.loadBase.i[2].im) + (- v.i[2].im) + (- z1.i[2].im) = 0
eq_31 : ground1.pin.iIm[3]@ laptop_adapter.loadBase.i[3].im@ v.i[3].im@M z1.i[3].im@ // ground1.pin.iIm[3] + (- laptop_adapter.loadBase.i[3].im) + (- v.i[3].im) + (- z1.i[3].im) = 0
eq_32 : ground1.pin.iRe[1]@ laptop_adapter.loadBase.i[1].re@ v.i[1].re@M z1.i[1].re@ // ground1.pin.iRe[1] + (- laptop_adapter.loadBase.i[1].re) + (- v.i[1].re) + (- z1.i[1].re) = 0
eq_33 : ground1.pin.iRe[2]@ laptop_adapter.loadBase.i[2].re@ v.i[2].re@M z1.i[2].re@ // ground1.pin.iRe[2] + (- laptop_adapter.loadBase.i[2].re) + (- v.i[2].re) + (- z1.i[2].re) = 0
eq_34 : ground1.pin.iRe[3]@ laptop_adapter.loadBase.i[3].re@ v.i[3].re@M z1.i[3].re@ // ground1.pin.iRe[3] + (- laptop_adapter.loadBase.i[3].re) + (- v.i[3].re) + (- z1.i[3].re) = 0
eq_35 : ground1.pin.iIm[1]@M // 0 = ground1.pin.iIm[1]
eq_36 : ground1.pin.iIm[2]@M // 0 = ground1.pin.iIm[2]
eq_37 : ground1.pin.iIm[3]@M // 0 = ground1.pin.iIm[3]
eq_38 : ground1.pin.iRe[1]@M // 0 = ground1.pin.iRe[1]
eq_39 : ground1.pin.iRe[2]@M // 0 = ground1.pin.iRe[2]
eq_40 : ground1.pin.iRe[3]@M // 0 = ground1.pin.iRe[3]
eq_41 : v.theta# // HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))
eq_42 : v.theta# // HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))
eq_43 : v.P1@M v.i[1].re@ // v.P1 = 120.0 * v.i[1].re
eq_44 : v.iMag[1]@M v.i[1].re@ v.i[1].im@ // v.iMag[1] = (v.i[1].re ^ 2 + v.i[1].im ^ 2) ^ 0.5
eq_45 : v.iMag[2]@M v.i[2].re@ v.i[2].im@ // v.iMag[2] = (v.i[2].re ^ 2 + v.i[2].im ^ 2) ^ 0.5
eq_46 : v.iMag[3]@M v.i[3].re@ v.i[3].im@ // v.iMag[3] = (v.i[3].re ^ 2 + v.i[3].im ^ 2) ^ 0.5
eq_47 : v.iArg[1]@M v.i[1].im@ v.i[1].re@ // v.iArg[1] = Modelica.Math.atan3(v.i[1].im, v.i[1].re, 0)
eq_48 : v.iArg[2]@M v.i[2].im@ v.i[2].re@ // v.iArg[2] = Modelica.Math.atan3(v.i[2].im, v.i[2].re, 0)
eq_49 : v.iArg[3]@M v.i[3].im@ v.i[3].re@ // v.iArg[3] = Modelica.Math.atan3(v.i[3].im, v.i[3].re, 0)
eq_50 : laptop_adapter.I_mag[1]@M laptop_adapter.loadBase.i[1].re@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.I_mag[1] = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5
eq_51 : laptop_adapter.I_mag[2]@M laptop_adapter.loadBase.i[2].re@ laptop_adapter.loadBase.i[2].im@ // laptop_adapter.I_mag[2] = (laptop_adapter.loadBase.i[2].re ^ 2 + laptop_adapter.loadBase.i[2].im ^ 2) ^ 0.5
eq_52 : laptop_adapter.I_mag[3]@M laptop_adapter.loadBase.i[3].re@ laptop_adapter.loadBase.i[3].im@ // laptop_adapter.I_mag[3] = (laptop_adapter.loadBase.i[3].re ^ 2 + laptop_adapter.loadBase.i[3].im ^ 2) ^ 0.5
eq_53 : laptop_adapter.I_arg[1]@M laptop_adapter.loadBase.i[1].im@ laptop_adapter.loadBase.i[1].re@ // laptop_adapter.I_arg[1] = Modelica.Math.atan3(laptop_adapter.loadBase.i[1].im, laptop_adapter.loadBase.i[1].re, 0)
eq_54 : laptop_adapter.I_arg[2]@M laptop_adapter.loadBase.i[2].im@ laptop_adapter.loadBase.i[2].re@ // laptop_adapter.I_arg[2] = Modelica.Math.atan3(laptop_adapter.loadBase.i[2].im, laptop_adapter.loadBase.i[2].re, 0)
eq_55 : laptop_adapter.I_arg[3]@M laptop_adapter.loadBase.i[3].im@ laptop_adapter.loadBase.i[3].re@ // laptop_adapter.I_arg[3] = Modelica.Math.atan3(laptop_adapter.loadBase.i[3].im, laptop_adapter.loadBase.i[3].re, 0)
eq_56 : laptop_adapter.V_mag[1]@M z1.v[1].re@ z.v[1].im@ // laptop_adapter.V_mag[1] = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5
eq_57 : laptop_adapter.V_mag[2]@M z1.v[2].re@ z.v[2].im@ // laptop_adapter.V_mag[2] = (z1.v[2].re ^ 2 + (- z.v[2].im) ^ 2) ^ 0.5
eq_58 : laptop_adapter.V_mag[3]@M z1.v[3].re@ z.v[3].im@ // laptop_adapter.V_mag[3] = (z1.v[3].re ^ 2 + (- z.v[3].im) ^ 2) ^ 0.5
eq_59 : laptop_adapter.V_arg[2]@M z.v[2].im@ z1.v[2].re@ // laptop_adapter.V_arg[2] = Modelica.Math.atan3(- z.v[2].im, z1.v[2].re, 0)
eq_60 : laptop_adapter.V_arg[3]@M z.v[3].im@ z1.v[3].re@ // laptop_adapter.V_arg[3] = Modelica.Math.atan3(- z.v[3].im, z1.v[3].re, 0)
eq_61 : laptop_adapter.magScale@M laptop_adapter.loadBase.i[1].re@ laptop_adapter.loadBase.i[1].im@ // laptop_adapter.magScale = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5
eq_62 : laptop_adapter.argAdj[1]@M laptop_adapter.V_arg[1]@ // laptop_adapter.argAdj[1] = -2.8182357929499515 - laptop_adapter.V_arg[1] .* systemDef.hrms[2]
eq_63 : laptop_adapter.argAdj[2]@M laptop_adapter.V_arg[1]@ // laptop_adapter.argAdj[2] = 0.5364901833841553 - laptop_adapter.V_arg[1] .* systemDef.hrms[3]
eq_64 : laptop_adapter.a[1].re@M laptop_adapter.argAdj[1]@ // laptop_adapter.a[1].re = cos(laptop_adapter.argAdj[1])
eq_65 : laptop_adapter.a[1].im@M laptop_adapter.argAdj[1]@ // laptop_adapter.a[1].im = sin(laptop_adapter.argAdj[1])
eq_66 : laptop_adapter.a[2].re@M laptop_adapter.argAdj[2]@ // laptop_adapter.a[2].re = cos(laptop_adapter.argAdj[2])
eq_67 : laptop_adapter.a[2].im@M laptop_adapter.argAdj[2]@ // laptop_adapter.a[2].im = sin(laptop_adapter.argAdj[2])
eq_68 : laptop_adapter.c[1]@M laptop_adapter.magScale@ // laptop_adapter.c[1] = laptop_adapter.magScale * 0.9486974344201337
eq_69 : laptop_adapter.c[2]@M laptop_adapter.magScale@ // laptop_adapter.c[2] = laptop_adapter.magScale * 0.9221155376813399
eq_70 : z.vFundAbs@M z.v[1].re@ z.v[1].im@ // z.vFundAbs = (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5
eq_71 : z.vFundArg@M z.v[1].im@ z.v[1].re@ // z.vFundArg = Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0)
eq_72 : z.iFundAbs@M v.i[1].re@ v.i[1].im@ // z.iFundAbs = ((- v.i[1].re) ^ 2 + (- v.i[1].im) ^ 2) ^ 0.5
eq_73 : z.iFundArg@M v.i[1].im@ v.i[1].re@ // z.iFundArg = Modelica.Math.atan3(- v.i[1].im, - v.i[1].re, 0)
eq_74 : z1.vFundAbs@M z1.v[1].re@ z.v[1].im@ // z1.vFundAbs = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5
eq_75 : z1.iFundAbs@M z1.i[1].re@ z1.i[1].im@ // z1.iFundAbs = (z1.i[1].re ^ 2 + z1.i[1].im ^ 2) ^ 0.5
eq_76 : z1.iFundArg@M z1.i[1].im@ z1.i[1].re@ // z1.iFundArg = Modelica.Math.atan3(z1.i[1].im, z1.i[1].re, 0)
eq_77 : laptop_adapter.V_arg[1]@M z.v[1].im@ z1.v[1].re@ // laptop_adapter.V_arg[1] = Modelica.Math.atan3(- z.v[1].im, z1.v[1].re, 0)
eq_78 : // algorithm

eq_79 : v.theta@M // v.theta = 0

Init BiPGraph matching after addition of initial equations
----------------------------------------
BiPGraph matching:
eq_2 : der(v.theta)
eq_3 : v.omega
eq_4 : laptop_adapter.loadBase.i[1].re
eq_5 : laptop_adapter.loadBase.i[1].im
eq_6 : laptop_adapter.loadBase.i[2].re
eq_7 : laptop_adapter.loadBase.i[2].im
eq_8 : laptop_adapter.loadBase.i[3].re
eq_9 : laptop_adapter.loadBase.i[3].im
eq_11 : laptop_adapter.loadBase.omega
eq_12 : z.v[1].re
eq_13 : z.v[2].re
eq_14 : z.v[3].re
eq_15 : z.v[1].im
eq_16 : z.v[2].im
eq_17 : z.v[3].im
eq_18 : z.omega
eq_19 : z1.v[1].re
eq_20 : z1.v[2].re
eq_21 : z1.v[3].re
eq_22 : z1.i[1].re
eq_23 : z1.i[2].re
eq_24 : z1.i[3].re
eq_25 : z1.i[1].im
eq_26 : z1.i[2].im
eq_27 : z1.i[3].im
eq_28 : z1.omega
eq_29 : v.i[1].im
eq_30 : v.i[2].im
eq_31 : v.i[3].im
eq_32 : v.i[1].re
eq_33 : v.i[2].re
eq_34 : v.i[3].re
eq_35 : ground1.pin.iIm[1]
eq_36 : ground1.pin.iIm[2]
eq_37 : ground1.pin.iIm[3]
eq_38 : ground1.pin.iRe[1]
eq_39 : ground1.pin.iRe[2]
eq_40 : ground1.pin.iRe[3]
eq_43 : v.P1
eq_44 : v.iMag[1]
eq_45 : v.iMag[2]
eq_46 : v.iMag[3]
eq_47 : v.iArg[1]
eq_48 : v.iArg[2]
eq_49 : v.iArg[3]
eq_50 : laptop_adapter.I_mag[1]
eq_51 : laptop_adapter.I_mag[2]
eq_52 : laptop_adapter.I_mag[3]
eq_53 : laptop_adapter.I_arg[1]
eq_54 : laptop_adapter.I_arg[2]
eq_55 : laptop_adapter.I_arg[3]
eq_56 : laptop_adapter.V_mag[1]
eq_57 : laptop_adapter.V_mag[2]
eq_58 : laptop_adapter.V_mag[3]
eq_59 : laptop_adapter.V_arg[2]
eq_60 : laptop_adapter.V_arg[3]
eq_61 : laptop_adapter.magScale
eq_62 : laptop_adapter.argAdj[1]
eq_63 : laptop_adapter.argAdj[2]
eq_64 : laptop_adapter.a[1].re
eq_65 : laptop_adapter.a[1].im
eq_66 : laptop_adapter.a[2].re
eq_67 : laptop_adapter.a[2].im
eq_68 : laptop_adapter.c[1]
eq_69 : laptop_adapter.c[2]
eq_70 : z.vFundAbs
eq_71 : z.vFundArg
eq_72 : z.iFundAbs
eq_73 : z.iFundArg
eq_74 : z1.vFundAbs
eq_75 : z1.iFundAbs
eq_76 : z1.iFundArg
eq_77 : laptop_adapter.V_arg[1]
eq_79 : v.theta
Unmatched equations: {}
Unmatched variables: {}
----------------------------------------

Initial system contains homotopy, computing homotopy block components...
... block components computed: []
Starting automatic tearing
BiPGraph (9 equations, 9 variables)
Variables: {laptop_adapter.loadBase.i[1].im v.i[1].im z.v[1].im z1.i[1].im z1.i[1].re v.i[1].re z.v[1].re z1.v[1].re laptop_adapter.loadBase.i[1].re }
eq_5 : z1.v[1].re# laptop_adapter.loadBase.i[1].im# z.v[1].im# laptop_adapter.loadBase.i[1].re# // laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re
eq_29 : laptop_adapter.loadBase.i[1].im@ v.i[1].im@M z1.i[1].im@ // ground1.pin.iIm[1] + (- laptop_adapter.loadBase.i[1].im) + (- v.i[1].im) + (- z1.i[1].im) = 0
eq_15 : z.v[1].im@M v.i[1].im# v.i[1].re# // z.v[1].im = z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re)
eq_25 : z.v[1].im@ z1.i[1].im# z1.i[1].re# // - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re
eq_22 : z1.v[1].re@ z1.i[1].re# z1.i[1].im# // z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im
eq_32 : laptop_adapter.loadBase.i[1].re@ v.i[1].re@M z1.i[1].re@ // ground1.pin.iRe[1] + (- laptop_adapter.loadBase.i[1].re) + (- v.i[1].re) + (- z1.i[1].re) = 0
eq_12 : z.v[1].re@M v.i[1].re# v.i[1].im# // z.v[1].re = z.z.re .* (- v.i[1].re) - z.z.im .* systemDef.hrms[1] .* (- v.i[1].im)
eq_19 : z.v[1].re@ z1.v[1].re@M // z.v[1].re = 120.0 - z1.v[1].re
eq_4 : z1.v[1].re# laptop_adapter.loadBase.i[1].re# z.v[1].im# laptop_adapter.loadBase.i[1].im# // laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im)

Initial matching
----------------------------------------
BiPGraph matching:
eq_29 : v.i[1].im
eq_15 : z.v[1].im
eq_32 : v.i[1].re
eq_12 : z.v[1].re
eq_19 : z1.v[1].re
Unmatched equations: {eq_5 eq_25 eq_22 eq_4 }
Unmatched variables: {laptop_adapter.loadBase.i[1].im z1.i[1].im z1.i[1].re laptop_adapter.loadBase.i[1].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
eq_29 : v.i[1].im
eq_15 : z.v[1].im
eq_32 : v.i[1].re
eq_12 : z.v[1].re
eq_19 : z1.v[1].re
Unmatched equations: {eq_5 eq_25 eq_22 eq_4 }
Unmatched variables: {laptop_adapter.loadBase.i[1].im z1.i[1].im z1.i[1].re laptop_adapter.loadBase.i[1].re }
----------------------------------------

Automatic tearing pair, equation: laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re, tearing with variable: laptop_adapter.loadBase.i[1].im
Automatic tearing pair, equation: - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re, tearing with variable: z1.i[1].im
Automatic tearing pair, equation: z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im, tearing with variable: laptop_adapter.loadBase.i[1].re
Automatic tearing pair, equation: laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im), tearing with variable: z1.i[1].re
Starting automatic tearing
BiPGraph (7 equations, 7 variables)
Variables: {v.i[2].im z.v[2].im z1.i[2].im z1.v[2].re z1.i[2].re v.i[2].re z.v[2].re }
eq_30 : v.i[2].im@M z1.i[2].im@ // ground1.pin.iIm[2] + (- laptop_adapter.loadBase.i[2].im) + (- v.i[2].im) + (- z1.i[2].im) = 0
eq_16 : z.v[2].im@M v.i[2].im# v.i[2].re# // z.v[2].im = z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re)
eq_26 : z.v[2].im@ z1.i[2].im# z1.i[2].re# // - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re
eq_20 : z.v[2].re@ z1.v[2].re@M // z.v[2].re = 0.001 - z1.v[2].re
eq_23 : z1.v[2].re@ z1.i[2].re# z1.i[2].im# // z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im
eq_33 : v.i[2].re@M z1.i[2].re@ // ground1.pin.iRe[2] + (- laptop_adapter.loadBase.i[2].re) + (- v.i[2].re) + (- z1.i[2].re) = 0
eq_13 : z.v[2].re@M v.i[2].re# v.i[2].im# // z.v[2].re = z.z.re .* (- v.i[2].re) - z.z.im .* systemDef.hrms[2] .* (- v.i[2].im)

Initial matching
----------------------------------------
BiPGraph matching:
eq_30 : v.i[2].im
eq_16 : z.v[2].im
eq_20 : z1.v[2].re
eq_33 : v.i[2].re
eq_13 : z.v[2].re
Unmatched equations: {eq_26 eq_23 }
Unmatched variables: {z1.i[2].im z1.i[2].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
eq_30 : v.i[2].im
eq_16 : z.v[2].im
eq_20 : z1.v[2].re
eq_33 : v.i[2].re
eq_13 : z.v[2].re
Unmatched equations: {eq_26 eq_23 }
Unmatched variables: {z1.i[2].im z1.i[2].re }
----------------------------------------

Automatic tearing pair, equation: - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re, tearing with variable: z1.i[2].im
Automatic tearing pair, equation: z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im, tearing with variable: z1.i[2].re
Starting automatic tearing
BiPGraph (7 equations, 7 variables)
Variables: {v.i[3].im z.v[3].im z1.i[3].im z1.v[3].re z1.i[3].re v.i[3].re z.v[3].re }
eq_31 : v.i[3].im@M z1.i[3].im@ // ground1.pin.iIm[3] + (- laptop_adapter.loadBase.i[3].im) + (- v.i[3].im) + (- z1.i[3].im) = 0
eq_17 : z.v[3].im@M v.i[3].im# v.i[3].re# // z.v[3].im = z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re)
eq_27 : z.v[3].im@ z1.i[3].im# z1.i[3].re# // - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re
eq_21 : z.v[3].re@ z1.v[3].re@M // z.v[3].re = 0.001 - z1.v[3].re
eq_24 : z1.v[3].re@ z1.i[3].re# z1.i[3].im# // z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im
eq_34 : v.i[3].re@M z1.i[3].re@ // ground1.pin.iRe[3] + (- laptop_adapter.loadBase.i[3].re) + (- v.i[3].re) + (- z1.i[3].re) = 0
eq_14 : z.v[3].re@M v.i[3].re# v.i[3].im# // z.v[3].re = z.z.re .* (- v.i[3].re) - z.z.im .* systemDef.hrms[3] .* (- v.i[3].im)

Initial matching
----------------------------------------
BiPGraph matching:
eq_31 : v.i[3].im
eq_17 : z.v[3].im
eq_21 : z1.v[3].re
eq_34 : v.i[3].re
eq_14 : z.v[3].re
Unmatched equations: {eq_27 eq_24 }
Unmatched variables: {z1.i[3].im z1.i[3].re }
----------------------------------------

Matching after initial manipulation
----------------------------------------
BiPGraph matching:
eq_31 : v.i[3].im
eq_17 : z.v[3].im
eq_21 : z1.v[3].re
eq_34 : v.i[3].re
eq_14 : z.v[3].re
Unmatched equations: {eq_27 eq_24 }
Unmatched variables: {z1.i[3].im z1.i[3].re }
----------------------------------------

Automatic tearing pair, equation: - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re, tearing with variable: z1.i[3].im
Automatic tearing pair, equation: z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im, tearing with variable: z1.i[3].re
--- Meta equation block ---
algorithm


--- Solved equation ---
der(v.theta) := 6.283185307179586 * systemDef.fFund

--- Solved equation ---
v.omega := der(v.theta)

--- Solved equation ---
ground1.pin.iRe[1] := 0

--- Solved equation ---
ground1.pin.iIm[1] := 0

--- Torn system (Block 1) of 4 iteration variables and 5 solved variables ---
Torn variables:
  v.i[1].im
  v.i[1].re
  z.v[1].im
  z.v[1].re
  z1.v[1].re

Iteration variables:
  laptop_adapter.loadBase.i[1].im (start=0)
  z1.i[1].im (start=0)
  laptop_adapter.loadBase.i[1].re (start=0)
  z1.i[1].re (start=0)

Torn equations:
  v.i[1].im := ground1.pin.iIm[1] - laptop_adapter.loadBase.i[1].im - z1.i[1].im
  v.i[1].re := ground1.pin.iRe[1] - laptop_adapter.loadBase.i[1].re - z1.i[1].re
  z.v[1].im := z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re)
  z.v[1].re := z.z.re .* (- v.i[1].re) + (- z.z.im .* systemDef.hrms[1] .* (- v.i[1].im))
  z1.v[1].re := - z.v[1].re + 120.0

Residual equations:
  laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re
    Iteration variables: laptop_adapter.loadBase.i[1].im
  - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re
    Iteration variables: z1.i[1].im
  z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im
    Iteration variables: laptop_adapter.loadBase.i[1].re
  laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im)
    Iteration variables: z1.i[1].re

--- Solved equation ---
laptop_adapter.magScale := (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.c[1] := laptop_adapter.magScale * 0.9486974344201337

--- Solved equation ---
laptop_adapter.V_arg[1] := Modelica.Math.atan3(- z.v[1].im, z1.v[1].re, 0)

--- Solved equation ---
laptop_adapter.argAdj[1] := -2.8182357929499515 + (- laptop_adapter.V_arg[1] .* systemDef.hrms[2])

--- Solved equation ---
laptop_adapter.a[1].re := cos(laptop_adapter.argAdj[1])

--- Solved equation ---
laptop_adapter.loadBase.i[2].re := laptop_adapter.c[1] * laptop_adapter.a[1].re

--- Solved equation ---
laptop_adapter.a[1].im := sin(laptop_adapter.argAdj[1])

--- Solved equation ---
laptop_adapter.loadBase.i[2].im := laptop_adapter.c[1] * laptop_adapter.a[1].im

--- Solved equation ---
laptop_adapter.c[2] := laptop_adapter.magScale * 0.9221155376813399

--- Solved equation ---
laptop_adapter.argAdj[2] := 0.5364901833841553 + (- laptop_adapter.V_arg[1] .* systemDef.hrms[3])

--- Solved equation ---
laptop_adapter.a[2].re := cos(laptop_adapter.argAdj[2])

--- Solved equation ---
laptop_adapter.loadBase.i[3].re := laptop_adapter.c[2] * laptop_adapter.a[2].re

--- Solved equation ---
laptop_adapter.a[2].im := sin(laptop_adapter.argAdj[2])

--- Solved equation ---
laptop_adapter.loadBase.i[3].im := laptop_adapter.c[2] * laptop_adapter.a[2].im

--- Meta equation block ---
algorithm


--- Solved equation ---
laptop_adapter.loadBase.omega := der(v.theta)

--- Solved equation ---
ground1.pin.iRe[2] := 0

--- Solved equation ---
ground1.pin.iIm[2] := 0

--- Torn linear system (Block 2) of 2 iteration variables and 5 solved variables ---
Coefficient variability: parameter
Torn variables:
  v.i[2].im
  v.i[2].re
  z.v[2].im
  z.v[2].re
  z1.v[2].re

Iteration variables:
  z1.i[2].im
  z1.i[2].re

Torn equations:
  v.i[2].im := ground1.pin.iIm[2] - laptop_adapter.loadBase.i[2].im - z1.i[2].im
  v.i[2].re := ground1.pin.iRe[2] - laptop_adapter.loadBase.i[2].re - z1.i[2].re
  z.v[2].im := z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re)
  z.v[2].re := z.z.re .* (- v.i[2].re) + (- z.z.im .* systemDef.hrms[2] .* (- v.i[2].im))
  z1.v[2].re := - z.v[2].re + 0.001

Residual equations:
  - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re
    Iteration variables: z1.i[2].im
  z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im
    Iteration variables: z1.i[2].re

Jacobian:
  |-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0|
  |0.0, -1.0, 0.0, 0.0, 0.0, 0.0, -1.0|
  |z.z.re, z.z.im .* systemDef.hrms[2], 1.0, 0.0, 0.0, 0.0, 0.0|
  |- z.z.im .* systemDef.hrms[2], z.z.re, 0.0, 1.0, 0.0, 0.0, 0.0|
  |0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0|
  |0.0, 0.0, -1.0, 0.0, 0.0, - z1.z.re, - z1.z.im .* systemDef.hrms[2]|
  |0.0, 0.0, 0.0, 0.0, 1.0, z1.z.im .* systemDef.hrms[2], - z1.z.re|

--- Solved equation ---
ground1.pin.iRe[3] := 0

--- Solved equation ---
ground1.pin.iIm[3] := 0

--- Torn linear system (Block 3) of 2 iteration variables and 5 solved variables ---
Coefficient variability: parameter
Torn variables:
  v.i[3].im
  v.i[3].re
  z.v[3].im
  z.v[3].re
  z1.v[3].re

Iteration variables:
  z1.i[3].im
  z1.i[3].re

Torn equations:
  v.i[3].im := ground1.pin.iIm[3] - laptop_adapter.loadBase.i[3].im - z1.i[3].im
  v.i[3].re := ground1.pin.iRe[3] - laptop_adapter.loadBase.i[3].re - z1.i[3].re
  z.v[3].im := z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re)
  z.v[3].re := z.z.re .* (- v.i[3].re) + (- z.z.im .* systemDef.hrms[3] .* (- v.i[3].im))
  z1.v[3].re := - z.v[3].re + 0.001

Residual equations:
  - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re
    Iteration variables: z1.i[3].im
  z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im
    Iteration variables: z1.i[3].re

Jacobian:
  |-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0|
  |0.0, -1.0, 0.0, 0.0, 0.0, 0.0, -1.0|
  |z.z.re, z.z.im .* systemDef.hrms[3], 1.0, 0.0, 0.0, 0.0, 0.0|
  |- z.z.im .* systemDef.hrms[3], z.z.re, 0.0, 1.0, 0.0, 0.0, 0.0|
  |0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0|
  |0.0, 0.0, -1.0, 0.0, 0.0, - z1.z.re, - z1.z.im .* systemDef.hrms[3]|
  |0.0, 0.0, 0.0, 0.0, 1.0, z1.z.im .* systemDef.hrms[3], - z1.z.re|

--- Solved equation ---
z.omega := der(v.theta)

--- Solved equation ---
z1.omega := der(v.theta)

--- Solved equation ---
v.theta := 0

--- Meta equation block ---
HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))

--- Meta equation block ---
HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta))

--- Solved equation ---
v.P1 := 120.0 * v.i[1].re

--- Solved equation ---
v.iMag[1] := (v.i[1].re ^ 2 + v.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
v.iMag[2] := (v.i[2].re ^ 2 + v.i[2].im ^ 2) ^ 0.5

--- Solved equation ---
v.iMag[3] := (v.i[3].re ^ 2 + v.i[3].im ^ 2) ^ 0.5

--- Solved equation ---
v.iArg[1] := Modelica.Math.atan3(v.i[1].im, v.i[1].re, 0)

--- Solved equation ---
v.iArg[2] := Modelica.Math.atan3(v.i[2].im, v.i[2].re, 0)

--- Solved equation ---
v.iArg[3] := Modelica.Math.atan3(v.i[3].im, v.i[3].re, 0)

--- Solved equation ---
laptop_adapter.I_mag[1] := (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.I_mag[2] := (laptop_adapter.loadBase.i[2].re ^ 2 + laptop_adapter.loadBase.i[2].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.I_mag[3] := (laptop_adapter.loadBase.i[3].re ^ 2 + laptop_adapter.loadBase.i[3].im ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.I_arg[1] := Modelica.Math.atan3(laptop_adapter.loadBase.i[1].im, laptop_adapter.loadBase.i[1].re, 0)

--- Solved equation ---
laptop_adapter.I_arg[2] := Modelica.Math.atan3(laptop_adapter.loadBase.i[2].im, laptop_adapter.loadBase.i[2].re, 0)

--- Solved equation ---
laptop_adapter.I_arg[3] := Modelica.Math.atan3(laptop_adapter.loadBase.i[3].im, laptop_adapter.loadBase.i[3].re, 0)

--- Solved equation ---
laptop_adapter.V_mag[1] := (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.V_mag[2] := (z1.v[2].re ^ 2 + (- z.v[2].im) ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.V_mag[3] := (z1.v[3].re ^ 2 + (- z.v[3].im) ^ 2) ^ 0.5

--- Solved equation ---
laptop_adapter.V_arg[2] := Modelica.Math.atan3(- z.v[2].im, z1.v[2].re, 0)

--- Solved equation ---
laptop_adapter.V_arg[3] := Modelica.Math.atan3(- z.v[3].im, z1.v[3].re, 0)

--- Solved equation ---
z.vFundAbs := (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5

--- Solved equation ---
z.vFundArg := Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0)

--- Solved equation ---
z.iFundAbs := ((- v.i[1].re) ^ 2 + (- v.i[1].im) ^ 2) ^ 0.5

--- Solved equation ---
z.iFundArg := Modelica.Math.atan3(- v.i[1].im, - v.i[1].re, 0)

--- Solved equation ---
z1.vFundAbs := (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5

--- Solved equation ---
z1.iFundAbs := (z1.i[1].re ^ 2 + z1.i[1].im ^ 2) ^ 0.5

--- Solved equation ---
z1.iFundArg := Modelica.Math.atan3(z1.i[1].im, z1.i[1].re, 0)

--- Meta equation block ---
algorithm

-------------------------------

Diagnostics for transformed flattened model:
Diagnostics for flattened class HPF.Test.Test_Rectifier
Number of independent constants:                   9(    9 scalars)
  Number of Real independent constants:            4(    4 scalars)
  Number of Real independent constants:            4(    4 scalars)
  Number of Integer independent constants:         0(    0 scalars)
  Number of Enum independent constants:            0(    0 scalars)
  Number of Boolean independent constants:         0(    0 scalars)
  Number of String independent constants:          5(    5 scalars)
Number of dependent constants:                     0(    0 scalars)
  Number of Real dependent constants:              0(    0 scalars)
  Number of Integer dependent constants:           0(    0 scalars)
  Number of Enum dependent constants:              0(    0 scalars)
  Number of Boolean dependent constants:           0(    0 scalars)
  Number of String dependent constants:            0(    0 scalars)
Number of independent parameters:                 92(   92 scalars)
  Number of Real independent parameters:          58(   58 scalars)
  Number of Integer independent parameters:       19(   19 scalars)
  Number of Enum independent parameters:           0(    0 scalars)
  Number of Boolean independent parameters:       13(   13 scalars)
  Number of String independent parameters:         2(    2 scalars)
Number of dependent parameters:                   42(   42 scalars)
  Number of Real dependent parameters:            39(   39 scalars)
  Number of Integer dependent parameters:          3(    3 scalars)
  Number of Enum dependent parameters:             0(    0 scalars)
  Number of Boolean dependent parameters:          0(    0 scalars)
  Number of String dependent parameters:           0(    0 scalars)
Number of initial parameters:                      0(    0 scalars)
  Number of Real dependent parameters:             0(    0 scalars)
  Number of Integer dependent parameters:          0(    0 scalars)
  Number of Enum dependent parameters:             0(    0 scalars)
  Number of Boolean dependent parameters:          0(    0 scalars)
  Number of String dependent parameters:           0(    0 scalars)
Number of variables:                              74(   74 scalars)
  Number of Real variables:                       74(   74 scalars)
  Number of Integer variables:                     0(    0 scalars)
  Number of Enum variables:                        0(    0 scalars)
  Number of Boolean variables:                     0(    0 scalars)
  Number of String variables:                      0(    0 scalars)
Number of Real differentiated variables:           1(    1 scalars)
Number of Real derivative variables:               1(    1 scalars)
Number of Real continous algebraic variables:     72(   72 scalars)
Number of inputs:                                  0(    0 scalars)
  Number of Real inputs:                           0(    0 scalars)
  Number of Integer inputs:                        0(    0 scalars)
  Number of Enum inputs:                           0(    0 scalars)
  Number of Boolean inputs:                        0(    0 scalars)
  Number of String inputs:                         0(    0 scalars)
Number of discrete variables:                      0(    0 scalars)
  Number of Real discrete variables:               0(    0 scalars)
  Number of Integer discrete variables:            0(    0 scalars)
  Number of Enum discrete variables:               0(    0 scalars)
  Number of Boolean discrete variables:            0(    0 scalars)
  Number of String discrete variables:             0(    0 scalars)
Number of equations:                              77(   73 scalars)
Number of variables with binding expression:       0(    0 scalars)
  Number of Real variables with binding exp:       0(    0 scalars)
  Number of Integer variables binding exp:         0(    0 scalars)
  Number of Enum variables binding exp:            0(    0 scalars)
  Number of Boolean variables binding exp:         0(    0 scalars)
  Number of String variables binding exp:          0(    0 scalars)
Total number of equations:                        77(   73 scalars)
Number of initial equations:                       2(    1 scalars)
Number of event indicators in equations:           0
Number of event indicators in init equations:      0

Independent constants: 
 v.v[1].re: number of uses: 0, isLinear: true
 v.v[1].im: number of uses: 0, isLinear: true
 v.v[2].re: number of uses: 0, isLinear: true
 laptop_adapter.argS: number of uses: 0, isLinear: true
 v.properties.ComponentType: number of uses: 0, isLinear: true
 ground1.properties.ComponentType: number of uses: 0, isLinear: true
 laptop_adapter.properties.ComponentType: number of uses: 0, isLinear: true
 laptop.properties.ComponentType: number of uses: 0, isLinear: true
 z.properties.ComponentType: number of uses: 0, isLinear: true

Dependent constants: 

Independent parameters: 
 systemDef.fFund: number of uses: 2, isLinear: true, evaluated binding exp: 60
 systemDef.fs: number of uses: 1, isLinear: true, evaluated binding exp: 10000.0
 laptop_adapter.V_Rect: number of uses: 1, isLinear: true, evaluated binding exp: 24
 laptop_adapter.efficiency: number of uses: 3, isLinear: true, evaluated binding exp: 0.9
 laptop_adapter.rectifierModel: number of uses: 0, isLinear: true, evaluated binding exp: 0
 laptop.pwr: number of uses: 1, isLinear: true, evaluated binding exp: 50
 z.z.re: number of uses: 6, isLinear: true, evaluated binding exp: 5.0
 z.z.im: number of uses: 6, isLinear: true, evaluated binding exp: 2.0
 z1.z.re: number of uses: 6, isLinear: true, evaluated binding exp: 5.0
 z1.z.im: number of uses: 6, isLinear: true, evaluated binding exp: 2.0
 _block_jacobian_check_tol: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-6
 _cs_rel_tol: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-6
 _cs_step_size: number of uses: 0, isLinear: true, evaluated binding exp: 0.001
 _events_default_tol: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-10
 _events_tol_factor: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-4
 _nle_jacobian_finite_difference_delta: number of uses: 0, isLinear: true, evaluated binding exp: 1.490116119384766E-8
 _nle_solver_default_tol: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-10
 _nle_solver_max_residual_scaling_factor: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E10
 _nle_solver_min_residual_scaling_factor: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-10
 _nle_solver_min_tol: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-12
 _nle_solver_regularization_tolerance: number of uses: 0, isLinear: true, evaluated binding exp: -1.0
 _nle_solver_step_limit_factor: number of uses: 0, isLinear: true, evaluated binding exp: 10.0
 _nle_solver_tol_factor: number of uses: 0, isLinear: true, evaluated binding exp: 1.0E-4
 _time_events_default_tol: number of uses: 0, isLinear: true, evaluated binding exp: 2.220446049250313E-14
 v.vMag[1]: number of uses: 0, isLinear: true, evaluated binding exp: 120
 v.vArg[1]: number of uses: 0, isLinear: true, evaluated binding exp: 0
 laptop_adapter.magDataMat[1,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.9999999999999999
 laptop_adapter.magDataMat[2,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.9486974344201337
 laptop_adapter.magDataMat[3,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.9221155376813399
 laptop_adapter.magDataMat[4,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.8849332521469448
 laptop_adapter.magDataMat[5,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.8475867045468796
 laptop_adapter.magDataMat[6,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.7944241839808487
 laptop_adapter.magDataMat[7,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.7230242274654483
 laptop_adapter.magDataMat[8,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.6688914048386135
 laptop_adapter.magDataMat[9,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.5939253865608557
 laptop_adapter.magDataMat[10,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.5280196623121391
 laptop_adapter.magDataMat[11,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.4568186887780485
 laptop_adapter.magDataMat[12,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.3861474201640431
 laptop_adapter.magDataMat[13,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.3163533253631282
 laptop_adapter.magDataMat[14,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.2534864723066213
 laptop_adapter.magDataMat[15,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.1920046370077911
 laptop_adapter.magDataMat[16,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.1442126307974456
 laptop_adapter.argDataMat[1,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.3053419323150846
 laptop_adapter.argDataMat[2,1]: number of uses: 0, isLinear: true, evaluated binding exp: -2.8182357929499515
 laptop_adapter.argDataMat[3,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.5364901833841553
 laptop_adapter.argDataMat[4,1]: number of uses: 0, isLinear: true, evaluated binding exp: -2.381193752481799
 laptop_adapter.argDataMat[5,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.9688071004089418
 laptop_adapter.argDataMat[6,1]: number of uses: 0, isLinear: true, evaluated binding exp: -1.959495555161772
 laptop_adapter.argDataMat[7,1]: number of uses: 0, isLinear: true, evaluated binding exp: 1.4013739855750704
 laptop_adapter.argDataMat[8,1]: number of uses: 0, isLinear: true, evaluated binding exp: -1.5329775105321843
 laptop_adapter.argDataMat[9,1]: number of uses: 0, isLinear: true, evaluated binding exp: 1.8276649690040103
 laptop_adapter.argDataMat[10,1]: number of uses: 0, isLinear: true, evaluated binding exp: -1.1106883983886444
 laptop_adapter.argDataMat[11,1]: number of uses: 0, isLinear: true, evaluated binding exp: 2.2426384598738585
 laptop_adapter.argDataMat[12,1]: number of uses: 0, isLinear: true, evaluated binding exp: -0.6809000975704675
 laptop_adapter.argDataMat[13,1]: number of uses: 0, isLinear: true, evaluated binding exp: 2.648460001811645
 laptop_adapter.argDataMat[14,1]: number of uses: 0, isLinear: true, evaluated binding exp: -0.2835615514742411
 laptop_adapter.argDataMat[15,1]: number of uses: 0, isLinear: true, evaluated binding exp: 3.0642644296286683
 laptop_adapter.argDataMat[16,1]: number of uses: 0, isLinear: true, evaluated binding exp: 0.0716470412434909
 systemDef.hrms[1]: number of uses: 4, isLinear: true, evaluated binding exp: 1
 systemDef.hrms[2]: number of uses: 5, isLinear: true, evaluated binding exp: 3
 systemDef.hrms[3]: number of uses: 5, isLinear: true, evaluated binding exp: 5
 systemDef.numPh: number of uses: 0, isLinear: true, evaluated binding exp: 3
 _block_solver_experimental_mode: number of uses: 0, isLinear: true, evaluated binding exp: 0
 _cs_experimental_mode: number of uses: 0, isLinear: true, evaluated binding exp: 0
 _cs_solver: number of uses: 0, isLinear: true, evaluated binding exp: 0
 _iteration_variable_scaling: number of uses: 0, isLinear: true, evaluated binding exp: 1
 _log_level: number of uses: 0, isLinear: true, evaluated binding exp: 3
 _nle_active_bounds_mode: number of uses: 0, isLinear: true, evaluated binding exp: 0
 _nle_jacobian_calculation_mode: number of uses: 0, isLinear: true, evaluated binding exp: 0
 _nle_jacobian_update_mode: number of uses: 0, isLinear: true, evaluated binding exp: 2
 _nle_solver_exit_criterion: number of uses: 0, isLinear: true, evaluated binding exp: 3
 _nle_solver_max_iter: number of uses: 0, isLinear: true, evaluated binding exp: 100
 _nle_solver_max_iter_no_jacobian: number of uses: 0, isLinear: true, evaluated binding exp: 10
 _residual_equation_scaling: number of uses: 0, isLinear: true, evaluated binding exp: 1
 systemDef.numHrm: number of uses: 0, isLinear: true, evaluated binding exp: 3
 laptop_adapter.matDim[1]: number of uses: 0, isLinear: true, evaluated binding exp: 16
 laptop_adapter.matDim[2]: number of uses: 0, isLinear: true, evaluated binding exp: 1
 _block_jacobian_check: number of uses: 0, isLinear: true, evaluated binding exp: false
 _block_solver_profiling: number of uses: 0, isLinear: true, evaluated binding exp: false
 _enforce_bounds: number of uses: 0, isLinear: true, evaluated binding exp: true
 _nle_brent_ignore_error: number of uses: 0, isLinear: true, evaluated binding exp: false
 _nle_solver_check_jac_cond: number of uses: 0, isLinear: true, evaluated binding exp: false
 _nle_solver_use_last_integrator_step: number of uses: 0, isLinear: true, evaluated binding exp: true
 _nle_solver_use_nominals_as_fallback: number of uses: 0, isLinear: true, evaluated binding exp: true
 _rescale_after_singular_jac: number of uses: 0, isLinear: true, evaluated binding exp: true
 _rescale_each_step: number of uses: 0, isLinear: true, evaluated binding exp: false
 _runtime_log_to_file: number of uses: 0, isLinear: true, evaluated binding exp: false
 _use_Brent_in_1d: number of uses: 0, isLinear: true, evaluated binding exp: true
 _use_jacobian_equilibration: number of uses: 0, isLinear: true, evaluated binding exp: false
 _use_newton_for_brent: number of uses: 0, isLinear: true, evaluated binding exp: true
 laptop_adapter.modelFileName: number of uses: 0, isLinear: true, evaluated binding exp: "HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat"
 laptop_adapter.resourceRetValue: number of uses: 0, isLinear: true, evaluated binding exp: "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat"

Dependent parameters: 
 temp_21[1,1]: number of uses: 2, isLinear: true
 temp_21[2,1]: number of uses: 2, isLinear: true
 temp_21[3,1]: number of uses: 2, isLinear: true
 temp_21[4,1]: number of uses: 2, isLinear: true
 temp_21[5,1]: number of uses: 2, isLinear: true
 temp_21[6,1]: number of uses: 2, isLinear: true
 temp_21[7,1]: number of uses: 2, isLinear: true
 temp_21[8,1]: number of uses: 2, isLinear: true
 temp_21[9,1]: number of uses: 2, isLinear: true
 temp_21[10,1]: number of uses: 2, isLinear: true
 temp_21[11,1]: number of uses: 2, isLinear: true
 temp_21[12,1]: number of uses: 2, isLinear: true
 temp_21[13,1]: number of uses: 2, isLinear: true
 temp_21[14,1]: number of uses: 2, isLinear: true
 temp_21[15,1]: number of uses: 2, isLinear: true
 temp_21[16,1]: number of uses: 2, isLinear: true
 temp_22[1,1]: number of uses: 2, isLinear: true
 temp_22[2,1]: number of uses: 2, isLinear: true
 temp_22[3,1]: number of uses: 2, isLinear: true
 temp_22[4,1]: number of uses: 2, isLinear: true
 temp_22[5,1]: number of uses: 2, isLinear: true
 temp_22[6,1]: number of uses: 2, isLinear: true
 temp_22[7,1]: number of uses: 2, isLinear: true
 temp_22[8,1]: number of uses: 2, isLinear: true
 temp_22[9,1]: number of uses: 2, isLinear: true
 temp_22[10,1]: number of uses: 2, isLinear: true
 temp_22[11,1]: number of uses: 2, isLinear: true
 temp_22[12,1]: number of uses: 2, isLinear: true
 temp_22[13,1]: number of uses: 2, isLinear: true
 temp_22[14,1]: number of uses: 2, isLinear: true
 temp_22[15,1]: number of uses: 2, isLinear: true
 temp_22[16,1]: number of uses: 2, isLinear: true
 laptop_adapter.vDC.V: number of uses: 3, isLinear: true
 laptop.i: number of uses: 4, isLinear: true
 ground2.p.i: number of uses: 1, isLinear: true
 laptop_adapter.P: number of uses: 4, isLinear: true
 laptop_adapter.S: number of uses: 2, isLinear: true
 laptop_adapter.PLoss: number of uses: 1, isLinear: true
 laptop_adapter.Q: number of uses: 2, isLinear: true
 temp_20[1]: number of uses: 2, isLinear: true
 temp_20[2]: number of uses: 2, isLinear: true
 systemDef.N: number of uses: 1, isLinear: true

Differentiated variables: 
 v.theta: number of uses: 5, isLinear: false

Derivative variables: 
 der(v.theta): number of uses: 5, isLinear: true

Discrete variables: 

Algebraic real variables: 
 v.P1: number of uses: 1, isLinear: true, alias: no
 v.iMag[1]: number of uses: 1, isLinear: true, alias: no
 v.iMag[2]: number of uses: 1, isLinear: true, alias: no
 v.iMag[3]: number of uses: 1, isLinear: true, alias: no
 v.iArg[1]: number of uses: 1, isLinear: true, alias: no
 v.iArg[2]: number of uses: 1, isLinear: true, alias: no
 v.iArg[3]: number of uses: 1, isLinear: true, alias: no
 v.i[1].re: number of uses: 8, isLinear: false, alias: no
 v.i[1].im: number of uses: 7, isLinear: false, alias: no
 v.i[2].re: number of uses: 5, isLinear: false, alias: no
 v.i[2].im: number of uses: 5, isLinear: false, alias: no
 v.i[3].re: number of uses: 5, isLinear: false, alias: no
 v.i[3].im: number of uses: 5, isLinear: false, alias: no
 v.omega: number of uses: 1, isLinear: true, alias: no
 ground1.pin.iIm[1]: number of uses: 2, isLinear: true, alias: no
 ground1.pin.iIm[2]: number of uses: 2, isLinear: true, alias: no
 ground1.pin.iIm[3]: number of uses: 2, isLinear: true, alias: no
 ground1.pin.iRe[1]: number of uses: 2, isLinear: true, alias: no
 ground1.pin.iRe[2]: number of uses: 2, isLinear: true, alias: no
 ground1.pin.iRe[3]: number of uses: 2, isLinear: true, alias: no
 laptop_adapter.loadBase.i[1].re: number of uses: 6, isLinear: false, alias: no
 laptop_adapter.loadBase.i[1].im: number of uses: 6, isLinear: false, alias: no
 laptop_adapter.loadBase.i[2].re: number of uses: 4, isLinear: false, alias: no
 laptop_adapter.loadBase.i[2].im: number of uses: 4, isLinear: false, alias: no
 laptop_adapter.loadBase.i[3].re: number of uses: 4, isLinear: false, alias: no
 laptop_adapter.loadBase.i[3].im: number of uses: 4, isLinear: false, alias: no
 laptop_adapter.loadBase.omega: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.I_mag[1]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.I_mag[2]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.I_mag[3]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.I_arg[1]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.I_arg[2]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.I_arg[3]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.V_mag[1]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.V_mag[2]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.V_mag[3]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.V_arg[1]: number of uses: 3, isLinear: true, alias: no
 laptop_adapter.V_arg[2]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.V_arg[3]: number of uses: 1, isLinear: true, alias: no
 laptop_adapter.magScale: number of uses: 3, isLinear: true, alias: no
 laptop_adapter.argAdj[1]: number of uses: 3, isLinear: false, alias: no
 laptop_adapter.argAdj[2]: number of uses: 3, isLinear: false, alias: no
 laptop_adapter.a[1].re: number of uses: 2, isLinear: false, alias: no
 laptop_adapter.a[1].im: number of uses: 2, isLinear: false, alias: no
 laptop_adapter.a[2].re: number of uses: 2, isLinear: false, alias: no
 laptop_adapter.a[2].im: number of uses: 2, isLinear: false, alias: no
 laptop_adapter.c[1]: number of uses: 3, isLinear: false, alias: no
 laptop_adapter.c[2]: number of uses: 3, isLinear: false, alias: no
 z.vFundAbs: number of uses: 1, isLinear: true, alias: no
 z.vFundArg: number of uses: 1, isLinear: true, alias: no
 z.iFundAbs: number of uses: 1, isLinear: true, alias: no
 z.iFundArg: number of uses: 1, isLinear: true, alias: no
 z.v[1].re: number of uses: 4, isLinear: false, alias: no
 z.v[1].im: number of uses: 9, isLinear: false, alias: no
 z.v[2].re: number of uses: 2, isLinear: true, alias: no
 z.v[2].im: number of uses: 4, isLinear: false, alias: no
 z.v[3].re: number of uses: 2, isLinear: true, alias: no
 z.v[3].im: number of uses: 4, isLinear: false, alias: no
 z.omega: number of uses: 1, isLinear: true, alias: no
 z1.vFundAbs: number of uses: 1, isLinear: true, alias: no
 z1.iFundAbs: number of uses: 1, isLinear: true, alias: no
 z1.iFundArg: number of uses: 1, isLinear: true, alias: no
 z1.v[1].re: number of uses: 7, isLinear: false, alias: no
 z1.v[2].re: number of uses: 4, isLinear: false, alias: no
 z1.v[3].re: number of uses: 4, isLinear: false, alias: no
 z1.i[1].re: number of uses: 5, isLinear: false, alias: no
 z1.i[1].im: number of uses: 5, isLinear: false, alias: no
 z1.i[2].re: number of uses: 3, isLinear: true, alias: no
 z1.i[2].im: number of uses: 3, isLinear: true, alias: no
 z1.i[3].re: number of uses: 3, isLinear: true, alias: no
 z1.i[3].im: number of uses: 3, isLinear: true, alias: no
 z1.omega: number of uses: 1, isLinear: true, alias: no

Input variables: 

Alias sets:
{v.i[1].re(start=0), v.pin_p.iRe[1], -v.pin_n.iRe[1], -z.i[1].re(start=0), -z.pin_p.iRe[1], z.pin_n.iRe[1]}
{v.i[2].re(start=0), v.pin_p.iRe[2], -v.pin_n.iRe[2], -z.i[2].re(start=0), -z.pin_p.iRe[2], z.pin_n.iRe[2]}
{v.i[3].re(start=0), v.pin_p.iRe[3], -v.pin_n.iRe[3], -z.i[3].re(start=0), -z.pin_p.iRe[3], z.pin_n.iRe[3]}
{v.i[1].im(start=0), v.pin_p.iIm[1], -v.pin_n.iIm[1], -z.i[1].im(start=0), -z.pin_p.iIm[1], z.pin_n.iIm[1]}
{v.i[2].im(start=0), v.pin_p.iIm[2], -v.pin_n.iIm[2], -z.i[2].im(start=0), -z.pin_p.iIm[2], z.pin_n.iIm[2]}
{v.i[3].im(start=0), v.pin_p.iIm[3], -v.pin_n.iIm[3], -z.i[3].im(start=0), -z.pin_p.iIm[3], z.pin_n.iIm[3]}
{laptop_adapter.P, temp_7.re}
{laptop_adapter.Q(start=1), temp_7.im}
{-laptop_adapter.loadBase.i[1].im(start=0), temp_87, -laptop_adapter.loadBase.pin_p.iIm[1], laptop_adapter.loadBase.pin_n.iIm[1], -laptop_adapter.hPin_P.iIm[1], laptop_adapter.hPin_N.iIm[1]}
{laptop_adapter.loadBase.i[1].re(start=0), laptop_adapter.loadBase.pin_p.iRe[1], -laptop_adapter.loadBase.pin_n.iRe[1], laptop_adapter.hPin_P.iRe[1], -laptop_adapter.hPin_N.iRe[1]}
{laptop_adapter.loadBase.i[2].re(start=0), laptop_adapter.loadBase.pin_p.iRe[2], -laptop_adapter.loadBase.pin_n.iRe[2], laptop_adapter.hPin_P.iRe[2], -laptop_adapter.hPin_N.iRe[2]}
{laptop_adapter.loadBase.i[3].re(start=0), laptop_adapter.loadBase.pin_p.iRe[3], -laptop_adapter.loadBase.pin_n.iRe[3], laptop_adapter.hPin_P.iRe[3], -laptop_adapter.hPin_N.iRe[3]}
{laptop_adapter.loadBase.i[2].im(start=0), laptop_adapter.loadBase.pin_p.iIm[2], -laptop_adapter.loadBase.pin_n.iIm[2], laptop_adapter.hPin_P.iIm[2], -laptop_adapter.hPin_N.iIm[2]}
{laptop_adapter.loadBase.i[3].im(start=0), laptop_adapter.loadBase.pin_p.iIm[3], -laptop_adapter.loadBase.pin_n.iIm[3], laptop_adapter.hPin_P.iIm[3], -laptop_adapter.hPin_N.iIm[3]}
{laptop.i, laptop.p.i, -laptop.n.i, -laptop_adapter.pin_p.i, -laptop_adapter.vDC.p.i, laptop_adapter.vDC.n.i, -laptop_adapter.vDC.i, laptop_adapter.pin_n.i}
{z1.i[1].re(start=0), z1.pin_p.iRe[1], -z1.pin_n.iRe[1]}
{z1.i[2].re(start=0), z1.pin_p.iRe[2], -z1.pin_n.iRe[2]}
{z1.i[3].re(start=0), z1.pin_p.iRe[3], -z1.pin_n.iRe[3]}
{z1.i[1].im(start=0), z1.pin_p.iIm[1], -z1.pin_n.iIm[1]}
{z1.i[2].im(start=0), z1.pin_p.iIm[2], -z1.pin_n.iIm[2]}
{z1.i[3].im(start=0), z1.pin_p.iIm[3], -z1.pin_n.iIm[3]}
{laptop_adapter.vDC.V(start=1), laptop.p.v, laptop_adapter.pin_p.v, laptop_adapter.vDC.p.v, laptop_adapter.vDC.v, laptop.v}
{-z.v[1].im(start=0), laptop_adapter.hPin_P.v[1].im, z.pin_n.v[1].im, z1.pin_p.v[1].im, laptop_adapter.loadBase.pin_p.v[1].im, laptop_adapter.loadBase.v[1].im(start=0), z1.v[1].im(start=0)}
{z1.v[1].re(start=0), laptop_adapter.hPin_P.v[1].re, z.pin_n.v[1].re, z1.pin_p.v[1].re, laptop_adapter.loadBase.pin_p.v[1].re, laptop_adapter.loadBase.v[1].re(start=0)}
{-z.v[2].im(start=0), laptop_adapter.hPin_P.v[2].im, z.pin_n.v[2].im, z1.pin_p.v[2].im, laptop_adapter.loadBase.pin_p.v[2].im, laptop_adapter.loadBase.v[2].im(start=0), z1.v[2].im(start=0)}
{z1.v[2].re(start=0), laptop_adapter.hPin_P.v[2].re, z.pin_n.v[2].re, z1.pin_p.v[2].re, laptop_adapter.loadBase.pin_p.v[2].re, laptop_adapter.loadBase.v[2].re(start=0)}
{-z.v[3].im(start=0), laptop_adapter.hPin_P.v[3].im, z.pin_n.v[3].im, z1.pin_p.v[3].im, laptop_adapter.loadBase.pin_p.v[3].im, laptop_adapter.loadBase.v[3].im(start=0), z1.v[3].im(start=0)}
{z1.v[3].re(start=0), laptop_adapter.hPin_P.v[3].re, z.pin_n.v[3].re, z1.pin_p.v[3].re, laptop_adapter.loadBase.pin_p.v[3].re, laptop_adapter.loadBase.v[3].re(start=0)}
{v.v[1].re(start=0), v.pin_p.v[1].re, z.pin_p.v[1].re}
{v.theta(start=0), ground1.pin.reference.theta(start=0), laptop_adapter.hPin_N.reference.theta(start=0), v.pin_p.reference.theta(start=0), v.pin_n.reference.theta(start=0), z.pin_p.reference.theta(start=0), z.pin_n.reference.theta(start=0), laptop_adapter.hPin_P.reference.theta(start=0), z1.pin_p.reference.theta(start=0), z1.pin_n.reference.theta(start=0), laptop_adapter.loadBase.pin_p.reference.theta(start=0), laptop_adapter.loadBase.pin_n.reference.theta(start=0)}
{v.v[2].re(start=0), v.vMag[2], v.vMag[3], v.v[3].re(start=0), v.pin_p.v[2].re, z.pin_p.v[2].re, v.pin_p.v[3].re, z.pin_p.v[3].re}
{v.vArg[1], v.vArg[2], v.vArg[3], ground1.pin.v[1].im, laptop_adapter.hPin_N.v[1].im, v.pin_n.v[1].im, z1.pin_n.v[1].im, laptop_adapter.loadBase.pin_n.v[1].im, ground1.pin.v[2].im, laptop_adapter.hPin_N.v[2].im, v.pin_n.v[2].im, z1.pin_n.v[2].im, laptop_adapter.loadBase.pin_n.v[2].im, ground1.pin.v[3].im, laptop_adapter.hPin_N.v[3].im, v.pin_n.v[3].im, z1.pin_n.v[3].im, laptop_adapter.loadBase.pin_n.v[3].im, ground2.p.v, laptop.n.v, laptop_adapter.pin_n.v, laptop_adapter.vDC.n.v, temp_92.im, temp_107.im}
{systemDef.numHrm, v.pin_p.h, v.pin_n.h, ground1.pin.h, laptop_adapter.hPin_P.h, laptop_adapter.hPin_N.h, laptop_adapter.loadBase.pin_p.h, laptop_adapter.loadBase.pin_n.h, z.pin_p.h, z.pin_n.h, z1.pin_p.h, z1.pin_n.h}
{v.v[1].im(start=0), v.v[2].im(start=0), v.v[3].im(start=0), v.pin_p.v[1].im, z.pin_p.v[1].im, v.pin_p.v[2].im, z.pin_p.v[2].im, v.pin_p.v[3].im, z.pin_p.v[3].im, ground1.pin.v[1].re, laptop_adapter.hPin_N.v[1].re, v.pin_n.v[1].re, z1.pin_n.v[1].re, laptop_adapter.loadBase.pin_n.v[1].re, ground1.pin.v[2].re, laptop_adapter.hPin_N.v[2].re, v.pin_n.v[2].re, z1.pin_n.v[2].re, laptop_adapter.loadBase.pin_n.v[2].re, ground1.pin.v[3].re, laptop_adapter.hPin_N.v[3].re, v.pin_n.v[3].re, z1.pin_n.v[3].re, laptop_adapter.loadBase.pin_n.v[3].re}
{z.properties.ComponentType, z1.properties.ComponentType}
{v.P1, v.P}
{laptop_adapter.V_arg[1], temp_357, z1.vFundArg}
195 variables can be eliminated

Incidence:
 eq 0:
 eq 1: der(v.theta)
 eq 2: der(v.theta) v.omega
 eq 3: z1.v[1].re laptop_adapter.loadBase.i[1].re z.v[1].im laptop_adapter.loadBase.i[1].im
 eq 4: z1.v[1].re laptop_adapter.loadBase.i[1].im z.v[1].im laptop_adapter.loadBase.i[1].re
 eq 5: laptop_adapter.loadBase.i[2].re laptop_adapter.c[1] laptop_adapter.a[1].re
 eq 6: laptop_adapter.loadBase.i[2].im laptop_adapter.c[1] laptop_adapter.a[1].im
 eq 7: laptop_adapter.loadBase.i[3].re laptop_adapter.c[2] laptop_adapter.a[2].re
 eq 8: laptop_adapter.loadBase.i[3].im laptop_adapter.c[2] laptop_adapter.a[2].im
 eq 9:
 eq 10: der(v.theta) laptop_adapter.loadBase.omega
 eq 11: z.v[1].re v.i[1].re v.i[1].im
 eq 12: z.v[2].re v.i[2].re v.i[2].im
 eq 13: z.v[3].re v.i[3].re v.i[3].im
 eq 14: z.v[1].im v.i[1].im v.i[1].re
 eq 15: z.v[2].im v.i[2].im v.i[2].re
 eq 16: z.v[3].im v.i[3].im v.i[3].re
 eq 17: der(v.theta) z.omega
 eq 18: z.v[1].re z1.v[1].re
 eq 19: z.v[2].re z1.v[2].re
 eq 20: z.v[3].re z1.v[3].re
 eq 21: z1.v[1].re z1.i[1].re z1.i[1].im
 eq 22: z1.v[2].re z1.i[2].re z1.i[2].im
 eq 23: z1.v[3].re z1.i[3].re z1.i[3].im
 eq 24: z.v[1].im z1.i[1].im z1.i[1].re
 eq 25: z.v[2].im z1.i[2].im z1.i[2].re
 eq 26: z.v[3].im z1.i[3].im z1.i[3].re
 eq 27: der(v.theta) z1.omega
 eq 28: ground1.pin.iIm[1] laptop_adapter.loadBase.i[1].im v.i[1].im z1.i[1].im
 eq 29: ground1.pin.iIm[2] laptop_adapter.loadBase.i[2].im v.i[2].im z1.i[2].im
 eq 30: ground1.pin.iIm[3] laptop_adapter.loadBase.i[3].im v.i[3].im z1.i[3].im
 eq 31: ground1.pin.iRe[1] laptop_adapter.loadBase.i[1].re v.i[1].re z1.i[1].re
 eq 32: ground1.pin.iRe[2] laptop_adapter.loadBase.i[2].re v.i[2].re z1.i[2].re
 eq 33: ground1.pin.iRe[3] laptop_adapter.loadBase.i[3].re v.i[3].re z1.i[3].re
 eq 34: ground1.pin.iIm[1]
 eq 35: ground1.pin.iIm[2]
 eq 36: ground1.pin.iIm[3]
 eq 37: ground1.pin.iRe[1]
 eq 38: ground1.pin.iRe[2]
 eq 39: ground1.pin.iRe[3]
 eq 40:
 eq 41:
 eq 42: v.P1 v.i[1].re
 eq 43: v.iMag[1] v.i[1].re v.i[1].im
 eq 44: v.iMag[2] v.i[2].re v.i[2].im
 eq 45: v.iMag[3] v.i[3].re v.i[3].im
 eq 46: v.iArg[1] v.i[1].im v.i[1].re
 eq 47: v.iArg[2] v.i[2].im v.i[2].re
 eq 48: v.iArg[3] v.i[3].im v.i[3].re
 eq 49: laptop_adapter.I_mag[1] laptop_adapter.loadBase.i[1].re laptop_adapter.loadBase.i[1].im
 eq 50: laptop_adapter.I_mag[2] laptop_adapter.loadBase.i[2].re laptop_adapter.loadBase.i[2].im
 eq 51: laptop_adapter.I_mag[3] laptop_adapter.loadBase.i[3].re laptop_adapter.loadBase.i[3].im
 eq 52: laptop_adapter.I_arg[1] laptop_adapter.loadBase.i[1].im laptop_adapter.loadBase.i[1].re
 eq 53: laptop_adapter.I_arg[2] laptop_adapter.loadBase.i[2].im laptop_adapter.loadBase.i[2].re
 eq 54: laptop_adapter.I_arg[3] laptop_adapter.loadBase.i[3].im laptop_adapter.loadBase.i[3].re
 eq 55: laptop_adapter.V_mag[1] z1.v[1].re z.v[1].im
 eq 56: laptop_adapter.V_mag[2] z1.v[2].re z.v[2].im
 eq 57: laptop_adapter.V_mag[3] z1.v[3].re z.v[3].im
 eq 58: laptop_adapter.V_arg[2] z.v[2].im z1.v[2].re
 eq 59: laptop_adapter.V_arg[3] z.v[3].im z1.v[3].re
 eq 60: laptop_adapter.magScale laptop_adapter.loadBase.i[1].re laptop_adapter.loadBase.i[1].im
 eq 61: laptop_adapter.argAdj[1] laptop_adapter.V_arg[1]
 eq 62: laptop_adapter.argAdj[2] laptop_adapter.V_arg[1]
 eq 63: laptop_adapter.a[1].re laptop_adapter.argAdj[1]
 eq 64: laptop_adapter.a[1].im laptop_adapter.argAdj[1]
 eq 65: laptop_adapter.a[2].re laptop_adapter.argAdj[2]
 eq 66: laptop_adapter.a[2].im laptop_adapter.argAdj[2]
 eq 67: laptop_adapter.c[1] laptop_adapter.magScale
 eq 68: laptop_adapter.c[2] laptop_adapter.magScale
 eq 69: z.vFundAbs z.v[1].re z.v[1].im
 eq 70: z.vFundArg z.v[1].im z.v[1].re
 eq 71: z.iFundAbs v.i[1].re v.i[1].im
 eq 72: z.iFundArg v.i[1].im v.i[1].re
 eq 73: z1.vFundAbs z1.v[1].re z.v[1].im
 eq 74: z1.iFundAbs z1.i[1].re z1.i[1].im
 eq 75: z1.iFundArg z1.i[1].im z1.i[1].re
 eq 76: laptop_adapter.V_arg[1] z.v[1].im z1.v[1].re

Variable dependencies:
Derivative variables: 
 der(v.theta)
    systemDef.fFund

Differentiated variables: 
 v.theta

Algebraic real variables: 
 v.P1
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 v.iMag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 v.iMag[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 v.iMag[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 v.iArg[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 v.iArg[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 v.iArg[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 v.i[1].re
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 v.i[1].im
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 v.i[2].re
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 v.i[2].im
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 v.i[3].re
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 v.i[3].im
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 v.omega
    systemDef.fFund
 ground1.pin.iIm[1]
 ground1.pin.iIm[2]
 ground1.pin.iIm[3]
 ground1.pin.iRe[1]
 ground1.pin.iRe[2]
 ground1.pin.iRe[3]
 laptop_adapter.loadBase.i[1].re
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.loadBase.i[1].im
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.loadBase.i[2].re
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
    systemDef.hrms[2]
 laptop_adapter.loadBase.i[2].im
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
    systemDef.hrms[2]
 laptop_adapter.loadBase.i[3].re
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
    systemDef.hrms[3]
 laptop_adapter.loadBase.i[3].im
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
    systemDef.hrms[3]
 laptop_adapter.loadBase.omega
    systemDef.fFund
 laptop_adapter.I_mag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.I_mag[2]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
    systemDef.hrms[2]
 laptop_adapter.I_mag[3]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
    systemDef.hrms[3]
 laptop_adapter.I_arg[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.I_arg[2]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
    systemDef.hrms[2]
 laptop_adapter.I_arg[3]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
    systemDef.hrms[3]
 laptop_adapter.V_mag[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.V_mag[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 laptop_adapter.V_mag[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 laptop_adapter.V_arg[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.V_arg[2]
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 laptop_adapter.V_arg[3]
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 laptop_adapter.magScale
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.argAdj[1]
    systemDef.hrms[2]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.argAdj[2]
    systemDef.hrms[3]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.a[1].re
    systemDef.hrms[2]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.a[1].im
    systemDef.hrms[2]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.a[2].re
    systemDef.hrms[3]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.a[2].im
    systemDef.hrms[3]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.c[1]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 laptop_adapter.c[2]
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z.vFundAbs
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z.vFundArg
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z.iFundAbs
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z.iFundArg
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z.v[1].re
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z.v[1].im
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z.v[2].re
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 z.v[2].im
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 z.v[3].re
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 z.v[3].im
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 z.omega
    systemDef.fFund
 z1.vFundAbs
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z1.iFundAbs
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z1.iFundArg
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z1.v[1].re
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z1.v[2].re
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 z1.v[3].re
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 z1.i[1].re
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z1.i[1].im
    z.z.re
    z.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
    z1.z.re
    z1.z.im
 z1.i[2].re
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 z1.i[2].im
    z.z.re
    z.z.im
    systemDef.hrms[2]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 z1.i[3].re
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 z1.i[3].im
    z.z.re
    z.z.im
    systemDef.hrms[3]
    z1.z.re
    z1.z.im
    systemDef.hrms[1]
    laptop_adapter.efficiency
    laptop.pwr
    laptop_adapter.V_Rect
 z1.omega
    systemDef.fFund



Connection sets: 52 sets
Connection set (flow): {ground1.pin.iIm[1:3] (i), laptop_adapter.hPin_N.iIm[1:3] (i), v.pin_n.iIm[1:3] (i), z1.pin_n.iIm[1:3] (i)}
Connection set (flow): {ground1.pin.iRe[1:3] (i), laptop_adapter.hPin_N.iRe[1:3] (i), v.pin_n.iRe[1:3] (i), z1.pin_n.iRe[1:3] (i)}
Connection set (potential): {ground1.pin.v[1].im (i), laptop_adapter.hPin_N.v[1].im (i), v.pin_n.v[1].im (i), z1.pin_n.v[1].im (i)}
Connection set (potential): {ground1.pin.v[1].re (i), laptop_adapter.hPin_N.v[1].re (i), v.pin_n.v[1].re (i), z1.pin_n.v[1].re (i)}
Connection set (potential): {ground1.pin.v[2].im (i), laptop_adapter.hPin_N.v[2].im (i), v.pin_n.v[2].im (i), z1.pin_n.v[2].im (i)}
Connection set (potential): {ground1.pin.v[2].re (i), laptop_adapter.hPin_N.v[2].re (i), v.pin_n.v[2].re (i), z1.pin_n.v[2].re (i)}
Connection set (potential): {ground1.pin.v[3].im (i), laptop_adapter.hPin_N.v[3].im (i), v.pin_n.v[3].im (i), z1.pin_n.v[3].im (i)}
Connection set (potential): {ground1.pin.v[3].re (i), laptop_adapter.hPin_N.v[3].re (i), v.pin_n.v[3].re (i), z1.pin_n.v[3].re (i)}
Connection set (flow): {ground2.p.i (i), laptop.n.i (i), laptop_adapter.pin_n.i (i)}
Connection set (potential): {ground2.p.v (i), laptop.n.v (i), laptop_adapter.pin_n.v (i)}
Connection set (flow): {laptop.p.i (i), laptop_adapter.pin_p.i (i)}
Connection set (potential): {laptop.p.v (i), laptop_adapter.pin_p.v (i)}
Connection set (flow): {laptop_adapter.hPin_P.iIm[1:3] (i), z.pin_n.iIm[1:3] (i), z1.pin_p.iIm[1:3] (i)}
Connection set (flow): {laptop_adapter.hPin_P.iRe[1:3] (i), z.pin_n.iRe[1:3] (i), z1.pin_p.iRe[1:3] (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[1].im (i), z.pin_n.v[1].im (i), z1.pin_p.v[1].im (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[1].re (i), z.pin_n.v[1].re (i), z1.pin_p.v[1].re (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[2].im (i), z.pin_n.v[2].im (i), z1.pin_p.v[2].im (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[2].re (i), z.pin_n.v[2].re (i), z1.pin_p.v[2].re (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[3].im (i), z.pin_n.v[3].im (i), z1.pin_p.v[3].im (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[3].re (i), z.pin_n.v[3].re (i), z1.pin_p.v[3].re (i)}
Connection set (flow): {v.pin_p.iIm[1:3] (i), z.pin_p.iIm[1:3] (i)}
Connection set (flow): {v.pin_p.iRe[1:3] (i), z.pin_p.iRe[1:3] (i)}
Connection set (potential): {v.pin_p.v[1].im (i), z.pin_p.v[1].im (i)}
Connection set (potential): {v.pin_p.v[1].re (i), z.pin_p.v[1].re (i)}
Connection set (potential): {v.pin_p.v[2].im (i), z.pin_p.v[2].im (i)}
Connection set (potential): {v.pin_p.v[2].re (i), z.pin_p.v[2].re (i)}
Connection set (potential): {v.pin_p.v[3].im (i), z.pin_p.v[3].im (i)}
Connection set (potential): {v.pin_p.v[3].re (i), z.pin_p.v[3].re (i)}
Connection set (flow): {laptop_adapter.pin_p.i (o), laptop_adapter.vDC.p.i (i)}
Connection set (potential): {laptop_adapter.pin_p.v (o), laptop_adapter.vDC.p.v (i)}
Connection set (flow): {laptop_adapter.pin_n.i (o), laptop_adapter.vDC.n.i (i)}
Connection set (potential): {laptop_adapter.pin_n.v (o), laptop_adapter.vDC.n.v (i)}
Connection set (flow): {laptop_adapter.hPin_P.iIm[1:3] (o), laptop_adapter.loadBase.pin_p.iIm[1:3] (i)}
Connection set (flow): {laptop_adapter.hPin_P.iRe[1:3] (o), laptop_adapter.loadBase.pin_p.iRe[1:3] (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[1].im (o), laptop_adapter.loadBase.pin_p.v[1].im (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[1].re (o), laptop_adapter.loadBase.pin_p.v[1].re (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[2].im (o), laptop_adapter.loadBase.pin_p.v[2].im (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[2].re (o), laptop_adapter.loadBase.pin_p.v[2].re (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[3].im (o), laptop_adapter.loadBase.pin_p.v[3].im (i)}
Connection set (potential): {laptop_adapter.hPin_P.v[3].re (o), laptop_adapter.loadBase.pin_p.v[3].re (i)}
Connection set (flow): {laptop_adapter.hPin_N.iIm[1:3] (o), laptop_adapter.loadBase.pin_n.iIm[1:3] (i)}
Connection set (flow): {laptop_adapter.hPin_N.iRe[1:3] (o), laptop_adapter.loadBase.pin_n.iRe[1:3] (i)}
Connection set (potential): {laptop_adapter.hPin_N.v[1].im (o), laptop_adapter.loadBase.pin_n.v[1].im (i)}
Connection set (potential): {laptop_adapter.hPin_N.v[1].re (o), laptop_adapter.loadBase.pin_n.v[1].re (i)}
Connection set (potential): {laptop_adapter.hPin_N.v[2].im (o), laptop_adapter.loadBase.pin_n.v[2].im (i)}
Connection set (potential): {laptop_adapter.hPin_N.v[2].re (o), laptop_adapter.loadBase.pin_n.v[2].re (i)}
Connection set (potential): {laptop_adapter.hPin_N.v[3].im (o), laptop_adapter.loadBase.pin_n.v[3].im (i)}
Connection set (potential): {laptop_adapter.hPin_N.v[3].re (o), laptop_adapter.loadBase.pin_n.v[3].re (i)}
Connection set (potential): {v.pin_p.reference.theta (i), z.pin_p.reference.theta (i)}
Connection set (potential): {laptop_adapter.hPin_P.reference.theta (i), z.pin_n.reference.theta (i), z1.pin_p.reference.theta (i)}
Connection set (potential): {ground1.pin.reference.theta (i), laptop_adapter.hPin_N.reference.theta (i), v.pin_n.reference.theta (i)}
Connection set (potential): {laptop_adapter.hPin_P.reference.theta (o), laptop_adapter.loadBase.pin_p.reference.theta (i)}

Transformed flattened model:
fclass HPF.Test.Test_Rectifier
 parameter Integer systemDef.hrms[1] = 1 "Harmonics to simulate" /* 1 */;
 parameter Integer systemDef.hrms[2] = 3 "Harmonics to simulate" /* 3 */;
 parameter Integer systemDef.hrms[3] = 5 "Harmonics to simulate" /* 5 */;
 structural parameter Integer systemDef.numHrm = 3 "Number of harmonics. (Automatically generated from hrms.)" /* 3 */;
 parameter Real systemDef.fFund = 60 "Fundamental frequency (Hz)" /* 60 */;
 parameter Real systemDef.fs = 10000.0 "Sampling frequency (Hz)" /* 10000.0 */;
 parameter Integer temp_20[1];
 parameter Integer systemDef.numPh = 3 "Number of phases" /* 3 */;
 constant String v.properties.ComponentType = "VoltageSource" "Type of the component";
 structural parameter Real v.vMag[1] = 120 "Voltage Magnitude (Volts rms)" /* 120 */;
 structural parameter Real v.vArg[1] = 0 "Voltage angle (rad)" /* 0 */;
 Real v.P1;
 Real v.iMag[1];
 Real v.iMag[2];
 Real v.iMag[3];
 Real v.iArg[1];
 Real v.iArg[2];
 Real v.iArg[3];
 Modelica.SIunits.Angle v.theta(start = 0);
 constant Real v.v[1].re(start = 0) = 120.0 "Real part of complex number";
 constant Real v.v[1].im(start = 0) = 0.0 "Imaginary part of complex number";
 constant Real v.v[2].re(start = 0) = 0.001 "Real part of complex number";
 Real v.i[1].re(start = 0) "Real part of complex number";
 Real v.i[1].im(start = 0) "Imaginary part of complex number";
 Real v.i[2].re(start = 0) "Real part of complex number";
 Real v.i[2].im(start = 0) "Imaginary part of complex number";
 Real v.i[3].re(start = 0) "Real part of complex number";
 Real v.i[3].im(start = 0) "Imaginary part of complex number";
 Real v.omega;
 constant String ground1.properties.ComponentType = "Ground" "Type of the component";
 Real ground1.pin.iIm[1];
 Real ground1.pin.iIm[2];
 Real ground1.pin.iIm[3];
 Real ground1.pin.iRe[1];
 Real ground1.pin.iRe[2];
 Real ground1.pin.iRe[3];
 parameter Integer temp_20[2];
 constant String laptop_adapter.properties.ComponentType = "NonlinearLoad" "Type of the component";
 parameter Real temp_21[1,1];
 parameter Real laptop_adapter.V_Rect(start = 0) = 24 "Rectifier DC output" /* 24 */;
 parameter Real laptop_adapter.efficiency(start = 1) = 0.9 "Rectifier efficiency (replace with efficiency model or curve)" /* 0.9 */;
 parameter Real laptop_adapter.rectifierModel = 0 "Rectifier model (Other model parameters passed as a record?)" /* 0 */;
 parameter Real temp_21[2,1];
 Real laptop_adapter.loadBase.i[1].re(start = 0) "Real part of complex number";
 Real laptop_adapter.loadBase.i[1].im(start = 0) "Imaginary part of complex number";
 Real laptop_adapter.loadBase.i[2].re(start = 0) "Real part of complex number";
 Real laptop_adapter.loadBase.i[2].im(start = 0) "Imaginary part of complex number";
 Real laptop_adapter.loadBase.i[3].re(start = 0) "Real part of complex number";
 Real laptop_adapter.loadBase.i[3].im(start = 0) "Imaginary part of complex number";
 Real laptop_adapter.loadBase.omega;
 parameter Real temp_21[3,1];
 Real laptop_adapter.I_mag[1];
 Real laptop_adapter.I_mag[2];
 Real laptop_adapter.I_mag[3];
 Real laptop_adapter.I_arg[1];
 Real laptop_adapter.I_arg[2];
 Real laptop_adapter.I_arg[3];
 Real laptop_adapter.V_mag[1];
 Real laptop_adapter.V_mag[2];
 Real laptop_adapter.V_mag[3];
 Real laptop_adapter.V_arg[1];
 Real laptop_adapter.V_arg[2];
 Real laptop_adapter.V_arg[3];
 parameter Real temp_21[4,1];
 parameter Real temp_21[5,1];
 structural (loadResource) parameter String laptop_adapter.modelFileName = "HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" "Rectifier harmonic model mat file" /* "HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" */;
 structural parameter String laptop_adapter.resourceRetValue = "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" /* "/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat" */;
 structural parameter Integer laptop_adapter.matDim[1] = 16 /* 16 */;
 structural parameter Integer laptop_adapter.matDim[2] = 1 /* 1 */;
 structural parameter Real laptop_adapter.magDataMat[1,1] = 0.9999999999999999 /* 0.9999999999999999 */;
 structural parameter Real laptop_adapter.magDataMat[2,1] = 0.9486974344201337 /* 0.9486974344201337 */;
 structural parameter Real laptop_adapter.magDataMat[3,1] = 0.9221155376813399 /* 0.9221155376813399 */;
 structural parameter Real laptop_adapter.magDataMat[4,1] = 0.8849332521469448 /* 0.8849332521469448 */;
 structural parameter Real laptop_adapter.magDataMat[5,1] = 0.8475867045468796 /* 0.8475867045468796 */;
 structural parameter Real laptop_adapter.magDataMat[6,1] = 0.7944241839808487 /* 0.7944241839808487 */;
 structural parameter Real laptop_adapter.magDataMat[7,1] = 0.7230242274654483 /* 0.7230242274654483 */;
 structural parameter Real laptop_adapter.magDataMat[8,1] = 0.6688914048386135 /* 0.6688914048386135 */;
 structural parameter Real laptop_adapter.magDataMat[9,1] = 0.5939253865608557 /* 0.5939253865608557 */;
 structural parameter Real laptop_adapter.magDataMat[10,1] = 0.5280196623121391 /* 0.5280196623121391 */;
 structural parameter Real laptop_adapter.magDataMat[11,1] = 0.4568186887780485 /* 0.4568186887780485 */;
 structural parameter Real laptop_adapter.magDataMat[12,1] = 0.3861474201640431 /* 0.3861474201640431 */;
 structural parameter Real laptop_adapter.magDataMat[13,1] = 0.3163533253631282 /* 0.3163533253631282 */;
 structural parameter Real laptop_adapter.magDataMat[14,1] = 0.2534864723066213 /* 0.2534864723066213 */;
 structural parameter Real laptop_adapter.magDataMat[15,1] = 0.1920046370077911 /* 0.1920046370077911 */;
 structural parameter Real laptop_adapter.magDataMat[16,1] = 0.1442126307974456 /* 0.1442126307974456 */;
 structural parameter Real laptop_adapter.argDataMat[1,1] = 0.3053419323150846 /* 0.3053419323150846 */;
 structural parameter Real laptop_adapter.argDataMat[2,1] = -2.8182357929499515 /* -2.8182357929499515 */;
 structural parameter Real laptop_adapter.argDataMat[3,1] = 0.5364901833841553 /* 0.5364901833841553 */;
 structural parameter Real laptop_adapter.argDataMat[4,1] = -2.381193752481799 /* -2.381193752481799 */;
 structural parameter Real laptop_adapter.argDataMat[5,1] = 0.9688071004089418 /* 0.9688071004089418 */;
 structural parameter Real laptop_adapter.argDataMat[6,1] = -1.959495555161772 /* -1.959495555161772 */;
 structural parameter Real laptop_adapter.argDataMat[7,1] = 1.4013739855750704 /* 1.4013739855750704 */;
 structural parameter Real laptop_adapter.argDataMat[8,1] = -1.5329775105321843 /* -1.5329775105321843 */;
 structural parameter Real laptop_adapter.argDataMat[9,1] = 1.8276649690040103 /* 1.8276649690040103 */;
 structural parameter Real laptop_adapter.argDataMat[10,1] = -1.1106883983886444 /* -1.1106883983886444 */;
 structural parameter Real laptop_adapter.argDataMat[11,1] = 2.2426384598738585 /* 2.2426384598738585 */;
 structural parameter Real laptop_adapter.argDataMat[12,1] = -0.6809000975704675 /* -0.6809000975704675 */;
 structural parameter Real laptop_adapter.argDataMat[13,1] = 2.648460001811645 /* 2.648460001811645 */;
 structural parameter Real laptop_adapter.argDataMat[14,1] = -0.2835615514742411 /* -0.2835615514742411 */;
 structural parameter Real laptop_adapter.argDataMat[15,1] = 3.0642644296286683 /* 3.0642644296286683 */;
 structural parameter Real laptop_adapter.argDataMat[16,1] = 0.0716470412434909 /* 0.0716470412434909 */;
 constant Real laptop_adapter.argS = -0.3053419323150846 "Phase angle for fundamental apparent power";
 Real laptop_adapter.magScale;
 Real laptop_adapter.argAdj[1];
 Real laptop_adapter.argAdj[2];
 Real laptop_adapter.a[1].re "Real part of complex number";
 Real laptop_adapter.a[1].im "Imaginary part of complex number";
 Real laptop_adapter.a[2].re "Real part of complex number";
 Real laptop_adapter.a[2].im "Imaginary part of complex number";
 Real laptop_adapter.c[1];
 Real laptop_adapter.c[2];
 constant String laptop.properties.ComponentType = "DC_Load" "Type of the component";
 parameter Real laptop.pwr(start = 1) = 50 "Power (watts)" /* 50 */;
 parameter Real temp_21[6,1];
 constant String z.properties.ComponentType = "Impedance" "Type of the component";
 parameter Real z.z.re(start = 1) = 5.0 "Real part of complex number" /* 5.0 */;
 parameter Real z.z.im(start = 0) = 2.0 "Imaginary part of complex number" /* 2.0 */;
 Real z.vFundAbs;
 Real z.vFundArg;
 Real z.iFundAbs;
 Real z.iFundArg;
 Real z.v[1].re(start = 0) "Real part of complex number";
 Real z.v[1].im(start = 0) "Imaginary part of complex number";
 Real z.v[2].re(start = 0) "Real part of complex number";
 Real z.v[2].im(start = 0) "Imaginary part of complex number";
 Real z.v[3].re(start = 0) "Real part of complex number";
 Real z.v[3].im(start = 0) "Imaginary part of complex number";
 Real z.omega;
 parameter Real z1.z.re(start = 1) = 5.0 "Real part of complex number" /* 5.0 */;
 parameter Real z1.z.im(start = 0) = 2.0 "Imaginary part of complex number" /* 2.0 */;
 Real z1.vFundAbs;
 Real z1.iFundAbs;
 Real z1.iFundArg;
 Real z1.v[1].re(start = 0) "Real part of complex number";
 Real z1.v[2].re(start = 0) "Real part of complex number";
 Real z1.v[3].re(start = 0) "Real part of complex number";
 Real z1.i[1].re(start = 0) "Real part of complex number";
 Real z1.i[1].im(start = 0) "Imaginary part of complex number";
 Real z1.i[2].re(start = 0) "Real part of complex number";
 Real z1.i[2].im(start = 0) "Imaginary part of complex number";
 Real z1.i[3].re(start = 0) "Real part of complex number";
 Real z1.i[3].im(start = 0) "Imaginary part of complex number";
 Real z1.omega;
 parameter Real temp_21[7,1];
 parameter Real temp_21[8,1];
 parameter Real temp_21[9,1];
 parameter Real temp_21[10,1];
 parameter Real temp_21[11,1];
 parameter Real temp_21[12,1];
 parameter Real temp_21[13,1];
 parameter Real temp_21[14,1];
 parameter Real temp_21[15,1];
 parameter Real temp_21[16,1];
 parameter Real temp_22[1,1];
 parameter Real temp_22[2,1];
 parameter Real temp_22[3,1];
 parameter Real temp_22[4,1];
 parameter Real temp_22[5,1];
 parameter Real temp_22[6,1];
 parameter Real temp_22[7,1];
 parameter Real temp_22[8,1];
 parameter Real temp_22[9,1];
 parameter Real temp_22[10,1];
 parameter Real temp_22[11,1];
 parameter Real temp_22[12,1];
 parameter Real temp_22[13,1];
 parameter Real temp_22[14,1];
 parameter Real temp_22[15,1];
 parameter Real temp_22[16,1];
 parameter Integer systemDef.N "Size of FFT";
 parameter Modelica.SIunits.ElectricPotential laptop_adapter.vDC.V(start = 1) "Value of constant voltage";
 parameter Modelica.SIunits.ElectricCurrent laptop.i "Current flowing from pin p to pin n";
 parameter Modelica.SIunits.ElectricCurrent ground2.p.i "Current flowing into the pin";
 parameter Real laptop_adapter.P;
 parameter Real laptop_adapter.S(start = 1) "Apparent power at fundamental";
 parameter Modelica.Blocks.Interfaces.RealOutput laptop_adapter.PLoss;
 parameter Real laptop_adapter.Q(start = 1) "Imaginary power at fundamental";
initial equation
 algorithm
;
 v.theta = 0;
parameter equation
 ({temp_20[1], temp_20[2]}) = Modelica.Utilities.Streams.readMatrixSize("/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat", "mag");
 ({{temp_21[1,1]}, {temp_21[2,1]}, {temp_21[3,1]}, {temp_21[4,1]}, {temp_21[5,1]}, {temp_21[6,1]}, {temp_21[7,1]}, {temp_21[8,1]}, {temp_21[9,1]}, {temp_21[10,1]}, {temp_21[11,1]}, {temp_21[12,1]}, {temp_21[13,1]}, {temp_21[14,1]}, {temp_21[15,1]}, {temp_21[16,1]}}) = Modelica.Utilities.Streams.readRealMatrix("/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat", "mag", 16, 1, true);
 ({{temp_22[1,1]}, {temp_22[2,1]}, {temp_22[3,1]}, {temp_22[4,1]}, {temp_22[5,1]}, {temp_22[6,1]}, {temp_22[7,1]}, {temp_22[8,1]}, {temp_22[9,1]}, {temp_22[10,1]}, {temp_22[11,1]}, {temp_22[12,1]}, {temp_22[13,1]}, {temp_22[14,1]}, {temp_22[15,1]}, {temp_22[16,1]}}) = Modelica.Utilities.Streams.readRealMatrix("/media/linuxdev/Documents/Research/DC Design Tool/Workspace/Modelica_HPF/DC-Design/HPF/PowerElectronicsConverters/AC2DC_ConverterModels/hrmMdl_laptop.mat", "arg", 16, 1, true);
 systemDef.N = integer(floor(systemDef.fs / systemDef.fFund));
 laptop_adapter.vDC.V = laptop_adapter.V_Rect;
 assert(16 == temp_20[1], "Error Error at line 50, column 39, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readMatrixSize' did not evaluate to same result as during compilation");
 assert(1 == temp_20[2], "Error Error at line 50, column 39, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readMatrixSize' did not evaluate to same result as during compilation");
 assert(0.9999999999999999 == temp_21[1,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.9486974344201337 == temp_21[2,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.9221155376813399 == temp_21[3,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.8849332521469448 == temp_21[4,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.8475867045468796 == temp_21[5,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.7944241839808487 == temp_21[6,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.7230242274654483 == temp_21[7,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.6688914048386135 == temp_21[8,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.5939253865608557 == temp_21[9,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.5280196623121391 == temp_21[10,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.4568186887780485 == temp_21[11,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.3861474201640431 == temp_21[12,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.3163533253631282 == temp_21[13,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.2534864723066213 == temp_21[14,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.1920046370077911 == temp_21[15,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.1442126307974456 == temp_21[16,1], "Error Error at line 52, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.3053419323150846 == temp_22[1,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-2.8182357929499515 == temp_22[2,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.5364901833841553 == temp_22[3,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-2.381193752481799 == temp_22[4,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.9688071004089418 == temp_22[5,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-1.959495555161772 == temp_22[6,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(1.4013739855750704 == temp_22[7,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-1.5329775105321843 == temp_22[8,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(1.8276649690040103 == temp_22[9,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-1.1106883983886444 == temp_22[10,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(2.2426384598738585 == temp_22[11,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-0.6809000975704675 == temp_22[12,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(2.648460001811645 == temp_22[13,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(-0.2835615514742411 == temp_22[14,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(3.0642644296286683 == temp_22[15,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 assert(0.0716470412434909 == temp_22[16,1], "Error Error at line 53, column 43, in file '../../../HPF/PowerElectronicsConverters/AC2DC_SinglePhase.mo'': Structural parameter external function call 'Modelica.Utilities.Streams.readRealMatrix' did not evaluate to same result as during compilation");
 laptop.i = laptop.pwr / laptop_adapter.vDC.V;
 ground2.p.i = laptop.i + (- laptop.i);
 laptop_adapter.P = abs(laptop_adapter.efficiency * (laptop_adapter.vDC.V * (- laptop.i)));
 laptop_adapter.S = (- laptop_adapter.P) / -0.9537442168683252;
 laptop_adapter.PLoss = laptop_adapter.P * (1 - laptop_adapter.efficiency) / laptop_adapter.efficiency;
 laptop_adapter.Q = laptop_adapter.S * -0.3006193087448392;
algorithm
equation
 der(v.theta) = 6.283185307179586 * systemDef.fFund;
 v.omega = der(v.theta);
 laptop_adapter.P = z1.v[1].re * laptop_adapter.loadBase.i[1].re - (- z.v[1].im) * (- laptop_adapter.loadBase.i[1].im);
 laptop_adapter.Q = z1.v[1].re * (- laptop_adapter.loadBase.i[1].im) + (- z.v[1].im) * laptop_adapter.loadBase.i[1].re;
 laptop_adapter.loadBase.i[2].re = laptop_adapter.c[1] * laptop_adapter.a[1].re;
 laptop_adapter.loadBase.i[2].im = laptop_adapter.c[1] * laptop_adapter.a[1].im;
 laptop_adapter.loadBase.i[3].re = laptop_adapter.c[2] * laptop_adapter.a[2].re;
 laptop_adapter.loadBase.i[3].im = laptop_adapter.c[2] * laptop_adapter.a[2].im;
algorithm
equation
 laptop_adapter.loadBase.omega = der(v.theta);
 z.v[1].re = z.z.re .* (- v.i[1].re) - z.z.im .* systemDef.hrms[1] .* (- v.i[1].im);
 z.v[2].re = z.z.re .* (- v.i[2].re) - z.z.im .* systemDef.hrms[2] .* (- v.i[2].im);
 z.v[3].re = z.z.re .* (- v.i[3].re) - z.z.im .* systemDef.hrms[3] .* (- v.i[3].im);
 z.v[1].im = z.z.re .* (- v.i[1].im) + z.z.im .* systemDef.hrms[1] .* (- v.i[1].re);
 z.v[2].im = z.z.re .* (- v.i[2].im) + z.z.im .* systemDef.hrms[2] .* (- v.i[2].re);
 z.v[3].im = z.z.re .* (- v.i[3].im) + z.z.im .* systemDef.hrms[3] .* (- v.i[3].re);
 z.omega = der(v.theta);
 z.v[1].re = 120.0 - z1.v[1].re;
 z.v[2].re = 0.001 - z1.v[2].re;
 z.v[3].re = 0.001 - z1.v[3].re;
 z1.v[1].re = z1.z.re .* z1.i[1].re - z1.z.im .* systemDef.hrms[1] .* z1.i[1].im;
 z1.v[2].re = z1.z.re .* z1.i[2].re - z1.z.im .* systemDef.hrms[2] .* z1.i[2].im;
 z1.v[3].re = z1.z.re .* z1.i[3].re - z1.z.im .* systemDef.hrms[3] .* z1.i[3].im;
 - z.v[1].im = z1.z.re .* z1.i[1].im + z1.z.im .* systemDef.hrms[1] .* z1.i[1].re;
 - z.v[2].im = z1.z.re .* z1.i[2].im + z1.z.im .* systemDef.hrms[2] .* z1.i[2].re;
 - z.v[3].im = z1.z.re .* z1.i[3].im + z1.z.im .* systemDef.hrms[3] .* z1.i[3].re;
 z1.omega = der(v.theta);
 ground1.pin.iIm[1] + (- laptop_adapter.loadBase.i[1].im) + (- v.i[1].im) + (- z1.i[1].im) = 0;
 ground1.pin.iIm[2] + (- laptop_adapter.loadBase.i[2].im) + (- v.i[2].im) + (- z1.i[2].im) = 0;
 ground1.pin.iIm[3] + (- laptop_adapter.loadBase.i[3].im) + (- v.i[3].im) + (- z1.i[3].im) = 0;
 ground1.pin.iRe[1] + (- laptop_adapter.loadBase.i[1].re) + (- v.i[1].re) + (- z1.i[1].re) = 0;
 ground1.pin.iRe[2] + (- laptop_adapter.loadBase.i[2].re) + (- v.i[2].re) + (- z1.i[2].re) = 0;
 ground1.pin.iRe[3] + (- laptop_adapter.loadBase.i[3].re) + (- v.i[3].re) + (- z1.i[3].re) = 0;
 0 = ground1.pin.iIm[1];
 0 = ground1.pin.iIm[2];
 0 = ground1.pin.iIm[3];
 0 = ground1.pin.iRe[1];
 0 = ground1.pin.iRe[2];
 0 = ground1.pin.iRe[3];
 HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta));
 HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint(HPF.Types.Reference(v.theta), HPF.Types.Reference(v.theta));
 v.P1 = 120.0 * v.i[1].re;
 v.iMag[1] = (v.i[1].re ^ 2 + v.i[1].im ^ 2) ^ 0.5;
 v.iMag[2] = (v.i[2].re ^ 2 + v.i[2].im ^ 2) ^ 0.5;
 v.iMag[3] = (v.i[3].re ^ 2 + v.i[3].im ^ 2) ^ 0.5;
 v.iArg[1] = Modelica.Math.atan3(v.i[1].im, v.i[1].re, 0);
 v.iArg[2] = Modelica.Math.atan3(v.i[2].im, v.i[2].re, 0);
 v.iArg[3] = Modelica.Math.atan3(v.i[3].im, v.i[3].re, 0);
 laptop_adapter.I_mag[1] = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5;
 laptop_adapter.I_mag[2] = (laptop_adapter.loadBase.i[2].re ^ 2 + laptop_adapter.loadBase.i[2].im ^ 2) ^ 0.5;
 laptop_adapter.I_mag[3] = (laptop_adapter.loadBase.i[3].re ^ 2 + laptop_adapter.loadBase.i[3].im ^ 2) ^ 0.5;
 laptop_adapter.I_arg[1] = Modelica.Math.atan3(laptop_adapter.loadBase.i[1].im, laptop_adapter.loadBase.i[1].re, 0);
 laptop_adapter.I_arg[2] = Modelica.Math.atan3(laptop_adapter.loadBase.i[2].im, laptop_adapter.loadBase.i[2].re, 0);
 laptop_adapter.I_arg[3] = Modelica.Math.atan3(laptop_adapter.loadBase.i[3].im, laptop_adapter.loadBase.i[3].re, 0);
 laptop_adapter.V_mag[1] = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5;
 laptop_adapter.V_mag[2] = (z1.v[2].re ^ 2 + (- z.v[2].im) ^ 2) ^ 0.5;
 laptop_adapter.V_mag[3] = (z1.v[3].re ^ 2 + (- z.v[3].im) ^ 2) ^ 0.5;
 laptop_adapter.V_arg[2] = Modelica.Math.atan3(- z.v[2].im, z1.v[2].re, 0);
 laptop_adapter.V_arg[3] = Modelica.Math.atan3(- z.v[3].im, z1.v[3].re, 0);
 laptop_adapter.magScale = (laptop_adapter.loadBase.i[1].re ^ 2 + laptop_adapter.loadBase.i[1].im ^ 2) ^ 0.5;
 laptop_adapter.argAdj[1] = -2.8182357929499515 - laptop_adapter.V_arg[1] .* systemDef.hrms[2];
 laptop_adapter.argAdj[2] = 0.5364901833841553 - laptop_adapter.V_arg[1] .* systemDef.hrms[3];
 laptop_adapter.a[1].re = cos(laptop_adapter.argAdj[1]);
 laptop_adapter.a[1].im = sin(laptop_adapter.argAdj[1]);
 laptop_adapter.a[2].re = cos(laptop_adapter.argAdj[2]);
 laptop_adapter.a[2].im = sin(laptop_adapter.argAdj[2]);
 laptop_adapter.c[1] = laptop_adapter.magScale * 0.9486974344201337;
 laptop_adapter.c[2] = laptop_adapter.magScale * 0.9221155376813399;
 z.vFundAbs = (z.v[1].re ^ 2 + z.v[1].im ^ 2) ^ 0.5;
 z.vFundArg = Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0);
 z.iFundAbs = ((- v.i[1].re) ^ 2 + (- v.i[1].im) ^ 2) ^ 0.5;
 z.iFundArg = Modelica.Math.atan3(- v.i[1].im, - v.i[1].re, 0);
 z1.vFundAbs = (z1.v[1].re ^ 2 + (- z.v[1].im) ^ 2) ^ 0.5;
 z1.iFundAbs = (z1.i[1].re ^ 2 + z1.i[1].im ^ 2) ^ 0.5;
 z1.iFundArg = Modelica.Math.atan3(z1.i[1].im, z1.i[1].re, 0);
 laptop_adapter.V_arg[1] = Modelica.Math.atan3(- z.v[1].im, z1.v[1].re, 0);

public
 function Modelica.Math.atan3
  input Real u1;
  input Real u2;
  input Real y0;
  output Real y;
  Real w;
 algorithm
  w := atan2(u1, u2);
  if y0 == 0 then
   y := w;
  else
   y := w + 6.283185307179586 * integer((3.141592653589793 + y0 - w) / 6.283185307179586);
  end if;
  return;
 end Modelica.Math.atan3;

 function Modelica.Utilities.Streams.readMatrixSize
  input String fileName;
  input String matrixName;
  output Integer[:] dim;
 algorithm
  init dim as Integer[2];
  external "C" ModelicaIO_readMatrixSizes(fileName, matrixName, dim);
  return;
 end Modelica.Utilities.Streams.readMatrixSize;

 function Modelica.Utilities.Streams.readRealMatrix
  input String fileName;
  input String matrixName;
  input Integer nrow;
  input Integer ncol;
  input Boolean verboseRead;
  output Real[:,:] matrix;
 algorithm
  init matrix as Real[nrow, ncol];
  external "C" ModelicaIO_readRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), verboseRead);
  return;
 end Modelica.Utilities.Streams.readRealMatrix;

 function HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Test_Rectifier.z1.pin_n.reference.equalityConstraint;

 function HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint
  input HPF.Types.Reference reference1;
  input HPF.Types.Reference reference2;
  output Real[:] residue;
 algorithm
  init residue as Real[0];
  assert(abs(reference1.theta - reference2.theta) < 1.0E-6 * 2 * 3.141592653589793, "Reference angles should be equal!");
  return;
 end HPF.Test.Test_Rectifier.laptop_adapter.loadBase.pin_n.reference.equalityConstraint;

 record HPF.Types.Reference
  Modelica.SIunits.Angle theta;
 end HPF.Types.Reference;

 type Modelica.SIunits.Angle = Real(final quantity = "Angle",final unit = "rad",displayUnit = "deg");
 type Modelica.SIunits.ElectricPotential = Real(final quantity = "ElectricPotential",final unit = "V");
 type Modelica.SIunits.ElectricCurrent = Real(final quantity = "ElectricCurrent",final unit = "A");
 type Modelica.Blocks.Interfaces.RealOutput = Real;
end HPF.Test.Test_Rectifier;

Generating code...
====== Model compiled successfully =======
make -f /home/linuxdev/jmodelica/Makefiles/MakeFile fmume20_
make[1]: Entering directory '/tmp/jmc17204345991466161181out'
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/linuxdev/jmodelica/include/RuntimeLibrary -I/home/linuxdev/jmodelica/ThirdParty/FMI/2.0  -I/home/linuxdev/jmodelica/ThirdParty/Sundials/include -c -o HPF_Test_Test_Rectifier_equ.o sources/HPF_Test_Test_Rectifier_equ.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/linuxdev/jmodelica/include/RuntimeLibrary -I/home/linuxdev/jmodelica/ThirdParty/FMI/2.0  -I/home/linuxdev/jmodelica/ThirdParty/Sundials/include -c -o HPF_Test_Test_Rectifier_base.o sources/HPF_Test_Test_Rectifier_base.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/linuxdev/jmodelica/include/RuntimeLibrary -I/home/linuxdev/jmodelica/ThirdParty/FMI/2.0  -I/home/linuxdev/jmodelica/ThirdParty/Sundials/include -c -o HPF_Test_Test_Rectifier_init_dependent.o sources/HPF_Test_Test_Rectifier_init_dependent.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/linuxdev/jmodelica/include/RuntimeLibrary -I/home/linuxdev/jmodelica/ThirdParty/FMI/2.0  -I/home/linuxdev/jmodelica/ThirdParty/Sundials/include -c -o HPF_Test_Test_Rectifier_init_independent.o sources/HPF_Test_Test_Rectifier_init_independent.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -O1 -I/home/linuxdev/jmodelica/include/RuntimeLibrary -I/home/linuxdev/jmodelica/ThirdParty/FMI/2.0  -I/home/linuxdev/jmodelica/ThirdParty/Sundials/include -c -o HPF_Test_Test_Rectifier_funcs.o sources/HPF_Test_Test_Rectifier_funcs.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/linuxdev/jmodelica/include/RuntimeLibrary -I/home/linuxdev/jmodelica/ThirdParty/FMI/2.0  -I/home/linuxdev/jmodelica/ThirdParty/Sundials/include -c -o HPF_Test_Test_Rectifier.o sources/HPF_Test_Test_Rectifier.c
gcc -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -I/home/linuxdev/jmodelica/include/RuntimeLibrary -I/home/linuxdev/jmodelica/ThirdParty/FMI/2.0  -I/home/linuxdev/jmodelica/ThirdParty/Sundials/include -c -o HPF_Test_Test_Rectifier_equ_init.o sources/HPF_Test_Test_Rectifier_equ_init.c
mkdir -p binaries/linux64
g++ -shared -Wl,-rpath,'$ORIGIN',--no-undefined -pthread -std=c89 -pedantic -fPIC -msse2 -mfpmath=sse -o binaries/linux64/HPF_Test_Test_Rectifier.so  HPF_Test_Test_Rectifier_equ.o  HPF_Test_Test_Rectifier_base.o  HPF_Test_Test_Rectifier_init_dependent.o  HPF_Test_Test_Rectifier_init_independent.o  HPF_Test_Test_Rectifier_funcs.o  HPF_Test_Test_Rectifier.o  HPF_Test_Test_Rectifier_equ_init.o  -L/home/linuxdev/jmodelica/lib/RuntimeLibrary -lfmi2 -ljmi -ldl "-L/home/linuxdev/jmodelica/lib" -L"/home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Resources/Library/linux64/gcc921-9ubuntu2" -L"/home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Resources/Library/linux64" -L"/home/linuxdev/jmodelica/ThirdParty/MSL/Modelica/Resources/Library" -lModelicaIO -lModelicaMatIO -lzlib -ljmi_get_set_default -lModelicaIO -lModelicaMatIO -lzlib -ljmi_get_set_default -llapack -lblas -lgfortran -lModelicaExternalC -lzlib -ljmi -L/home/linuxdev/jmodelica/ThirdParty/Sundials/lib -l:libsundials_kinsol.a -l:libsundials_nvecserial.a -L/home/linuxdev/jmodelica/ThirdParty/Minpack/lib -l:libcminpack.a -lstdc++ -lm -l:libsundials_cvode.a
/usr/bin/ld: /home/linuxdev/jmodelica/lib/RuntimeLibrary/libModelicaMatIO.a(ModelicaMatIO.c.o): in function `Mat_VarDelete':
/home/linuxdev/tmp/JModelica.org/ThirdParty/MSL/Modelica/Resources/C-Sources/ModelicaMatIO.c:8521: warning: the use of `mktemp' is dangerous, better use `mkstemp' or `mkdtemp'
rm -f  HPF_Test_Test_Rectifier_equ.o  HPF_Test_Test_Rectifier_base.o  HPF_Test_Test_Rectifier_init_dependent.o  HPF_Test_Test_Rectifier_init_independent.o  HPF_Test_Test_Rectifier_funcs.o  HPF_Test_Test_Rectifier.o  HPF_Test_Test_Rectifier_equ_init.o 
make[1]: Leaving directory '/tmp/jmc17204345991466161181out'

