#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model HPF.Test.Test_Rectifier
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Thu Jul 18 23:56:34 2019

  Evaluate = true;
 */

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays0[3]={1.0, 3.0, 5.0};
static double DymArrays2[3]={10.0, 300.15, 0.0};
static double DymArrays4[6]={0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
static double DymArrays1[6]={100.0, 0.5, 0.225, 0.0, 0.25, -0.5};
static double DymArrays3[10]={0.95, 2.70064268049248E-05, -0.0015697610131034, 
  -0.00600037080602108, 0.995516922015768, -5.02372881045404E-05, 
  0.00237063924944842, -1.49993957428169, 1.71994407623008, 1.0};
#endif
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  double  theta_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(double   theta_02) {
  struct DymStruc0 dummy_0;
  dummy_0.theta_0member = theta_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC RealArray    HPF_Types_Reference_equalityConstraint(struct 
  DymStruc0 reference10_0, struct DymStruc0 reference20_0);
DYMOLA_STATIC double   Modelica_Math_atan3(double  u10_0, double  u20_0, double 
   y00_0);
/* Codes used in model */

/* Flattened Modelica model:

function HPF.Types.Reference.equalityConstraint
input HPF.Types.Reference reference1;
input HPF.Types.Reference reference2;
discrete output Real residue[0];

algorithm 
assert(abs(reference1.theta-reference2.theta) < 6.283185307179586E-06, "Reference angles should be equal!");
end HPF.Types.Reference.equalityConstraint;

  */
DYMOLA_STATIC RealArray    HPF_Types_Reference_equalityConstraint(struct 
  DymStruc0 reference10_0, struct DymStruc0 reference20_0) {
  PushContext("HPF.Types.Reference.equalityConstraint")
  {
    /* Declare outputs and temporaries */
    RealArray    residue0_0;
    MarkObject retmark_ = PushMark();
    residue0_0=RealTemporary( 1, 0);
    RePushMark(&retmark_);
    RealFillAssign( residue0_0, 0);
    /* Start of real code */
      AssertModelica(fabs(reference10_0.theta_0member-reference20_0.
        theta_0member) < 6.283185307179586E-06,"abs(reference1.theta-reference2.theta) < 6.283185307179586E-06",
         "Reference angles should be equal!");
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return residue0_0;
  }}

/* Flattened Modelica model:

function Modelica.Math.atan3
discrete input Real u1;
discrete input Real u2;
discrete input Real y0(start = 0, unit = "rad", displayUnit = "deg") "y shall be in the range: -pi < y-y0 <= pi";
discrete output Real y(unit = "rad", displayUnit = "deg");
protected 
constant Real pi2 = 6.283185307179586;
discrete Real w;
public 
algorithm 
w := atan2(u1, u2);
if (y0 == 0) then 
y := w;
else
y := w+pi2*integer((3.141592653589793+y0-w)/pi2);
end if;
end Modelica.Math.atan3;

  */
DYMOLA_STATIC double   Modelica_Math_atan3(double  u10_0, double  u20_0, double 
   y00_0) {
  PushContext("Modelica.Math.atan3")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   pi20_0;
    double   w0_0;
    y0_0=0;
    pi20_0 = 6.283185307179586;
    w0_0=0;
    /* Start of real code */
      w0_0 = atan2(u10_0, u20_0);
      if (y00_0 == 0) {
        y0_0 = w0_0;
      }
      else{
        y0_0 = w0_0+pi20_0*real2integer(divGuarded(3.141592653589793+y00_0-w0_0,
          "3.141592653589793+y0-w",pi20_0,"pi2"));
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}
/* DSblock C-code: */

#define NX_    1
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    149
#define NP_    0
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   1
#define MAXAuxStrLen_   500
#define NHash1_ -1273434512
#define NHash2_ -696539570
#define NHash3_ 0
#define NI_    0
#define NRelF_ 3
#define NRel_  3
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    87
#define SizePre_ 3
#define SizeEq_ 6
#define SizeDelay_ 0
#define QNLmax_ 3
#define MAXAux 3
#define NrDymolaTimers_ 0
#define NWhen_ 5
#define NCheckIf_ 0
#define NGlobalHelp_ 174
#define NGlobalHelpI_ 72
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="HPF.Test.Test_Rectifier";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,3) = 3;
DYNX(W_,22) = 3;
DYNX(W_,29) = 3;
DYNX(W_,49) = 3;
DYNX(W_,58) = 3;
DYNX(W_,71) = 3;
DYNX(W_,93) = false;
DYNX(W_,111) = 3;
DYNX(W_,112) = 3;
DYNX(W_,132) = 3;
DYNX(W_,134) = 3;
memcpy(&DYNX(W_,0), &DymArrays0, sizeof(double)*3);
DYNX(W_,4) = 3;
DYNX(W_,5) = 60;
memcpy(&DYNX(W_,36), &DymArrays1, sizeof(double)*6);
#endif
DYNSetAuxString(did_, "Impedance", 0);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,65) = 10.0;
DYNX(W_,66) = 2.0;
memcpy(&DYNX(W_,84), &DymArrays2, sizeof(double)*3);
DYNX(W_,94) = 300.15;
DYNX(W_,119) = 100;
DYNX(W_,100) = 100.0;
memcpy(&DYNX(W_,120), &DymArrays3, sizeof(double)*10);
DYNX(W_,24) = 0.0;
DYNX(W_,23) = 100.0;
DYNX(W_,91) = 0;
DYNX(W_,89) = 100.0;
DYNX(W_,87) = 100.0;
DYNX(W_,88) = 10.0;
DYNX(W_,130) = -1000.0;
DYNX(W_,142) = -950.0;
DYNX(W_,26) = 0.12370197962726147;
DYNX(W_,25) = 0.48445621085532237;
DYNX(W_,28) = -0.10787074618594568;
DYNX(W_,27) = 0.1974560764253339;
DYNX(W_,64) = 2;
DYNX(W_,95) = 1000.0;
DYNX(W_,99) = 0.0;
DYNX(W_,148) = 9854;
DYNX(W_,133) = 376.99111843077515;
DYNX(W_,57) = 376.99111843077515;
DYNX(W_,73) = 0.0;
DYNX(W_,72) = 0.0;
DYNX(W_,75) = 0.0;
DYNX(W_,74) = 0.0;
DYNX(W_,77) = 0.0;
DYNX(W_,76) = 0.0;
DYNX(W_,98) = 0.0;
DYNX(W_,141) = 0.5;
DYNX(W_,143) = 0.5;
DYNX(W_,145) = 0.0;
DYNX(W_,144) = 0.0;
DYNX(W_,147) = 0.0;
DYNX(W_,146) = 0.0;
DYNX(W_,102) = -10.0;
DYNX(W_,106) = 10.0;
DYNX(W_,105) = 0.0;
DYNX(W_,104) = -10.0;
DYNX(W_,103) = 100.0;
DYNX(W_,101) = 100.0;
DYNX(W_,114) = 0.0;
DYNX(W_,113) = 0.0;
DYNX(W_,116) = 0.0;
DYNX(W_,115) = 0.0;
DYNX(W_,118) = 0.0;
DYNX(W_,117) = 0.0;
DYNX(W_,131) = 376.99111843077515;
DYNX(W_,136) = 0.0;
DYNX(W_,135) = 0.0;
DYNX(W_,138) = 0.0;
DYNX(W_,137) = 0.0;
DYNX(W_,140) = 0.0;
DYNX(W_,139) = 0.0;
DYNX(W_,110) = 10.0;
DYNX(W_,109) = 0.0;
DYNX(W_,108) = -10.0;
DYNX(W_,107) = 100.0;
DYNX(W_,97) = 10.0;
DYNX(W_,96) = 300.15;
DYNX(W_,92) = -10.0;
DYNX(W_,90) = 10.0;
DYNX(W_,21) = 376.99111843077515;
DYNX(W_,31) = 0.0;
DYNX(W_,30) = 0.0;
DYNX(W_,33) = 0.0;
DYNX(W_,32) = 0.0;
DYNX(W_,35) = 0.0;
DYNX(W_,34) = 0.0;
DYNX(W_,10) = 0.0;
DYNX(W_,9) = 100.0;
DYNX(W_,12) = 0.12370197962726147;
DYNX(W_,11) = 0.48445621085532237;
DYNX(W_,14) = -0.10787074618594568;
DYNX(W_,13) = 0.1974560764253339;
DYNX(W_,48) = 376.99111843077515;
DYNX(W_,51) = 0.0;
DYNX(W_,50) = 100.0;
DYNX(W_,53) = 0.12370197962726147;
DYNX(W_,52) = 0.48445621085532237;
DYNX(W_,55) = -0.10787074618594568;
DYNX(W_,54) = 0.1974560764253339;
memcpy(&DYNX(W_,78), &DymArrays4, sizeof(double)*6);
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,6) = false;
DYNX(W_,7) = false;
DYNX(W_,8) = false;
DYNX(W_,15) = 0;
DYNX(W_,16) = 0;
DYNX(W_,17) = 0;
DYNX(W_,18) = 0;
DYNX(W_,19) = 0;
DYNX(W_,20) = 0;
DYNX(W_,42) = 0;
DYNX(W_,43) = 0;
DYNX(W_,44) = 0;
DYNX(W_,45) = 0;
DYNX(W_,46) = 0;
DYNX(W_,47) = 0;
DYNX(W_,59) = 0;
DYNX(W_,60) = 0;
DYNX(W_,61) = 0;
DYNX(W_,62) = 0;
DYNX(W_,63) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,8);
DYNX(Aux_,1) = DYNX(W_,7);
DYNX(Aux_,2) = DYNX(W_,6);
InitialSection
InitialSection2
DYNX(F_,0) = 376.99111843077515;
DYNX(W_,78) = 0.0;
DYNX(W_,79) = 0.0;
DYNX(W_,80) = 0.0;
DYNX(W_,81) = 0.0;
DYNX(W_,82) = 0.0;
DYNX(W_,83) = 0.0;
DYNX(W_,8) = DYNX(Aux_,0);
DYNX(W_,6) = DYNX(Aux_,2);
DYNX(W_,7) = DYNX(Aux_,1);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
InitialSection2
EndInitialSection

OutputSection

DynamicsSection
DYNX(F_,0) = 376.99111843077515;

AcceptedSection1
DYNX(W_,6) = PRE(DYNX(W_,6), 0);
DYNX(W_,7) = PRE(DYNX(W_,7), 1);
DYNX(W_,8) = PRE(DYNX(W_,8), 2);
  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.5,"0.5", 0), 0) 
    DYNX(W_,6) = true;
  endwhenModelica()
  endwhenBlock

  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.25,"0.25", 1), 1) 
    DYNX(W_,7) = true;
  endwhenModelica()
  endwhenBlock

  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.4,"0.4", 2), 2) 
    DYNX(W_,8) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,56) = DYNX(X_,0);

  beginwhenBlock
  whenModelica(( DYNX(W_,7) != PRE(DYNX(W_,7), 1) ), 3) 
    /* No equations */
  endwhenModelica()
  endwhenBlock

  beginwhenBlock
  whenModelica(( DYNX(W_,8) != PRE(DYNX(W_,8), 2) ), 4) 
    /* No equations */
  endwhenModelica()
  endwhenBlock

RealFillAssign ((PushModelContext(1,"HPF.Types.Reference.equalityConstraint(\nv.pin_p.reference, \nz.pin_p.reference)")
  HPF_Types_Reference_equalityConstraint(DymStruc0_construct(DYNX(X_,0)), 
  DymStruc0_construct(DYNX(W_,56)))), 0);
PopAllMarks();
AcceptedSection2

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 12 common subexpressions used in 7 expressions */
/* Of the common subexpressions 11 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"z.v[1].re", "v.i[1].re"};
const double nominal_[]={1.0, 1.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 0, 0, 1, -2, 1, 
  DYNX(DYNhelp,0), 55, DYNX(did_->helpvari_vec,0), 24);
NonLinearSystemSave(DYNX(W_,6), 0);
SetInitVectorNH(x__, 1, DYNX(W_,42), Remember_(DYNX(W_,42), 0));
SetInitVectorNH(x__, 2, DYNX(W_,15), Remember_(DYNX(W_,15), 1));
Residues;
  DYNX(W_,59) = 100.0-DYNX(W_,42);
  DYNX(W_,16) = 0.5*(DYNX(W_,42)+10.0*DYNX(W_,15));
  DYNX(W_,43) = (-10.0)*DYNX(W_,16)-2.0*DYNX(W_,15);
DYNX(DYNhelp,55) = DYNX(W_,6) == false;
SetVector(residue__, 1, IF DYNX(DYNhelp,55) THEN DYNX(W_,59)*DYNX(W_,15)-950.0
   ELSE (-0.2178461464695957)-DYNX(W_,15));
SetVector(residue__, 2, IF DYNX(DYNhelp,55) THEN 0.5+DYNX(W_,43)*DYNX(W_,16)
   ELSE (-0.9636572415972904)-DYNX(W_,16));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,56) = IF DYNX(DYNhelp,55) THEN DYNX(W_,16) ELSE 0.0;
DYNX(DYNhelp,57) = (IF DYNX(DYNhelp,55) THEN DYNX(W_,43) ELSE -1.0)-10.0*
  DYNX(DYNhelp,56);
SetMatrixLeading(Jacobian__, 1, 1, 2, (-1.0)*(IF DYNX(DYNhelp,55) THEN 
  DYNX(W_,15) ELSE 0.0));
SetMatrixLeading(Jacobian__, 1, 2, 2, IF DYNX(DYNhelp,55) THEN DYNX(W_,59) ELSE 
  -1.0);
SetMatrixLeading(Jacobian__, 2, 1, 2, 0.5*DYNX(DYNhelp,57));
SetMatrixLeading(Jacobian__, 2, 2, 2, 5.0*DYNX(DYNhelp,57)-2.0*DYNX(DYNhelp,56));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 1, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,42) = GetVector(x__, 1);
DYNX(W_,15) = GetVector(x__, 2);
EndNonLinearSystemOfEquationsNH(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }




{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[2] */
/* Introducing 12 common subexpressions used in 7 expressions */
/* Of the common subexpressions 11 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"z.v[2].re", "v.i[2].re"};
const double nominal_[]={1.0, 1.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 0, 0, 2, -2, 1, 
  DYNX(DYNhelp,58), 55, DYNX(did_->helpvari_vec,24), 24);
NonLinearSystemSave(DYNX(W_,6), 0);
SetInitVectorNH(x__, 1, DYNX(W_,44), Remember_(DYNX(W_,44), 2));
SetInitVectorNH(x__, 2, DYNX(W_,17), Remember_(DYNX(W_,17), 3));
Residues;
  DYNX(W_,60) = 0.48445621085532237-DYNX(W_,44);
  DYNX(W_,18) = 0.16666666666666666*(DYNX(W_,44)+10.0*DYNX(W_,17));
  DYNX(W_,45) = (-10.0)*DYNX(W_,18)-6.0*DYNX(W_,17);
  DYNX(W_,61) = 0.12370197962726147-DYNX(W_,45);
DYNX(DYNhelp,113) = DYNX(W_,6) == false;
SetVector(residue__, 1, IF DYNX(DYNhelp,113) THEN DYNX(W_,60)*DYNX(W_,17) ELSE 
  0.3591299749978818-DYNX(W_,17));
SetVector(residue__, 2, IF DYNX(DYNhelp,113) THEN  -DYNX(W_,61)*DYNX(W_,18)
   ELSE 0.8947332055630648-DYNX(W_,18));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,114) = IF DYNX(DYNhelp,113) THEN  -DYNX(W_,18) ELSE 0.0;
DYNX(DYNhelp,115) = (IF DYNX(DYNhelp,113) THEN  -DYNX(W_,61) ELSE -1.0)+10.0*
  DYNX(DYNhelp,114);
SetMatrixLeading(Jacobian__, 1, 1, 2, (-1.0)*(IF DYNX(DYNhelp,113) THEN 
  DYNX(W_,17) ELSE 0.0));
SetMatrixLeading(Jacobian__, 1, 2, 2, IF DYNX(DYNhelp,113) THEN DYNX(W_,60)
   ELSE -1.0);
SetMatrixLeading(Jacobian__, 2, 1, 2, 0.16666666666666666*DYNX(DYNhelp,115));
SetMatrixLeading(Jacobian__, 2, 2, 2, 1.6666666666666665*DYNX(DYNhelp,115)+6.0*
  DYNX(DYNhelp,114));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 2, 
  "Tag: simulation.nonlinear[2]");
DYNX(W_,44) = GetVector(x__, 1);
DYNX(W_,17) = GetVector(x__, 2);
EndNonLinearSystemOfEquationsNH(residue__, x__, 2);
 /* End of Non-Linear Equation Block */ }




{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[3] */
/* Introducing 10 common subexpressions used in 7 expressions */
/* Of the common subexpressions 9 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"z.v[3].re", "v.i[3].re"};
const double nominal_[]={1.0, 1.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 0, 0, 3, -2, 1, 
  DYNX(DYNhelp,116), 55, DYNX(did_->helpvari_vec,48), 24);
NonLinearSystemSave(DYNX(W_,6), 0);
SetInitVectorNH(x__, 1, DYNX(W_,46), Remember_(DYNX(W_,46), 4));
SetInitVectorNH(x__, 2, DYNX(W_,19), Remember_(DYNX(W_,19), 5));
Residues;
  DYNX(W_,62) = 0.1974560764253339-DYNX(W_,46);
  DYNX(W_,20) = 0.1*(DYNX(W_,46)+10.0*DYNX(W_,19));
  DYNX(W_,47) = (-10.0)*(DYNX(W_,20)+DYNX(W_,19));
  DYNX(W_,63) = (-0.10787074618594568)-DYNX(W_,47);
DYNX(DYNhelp,171) = DYNX(W_,6) == false;
SetVector(residue__, 1, IF DYNX(DYNhelp,171) THEN DYNX(W_,62)*DYNX(W_,19) ELSE (
  -0.49099092384203735)-DYNX(W_,19));
SetVector(residue__, 2, IF DYNX(DYNhelp,171) THEN  -DYNX(W_,63)*DYNX(W_,20)
   ELSE (-0.7894119146546077)-DYNX(W_,20));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,172) = 10.0*(IF DYNX(DYNhelp,171) THEN  -DYNX(W_,20) ELSE 0.0);
DYNX(DYNhelp,173) = (IF DYNX(DYNhelp,171) THEN  -DYNX(W_,63) ELSE -1.0)+
  DYNX(DYNhelp,172);
SetMatrixLeading(Jacobian__, 1, 1, 2, (-1.0)*(IF DYNX(DYNhelp,171) THEN 
  DYNX(W_,19) ELSE 0.0));
SetMatrixLeading(Jacobian__, 1, 2, 2, IF DYNX(DYNhelp,171) THEN DYNX(W_,62)
   ELSE -1.0);
SetMatrixLeading(Jacobian__, 2, 1, 2, 0.1*DYNX(DYNhelp,173));
SetMatrixLeading(Jacobian__, 2, 2, 2, DYNX(DYNhelp,173)+DYNX(DYNhelp,172));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 3, 
  "Tag: simulation.nonlinear[3]");
DYNX(W_,46) = GetVector(x__, 1);
DYNX(W_,19) = GetVector(x__, 2);
EndNonLinearSystemOfEquationsNH(residue__, x__, 3);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,67) = powGuarded(sqr(DYNX(W_,42))+sqr(DYNX(W_,43)),"z.v[1].re^2+z.v[1].im^2",
  0.5,"0.5");
DYNX(W_,68) = (PushModelContext(1,"Modelica.Math.atan3(z.v[1].im, z.v[1].re, 0)")
  Modelica_Math_atan3(DYNX(W_,43), DYNX(W_,42), 0));
PopModelContext();
DYNX(W_,69) = powGuarded(sqr(DYNX(W_,15))+sqr(DYNX(W_,16)),"v.i[1].re^2+v.i[1].im^2",
  0.5,"0.5");
DYNX(W_,70) = (PushModelContext(1,"Modelica.Math.atan3( -v.i[1].im,  -v.i[1].re, 0)")
  Modelica_Math_atan3( -DYNX(W_,16),  -DYNX(W_,15), 0));
PopModelContext();

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("systemDef.hrms[1]", "Harmonics to simulate [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("systemDef.hrms[2]", "Harmonics to simulate [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("systemDef.hrms[3]", "Harmonics to simulate [:#(type=Integer)]",\
 5, 0.0,0.0,0.0,0,517)
DeclareVariable("systemDef.numHrm", "Number of harmonics. (Automatically generated from hrms. Do not alter) [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("systemDef.numPh", "Number of phases [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("systemDef.fFund", "Fundamental frequency", 60, 0.0,0.0,0.0,0,513)
DeclareVariable("systemDef.modeSelect", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,\
0,658)
DeclareVariable("systemDef.eventWriteData", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,658)
DeclareVariable("systemDef.eventReadData", "[:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,658)
DeclareVariable("v.v[1].re", "Real part of complex number", 100.0, 0.0,0.0,1.0,0,513)
DeclareVariable("v.v[1].im", "Imaginary part of complex number", 0.0, 0.0,0.0,\
1.0,0,513)
DeclareVariable("v.v[2].re", "Real part of complex number", 0.48445621085532237,\
 0.0,0.0,1.0,0,513)
DeclareVariable("v.v[2].im", "Imaginary part of complex number", \
0.12370197962726147, 0.0,0.0,1.0,0,513)
DeclareVariable("v.v[3].re", "Real part of complex number", 0.1974560764253339, \
0.0,0.0,1.0,0,513)
DeclareVariable("v.v[3].im", "Imaginary part of complex number", \
-0.10787074618594568, 0.0,0.0,1.0,0,513)
DeclareVariable("v.i[1].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareVariable("v.i[1].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("v.i[2].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareVariable("v.i[2].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("v.i[3].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareVariable("v.i[3].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("v.omega", "[rad/s]", 376.99111843077515, 0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_p.h", "Numbder of harmonics [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,525)
DeclareVariable("v.pin_p.v[1].re", "Real part of complex number", 100.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_p.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_p.v[2].re", "Real part of complex number", \
0.48445621085532237, 0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_p.v[2].im", "Imaginary part of complex number", \
0.12370197962726147, 0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_p.v[3].re", "Real part of complex number", \
0.1974560764253339, 0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_p.v[3].im", "Imaginary part of complex number", \
-0.10787074618594568, 0.0,0.0,0.0,0,513)
DeclareAlias2("v.pin_p.iIm[1]", "", "v.i[1].im", 1, 5, 16, 132)
DeclareAlias2("v.pin_p.iIm[2]", "", "v.i[2].im", 1, 5, 18, 132)
DeclareAlias2("v.pin_p.iIm[3]", "", "v.i[3].im", 1, 5, 20, 132)
DeclareAlias2("v.pin_p.iRe[1]", "", "v.i[1].re", 1, 5, 15, 132)
DeclareAlias2("v.pin_p.iRe[2]", "", "v.i[2].re", 1, 5, 17, 132)
DeclareAlias2("v.pin_p.iRe[3]", "", "v.i[3].re", 1, 5, 19, 132)
DeclareState("v.pin_p.reference.theta", "[rad|deg]", 0, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("v.pin_p.reference.der(theta)", "[rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("v.pin_n.h", "Numbder of harmonics [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,525)
DeclareVariable("v.pin_n.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("v.pin_n.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_n.v[2].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("v.pin_n.v[2].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_n.v[3].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("v.pin_n.v[3].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("v.pin_n.iIm[1]", "", "v.i[1].im", -1, 5, 16, 132)
DeclareAlias2("v.pin_n.iIm[2]", "", "v.i[2].im", -1, 5, 18, 132)
DeclareAlias2("v.pin_n.iIm[3]", "", "v.i[3].im", -1, 5, 20, 132)
DeclareAlias2("v.pin_n.iRe[1]", "", "v.i[1].re", -1, 5, 15, 132)
DeclareAlias2("v.pin_n.iRe[2]", "", "v.i[2].re", -1, 5, 17, 132)
DeclareAlias2("v.pin_n.iRe[3]", "", "v.i[3].re", -1, 5, 19, 132)
DeclareAlias2("v.pin_n.reference.theta", "[rad|deg]", "v.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareAlias2("v.theta", "[rad|deg]", "v.pin_p.reference.theta", 1, 1, 0, 0)
DeclareVariable("v.vMag[1]", "Voltage Magnitude (Volts rms)", 100.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("v.vMag[2]", "Voltage Magnitude (Volts rms)", 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("v.vMag[3]", "Voltage Magnitude (Volts rms)", 0.225, 0.0,0.0,0.0,\
0,513)
DeclareVariable("v.vArg[1]", "Voltage angle (rad)", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("v.vArg[2]", "Voltage angle (rad)", 0.25, 0.0,0.0,0.0,0,513)
DeclareVariable("v.vArg[3]", "Voltage angle (rad)", -0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("z.v[1].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareVariable("z.v[1].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("z.v[2].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareVariable("z.v[2].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("z.v[3].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareVariable("z.v[3].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareAlias2("z.i[1].re", "Real part of complex number", "v.i[1].re", -1, 5, 15,\
 0)
DeclareAlias2("z.i[1].im", "Imaginary part of complex number", "v.i[1].im", -1, 5,\
 16, 0)
DeclareAlias2("z.i[2].re", "Real part of complex number", "v.i[2].re", -1, 5, 17,\
 0)
DeclareAlias2("z.i[2].im", "Imaginary part of complex number", "v.i[2].im", -1, 5,\
 18, 0)
DeclareAlias2("z.i[3].re", "Real part of complex number", "v.i[3].re", -1, 5, 19,\
 0)
DeclareAlias2("z.i[3].im", "Imaginary part of complex number", "v.i[3].im", -1, 5,\
 20, 0)
DeclareVariable("z.omega", "[rad/s]", 376.99111843077515, 0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_p.h", "Numbder of harmonics [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,525)
DeclareVariable("z.pin_p.v[1].re", "Real part of complex number", 100.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_p.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_p.v[2].re", "Real part of complex number", \
0.48445621085532237, 0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_p.v[2].im", "Imaginary part of complex number", \
0.12370197962726147, 0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_p.v[3].re", "Real part of complex number", \
0.1974560764253339, 0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_p.v[3].im", "Imaginary part of complex number", \
-0.10787074618594568, 0.0,0.0,0.0,0,513)
DeclareAlias2("z.pin_p.iIm[1]", "", "v.i[1].im", -1, 5, 16, 132)
DeclareAlias2("z.pin_p.iIm[2]", "", "v.i[2].im", -1, 5, 18, 132)
DeclareAlias2("z.pin_p.iIm[3]", "", "v.i[3].im", -1, 5, 20, 132)
DeclareAlias2("z.pin_p.iRe[1]", "", "v.i[1].re", -1, 5, 15, 132)
DeclareAlias2("z.pin_p.iRe[2]", "", "v.i[2].re", -1, 5, 17, 132)
DeclareAlias2("z.pin_p.iRe[3]", "", "v.i[3].re", -1, 5, 19, 132)
DeclareVariable("z.pin_p.reference.theta", "[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("z.pin_p.reference.der(theta)", "[rad/s]", 376.99111843077515, \
0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_n.h", "Numbder of harmonics [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,525)
DeclareVariable("z.pin_n.v[1].re", "Real part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareAlias2("z.pin_n.v[1].im", "Imaginary part of complex number", "z.v[1].im", -1,\
 5, 43, 64)
DeclareVariable("z.pin_n.v[2].re", "Real part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("z.pin_n.v[2].im", "Imaginary part of complex number", 0, \
0.0,0.0,1.0,0,640)
DeclareVariable("z.pin_n.v[3].re", "Real part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("z.pin_n.v[3].im", "Imaginary part of complex number", 0, \
0.0,0.0,1.0,0,640)
DeclareAlias2("z.pin_n.iIm[1]", "", "v.i[1].im", 1, 5, 16, 132)
DeclareAlias2("z.pin_n.iIm[2]", "", "v.i[2].im", 1, 5, 18, 132)
DeclareAlias2("z.pin_n.iIm[3]", "", "v.i[3].im", 1, 5, 20, 132)
DeclareAlias2("z.pin_n.iRe[1]", "", "v.i[1].re", 1, 5, 15, 132)
DeclareAlias2("z.pin_n.iRe[2]", "", "v.i[2].re", 1, 5, 17, 132)
DeclareAlias2("z.pin_n.iRe[3]", "", "v.i[3].re", 1, 5, 19, 132)
DeclareAlias2("z.pin_n.reference.theta", "[rad|deg]", "v.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareVariable("z.a", "", 2, 0.0,0.0,0.0,0,513)
DeclareVariable("z.z.re", "Real part of complex number", 10.0, 0.0,0.0,0.0,0,513)
DeclareVariable("z.z.im", "Imaginary part of complex number", 2.0, 0.0,0.0,0.0,0,513)
DeclareVariable("z.vFundAbs", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("z.vFundArg", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("z.iFundAbs", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("z.iFundArg", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("ground1.pin.h", "Numbder of harmonics [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,525)
DeclareVariable("ground1.pin.v[1].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[2].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[2].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[3].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[3].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.iIm[1]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iIm[2]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iIm[3]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iRe[1]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iRe[2]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iRe[3]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("ground1.pin.reference.theta", "[rad|deg]", "v.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareVariable("resistor1.R", "Resistance at temperature T_ref [Ohm]", 10, \
0.0,0.0,0.0,0,513)
DeclareVariable("resistor1.T_ref", "Reference temperature [K|degC]", 300.15, 0.0,\
1E+100,300.0,0,513)
DeclareVariable("resistor1.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("resistor1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 100.0, 0.0,0.0,0.0,0,513)
DeclareVariable("resistor1.i", "Current flowing from pin p to pin n [A]", 10.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("resistor1.p.v", "Potential at the pin [V]", 100.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("resistor1.p.i", "Current flowing into the pin [A]", 10.0, \
0.0,0.0,0.0,0,777)
DeclareVariable("resistor1.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("resistor1.n.i", "Current flowing into the pin [A]", -10.0, \
0.0,0.0,0.0,0,777)
DeclareVariable("resistor1.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("resistor1.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 300.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("resistor1.LossPower", "Loss power leaving component via heatPort [W]",\
 1000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("resistor1.T_heatPort", "Temperature of heatPort [K|degC]", \
300.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("resistor1.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 10.0, 0.0,0.0,0.0,0,513)
DeclareVariable("ground2.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("ground2.p.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,\
0.0,0,777)
DeclareVariable("rectifier1.constantVoltage1.V", "Value of constant voltage [V]",\
 100.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.constantVoltage1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 100.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.constantVoltage1.i", "Current flowing from pin p to pin n [A]",\
 -10.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.constantVoltage1.p.v", "Potential at the pin [V]", \
100.0, 0.0,0.0,0.0,0,521)
DeclareVariable("rectifier1.constantVoltage1.p.i", "Current flowing into the pin [A]",\
 -10.0, 0.0,0.0,0.0,0,777)
DeclareVariable("rectifier1.constantVoltage1.n.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("rectifier1.constantVoltage1.n.i", "Current flowing into the pin [A]",\
 10.0, 0.0,0.0,0.0,0,777)
DeclareVariable("rectifier1.pin_p.v", "Potential at the pin [V]", 100.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("rectifier1.pin_p.i", "Current flowing into the pin [A]", -10.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("rectifier1.pin_n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareVariable("rectifier1.pin_n.i", "Current flowing into the pin [A]", 10.0, \
0.0,0.0,0.0,0,777)
DeclareVariable("rectifier1.hPin_P.h", "Numbder of harmonics [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,525)
DeclareAlias2("rectifier1.hPin_P.v[1].re", "Real part of complex number", \
"z.pin_n.v[1].re", 1, 5, 59, 0)
DeclareAlias2("rectifier1.hPin_P.v[1].im", "Imaginary part of complex number", \
"z.v[1].im", -1, 5, 43, 0)
DeclareAlias2("rectifier1.hPin_P.v[2].re", "Real part of complex number", \
"z.pin_n.v[2].re", 1, 5, 60, 0)
DeclareAlias2("rectifier1.hPin_P.v[2].im", "Imaginary part of complex number", \
"z.pin_n.v[2].im", 1, 5, 61, 0)
DeclareAlias2("rectifier1.hPin_P.v[3].re", "Real part of complex number", \
"z.pin_n.v[3].re", 1, 5, 62, 0)
DeclareAlias2("rectifier1.hPin_P.v[3].im", "Imaginary part of complex number", \
"z.pin_n.v[3].im", 1, 5, 63, 0)
DeclareAlias2("rectifier1.hPin_P.iIm[1]", "", "v.i[1].im", -1, 5, 16, 132)
DeclareAlias2("rectifier1.hPin_P.iIm[2]", "", "v.i[2].im", -1, 5, 18, 132)
DeclareAlias2("rectifier1.hPin_P.iIm[3]", "", "v.i[3].im", -1, 5, 20, 132)
DeclareAlias2("rectifier1.hPin_P.iRe[1]", "", "v.i[1].re", -1, 5, 15, 132)
DeclareAlias2("rectifier1.hPin_P.iRe[2]", "", "v.i[2].re", -1, 5, 17, 132)
DeclareAlias2("rectifier1.hPin_P.iRe[3]", "", "v.i[3].re", -1, 5, 19, 132)
DeclareAlias2("rectifier1.hPin_P.reference.theta", "[rad|deg]", "v.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareVariable("rectifier1.hPin_N.h", "Numbder of harmonics [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,525)
DeclareVariable("rectifier1.hPin_N.v[1].re", "Real part of complex number", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hPin_N.v[1].im", "Imaginary part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hPin_N.v[2].re", "Real part of complex number", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hPin_N.v[2].im", "Imaginary part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hPin_N.v[3].re", "Real part of complex number", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hPin_N.v[3].im", "Imaginary part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("rectifier1.hPin_N.iIm[1]", "", "v.i[1].im", 1, 5, 16, 132)
DeclareAlias2("rectifier1.hPin_N.iIm[2]", "", "v.i[2].im", 1, 5, 18, 132)
DeclareAlias2("rectifier1.hPin_N.iIm[3]", "", "v.i[3].im", 1, 5, 20, 132)
DeclareAlias2("rectifier1.hPin_N.iRe[1]", "", "v.i[1].re", 1, 5, 15, 132)
DeclareAlias2("rectifier1.hPin_N.iRe[2]", "", "v.i[2].re", 1, 5, 17, 132)
DeclareAlias2("rectifier1.hPin_N.iRe[3]", "", "v.i[3].re", 1, 5, 19, 132)
DeclareAlias2("rectifier1.hPin_N.reference.theta", "[rad|deg]", "v.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareVariable("rectifier1.V_Rect", "Rectifier DC output [V]", 100, 0.0,0.0,0.0,\
0,513)
DeclareVariable("rectifier1.efficiency", "Rectifier efficiency", 0.95, 0.0,0.0,\
0.0,0,513)
DeclareVariable("rectifier1.hrmMdl_coefMag[1]", "Harmonic model magnitude polynomial coefficient",\
 2.70064268049248E-05, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hrmMdl_coefMag[2]", "Harmonic model magnitude polynomial coefficient",\
 -0.0015697610131034, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hrmMdl_coefMag[3]", "Harmonic model magnitude polynomial coefficient",\
 -0.00600037080602108, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hrmMdl_coefMag[4]", "Harmonic model magnitude polynomial coefficient",\
 0.995516922015768, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hrmMdl_coefArg[1]", "Harmonic model argument (angle, [rad]) polynomial coefficient",\
 -5.02372881045404E-05, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hrmMdl_coefArg[2]", "Harmonic model argument (angle, [rad]) polynomial coefficient",\
 0.00237063924944842, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hrmMdl_coefArg[3]", "Harmonic model argument (angle, [rad]) polynomial coefficient",\
 -1.49993957428169, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.hrmMdl_coefArg[4]", "Harmonic model argument (angle, [rad]) polynomial coefficient",\
 1.71994407623008, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.rectifierModel", "Rectifier model (Other model parameters passed as a record?)",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.P", "[W]", -1000.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("rectifier1.loadBase1.v[1].re", "Real part of complex number", \
"z.pin_n.v[1].re", 1, 5, 59, 64)
DeclareAlias2("rectifier1.loadBase1.v[1].im", "Imaginary part of complex number",\
 "z.v[1].im", -1, 5, 43, 64)
DeclareAlias2("rectifier1.loadBase1.v[2].re", "Real part of complex number", \
"z.pin_n.v[2].re", 1, 5, 60, 64)
DeclareAlias2("rectifier1.loadBase1.v[2].im", "Imaginary part of complex number",\
 "z.pin_n.v[2].im", 1, 5, 61, 64)
DeclareAlias2("rectifier1.loadBase1.v[3].re", "Real part of complex number", \
"z.pin_n.v[3].re", 1, 5, 62, 64)
DeclareAlias2("rectifier1.loadBase1.v[3].im", "Imaginary part of complex number",\
 "z.pin_n.v[3].im", 1, 5, 63, 64)
DeclareAlias2("rectifier1.loadBase1.i[1].re", "Real part of complex number", \
"v.i[1].re", -1, 5, 15, 0)
DeclareAlias2("rectifier1.loadBase1.i[1].im", "Imaginary part of complex number",\
 "v.i[1].im", -1, 5, 16, 0)
DeclareAlias2("rectifier1.loadBase1.i[2].re", "Real part of complex number", \
"v.i[2].re", -1, 5, 17, 0)
DeclareAlias2("rectifier1.loadBase1.i[2].im", "Imaginary part of complex number",\
 "v.i[2].im", -1, 5, 18, 0)
DeclareAlias2("rectifier1.loadBase1.i[3].re", "Real part of complex number", \
"v.i[3].re", -1, 5, 19, 0)
DeclareAlias2("rectifier1.loadBase1.i[3].im", "Imaginary part of complex number",\
 "v.i[3].im", -1, 5, 20, 0)
DeclareVariable("rectifier1.loadBase1.omega", "[rad/s]", 376.99111843077515, \
0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.loadBase1.pin_p.h", "Numbder of harmonics [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,525)
DeclareAlias2("rectifier1.loadBase1.pin_p.v[1].re", "Real part of complex number",\
 "z.pin_n.v[1].re", 1, 5, 59, 0)
DeclareAlias2("rectifier1.loadBase1.pin_p.v[1].im", "Imaginary part of complex number",\
 "z.v[1].im", -1, 5, 43, 0)
DeclareAlias2("rectifier1.loadBase1.pin_p.v[2].re", "Real part of complex number",\
 "z.pin_n.v[2].re", 1, 5, 60, 0)
DeclareAlias2("rectifier1.loadBase1.pin_p.v[2].im", "Imaginary part of complex number",\
 "z.pin_n.v[2].im", 1, 5, 61, 0)
DeclareAlias2("rectifier1.loadBase1.pin_p.v[3].re", "Real part of complex number",\
 "z.pin_n.v[3].re", 1, 5, 62, 0)
DeclareAlias2("rectifier1.loadBase1.pin_p.v[3].im", "Imaginary part of complex number",\
 "z.pin_n.v[3].im", 1, 5, 63, 0)
DeclareAlias2("rectifier1.loadBase1.pin_p.iIm[1]", "", "v.i[1].im", -1, 5, 16, 132)
DeclareAlias2("rectifier1.loadBase1.pin_p.iIm[2]", "", "v.i[2].im", -1, 5, 18, 132)
DeclareAlias2("rectifier1.loadBase1.pin_p.iIm[3]", "", "v.i[3].im", -1, 5, 20, 132)
DeclareAlias2("rectifier1.loadBase1.pin_p.iRe[1]", "", "v.i[1].re", -1, 5, 15, 132)
DeclareAlias2("rectifier1.loadBase1.pin_p.iRe[2]", "", "v.i[2].re", -1, 5, 17, 132)
DeclareAlias2("rectifier1.loadBase1.pin_p.iRe[3]", "", "v.i[3].re", -1, 5, 19, 132)
DeclareAlias2("rectifier1.loadBase1.pin_p.reference.theta", "[rad|deg]", \
"v.pin_p.reference.theta", 1, 1, 0, 0)
DeclareVariable("rectifier1.loadBase1.pin_p.reference.der(theta)", "[rad/s]", \
376.99111843077515, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.loadBase1.pin_n.h", "Numbder of harmonics [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,525)
DeclareVariable("rectifier1.loadBase1.pin_n.v[1].re", "Real part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.loadBase1.pin_n.v[1].im", "Imaginary part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.loadBase1.pin_n.v[2].re", "Real part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.loadBase1.pin_n.v[2].im", "Imaginary part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.loadBase1.pin_n.v[3].re", "Real part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rectifier1.loadBase1.pin_n.v[3].im", "Imaginary part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("rectifier1.loadBase1.pin_n.iIm[1]", "", "v.i[1].im", 1, 5, 16, 132)
DeclareAlias2("rectifier1.loadBase1.pin_n.iIm[2]", "", "v.i[2].im", 1, 5, 18, 132)
DeclareAlias2("rectifier1.loadBase1.pin_n.iIm[3]", "", "v.i[3].im", 1, 5, 20, 132)
DeclareAlias2("rectifier1.loadBase1.pin_n.iRe[1]", "", "v.i[1].re", 1, 5, 15, 132)
DeclareAlias2("rectifier1.loadBase1.pin_n.iRe[2]", "", "v.i[2].re", 1, 5, 17, 132)
DeclareAlias2("rectifier1.loadBase1.pin_n.iRe[3]", "", "v.i[3].re", 1, 5, 19, 132)
DeclareAlias2("rectifier1.loadBase1.pin_n.reference.theta", "[rad|deg]", \
"v.pin_p.reference.theta", 1, 1, 0, 0)
DeclareVariable("rectifier1.Q", "", 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("rectifier1.S_vect[1].re", "Real part of complex number", -950.0,\
 0.0,0.0,1.0,0,2561)
DeclareVariable("rectifier1.S_vect[1].im", "Imaginary part of complex number", \
0.5, 0.0,0.0,1.0,0,2561)
DeclareVariable("rectifier1.S_vect[2].re", "Real part of complex number", 0.0, \
0.0,0.0,1.0,0,2561)
DeclareVariable("rectifier1.S_vect[2].im", "Imaginary part of complex number", \
0.0, 0.0,0.0,1.0,0,2561)
DeclareVariable("rectifier1.S_vect[3].re", "Real part of complex number", 0.0, \
0.0,0.0,1.0,0,2561)
DeclareVariable("rectifier1.S_vect[3].im", "Imaginary part of complex number", \
0.0, 0.0,0.0,1.0,0,2561)
DeclareVariable("rectifier1.globalSeed", "", 9854, 0.0,0.0,0.0,0,2561)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
pre(DYNX(W_,8),"systemDef.eventReadData", false, 2);
pre(DYNX(W_,7),"systemDef.eventWriteData", false, 1);
pre(DYNX(W_,6),"systemDef.modeSelect", false, 0);
EndPreBlock
StartEqBlock
DoRememAcc_(DYNX(W_,15), 0, 1);
DoRememAcc_(DYNX(W_,17), 0, 3);
DoRememAcc_(DYNX(W_,19), 0, 5);
DoRememAcc_(DYNX(W_,42), 0, 0);
DoRememAcc_(DYNX(W_,44), 0, 2);
DoRememAcc_(DYNX(W_,46), 0, 4);
EndEqBlock
UpdateQEvaluate(5)
EndDataBlock
