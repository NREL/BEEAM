#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model HPF.Test.SinglePhase_HarmonicLoad
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Fri Jun 14 12:52:13 2019

   */

#include <matrixop.h>
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  double  theta_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(double   theta_02) {
  struct DymStruc0 dummy_0;
  dummy_0.theta_0member = theta_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC RealArray    HPF_Types_Reference_equalityConstraint(struct 
  DymStruc0 reference10_0, struct DymStruc0 reference20_0);
/* Codes used in model */

/* Flattened Modelica model:

function HPF.Types.Reference.equalityConstraint
input HPF.Types.Reference reference1;
input HPF.Types.Reference reference2;
discrete output Real residue[0];

algorithm 
assert(abs(reference1.theta-reference2.theta) < 6.283185307179586E-06, "Reference angles should be equal!");
end HPF.Types.Reference.equalityConstraint;

  */
DYMOLA_STATIC RealArray    HPF_Types_Reference_equalityConstraint(struct 
  DymStruc0 reference10_0, struct DymStruc0 reference20_0) {
  PushContext("HPF.Types.Reference.equalityConstraint")
  {
    /* Declare outputs and temporaries */
    RealArray    residue0_0;
    MarkObject retmark_ = PushMark();
    residue0_0=RealTemporary( 1, 0);
    RePushMark(&retmark_);
    RealFillAssign( residue0_0, 0);
    /* Start of real code */
      AssertModelica(fabs(reference10_0.theta_0member-reference20_0.
        theta_0member) < 6.283185307179586E-06,"abs(reference1.theta-reference2.theta) < 6.283185307179586E-06",
         "Reference angles should be equal!");
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return residue0_0;
  }}
/* DSblock C-code: */

#define NX_    1
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    26
#define NP_    11
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 2091998134
#define NHash2_ -1518585340
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  1
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    35
#define SizePre_ 0
#define SizeEq_ 2
#define SizeDelay_ 0
#define QNLmax_ 1
#define MAXAux 1
#define NrDymolaTimers_ 0
#define NWhen_ 1
#define NCheckIf_ 0
#define NGlobalHelp_ 62
#define NGlobalHelpI_ 24
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="HPF.Test.SinglePhase_HarmonicLoad";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,0) = 1;
DYNX(W_,6) = 1;
DYNX(W_,9) = 1;
DYNX(W_,12) = 1;
DYNX(W_,14) = 1;
DYNX(W_,17) = 1;
DYNX(W_,22) = 1;
DYNX(W_,23) = 1;
DYNX(W_,19) = 0.0;
DYNX(W_,18) = 0.0;
DYNX(W_,25) = 0.0;
DYNX(W_,24) = 0.0;
DYNX(W_,16) = 0.0;
DYNX(W_,15) = 0.0;
DYNX(W_,20) = 0.0;
DYNX(W_,21) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
BoundParameterConstantSection
DYNX(DYNhelp,0) = cos(DYNX(DP_,6));
DYNX(W_,7) = DYNX(DP_,5)*DYNX(DYNhelp,0);
DYNX(DYNhelp,1) = sin(DYNX(DP_,6));
DYNX(W_,8) = DYNX(DP_,5)*DYNX(DYNhelp,1);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1) = false;
#endif
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,1);
InitialSection
InitialSection2
DYNX(W_,20) = 0.0;
DYNX(W_,21) = 0.0;
DYNX(W_,1) = DYNX(Aux_,0);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(F_,0) = 6.283185307179586*DYNX(DP_,2);

AcceptedSection1
DYNX(W_,13) = DYNX(X_,0);

RealFillAssign ((PushModelContext(1,"HPF.Types.Reference.equalityConstraint(\nv.pin_p.reference, \nz.pin_p.reference)")
  HPF_Types_Reference_equalityConstraint(DymStruc0_construct(DYNX(W_,13)), 
  DymStruc0_construct(DYNX(X_,0)))), 0);
PopAllMarks();
AcceptedSection2
beginwhenBlock
whenModelica(GreaterMinor(DYNTime,"time", 0.5,"0.5", 0), 0) 
  DYNX(W_,1) = true;
endwhenModelica()
endwhenBlock



{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 14 common subexpressions used in 13 expressions */
/* Of the common subexpressions 13 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"z.i[1].re", "z.i[1].im"};
const double nominal_[]={1, 1};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 0, 0, 1, -2, 1, 
  DYNX(DYNhelp,2), 55, DYNX(did_->helpvari_vec,0), 24);
NonLinearSystemSave(DYNX(W_,1), 0);
SetInitVectorNH(x__, 1, DYNX(W_,4), Remember_(DYNX(W_,4), 0));
SetInitVectorNH(x__, 2, DYNX(W_,5), Remember_(DYNX(W_,5), 1));
Residues;
  DYNX(DYNhelp,57) = DYNX(DP_,3)*DYNX(DP_,0);
  DYNX(DYNhelp,58) = DYNX(DP_,4)*DYNX(DP_,0);
  DYNX(W_,2) = DYNX(DYNhelp,57)*DYNX(W_,4)-DYNX(DYNhelp,58)*DYNX(W_,5);
  DYNX(W_,10) = DYNX(W_,7)-DYNX(W_,2);
  DYNX(W_,3) = DYNX(DYNhelp,57)*DYNX(W_,5)+DYNX(DYNhelp,58)*DYNX(W_,4);
  DYNX(W_,11) = DYNX(W_,8)-DYNX(W_,3);
DYNX(DYNhelp,59) = DYNX(W_,1) == false;
SetVector(residue__, 1, IF DYNX(DYNhelp,59) THEN DYNX(DP_,7)-DYNX(W_,10)*
  DYNX(W_,4) ELSE DYNX(W_,4)+DYNX(DP_,9));
SetVector(residue__, 2, IF DYNX(DYNhelp,59) THEN DYNX(DP_,8)+DYNX(W_,11)*
  DYNX(W_,5) ELSE DYNX(W_,5)+DYNX(DP_,10));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,60) = IF DYNX(DYNhelp,59) THEN  -DYNX(W_,4) ELSE 0.0;
DYNX(DYNhelp,61) = IF DYNX(DYNhelp,59) THEN DYNX(W_,5) ELSE 0.0;
SetMatrixLeading(Jacobian__, 1, 1, 2, (IF DYNX(DYNhelp,59) THEN  -DYNX(W_,10)
   ELSE 1.0)-DYNX(DYNhelp,60)*DYNX(DYNhelp,57));
SetMatrixLeading(Jacobian__, 1, 2, 2, DYNX(DYNhelp,60)*DYNX(DYNhelp,58));
SetMatrixLeading(Jacobian__, 2, 1, 2, (-1.0)*DYNX(DYNhelp,61)*DYNX(DYNhelp,58));
SetMatrixLeading(Jacobian__, 2, 2, 2, (IF DYNX(DYNhelp,59) THEN DYNX(W_,11)
   ELSE 1.0)-DYNX(DYNhelp,61)*DYNX(DYNhelp,57));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 1, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,4) = GetVector(x__, 1);
DYNX(W_,5) = GetVector(x__, 2);
EndNonLinearSystemOfEquationsNH(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }




DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("systemDef.hrms[1]", "Harmonics to simulate [:#(type=Integer)]",\
 0, 1, 0.0,0.0,0.0,0,564)
DeclareVariable("systemDef.numHrm", "Number of harmonics. (Automatically generated from hrms. Do not alter) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareParameter("systemDef.numPh", "Number of phases [:#(type=Integer)]", 1, 3,\
 0.0,0.0,0.0,0,564)
DeclareParameter("systemDef.fFund", "Fundamental frequency", 2, 60, 0.0,0.0,0.0,\
0,560)
DeclareVariable("systemDef.modeSelect", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,\
0,658)
DeclareVariable("z.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("z.v[1].im", "Imaginary part of complex number", 0.0, 0.0,0.0,\
0.0,0,640)
DeclareVariable("z.i[1].re", "Real part of complex number", 0.0, 0.0,0.0,0.0,0,704)
DeclareVariable("z.i[1].im", "Imaginary part of complex number", 0.0, 0.0,0.0,\
0.0,0,704)
DeclareAlias2("z.omega", "[rad/s]", "z.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("z.pin_p.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareVariable("z.pin_p.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("z.pin_p.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("z.pin_p.iIm[1]", "", "z.i[1].im", 1, 5, 5, 132)
DeclareAlias2("z.pin_p.iRe[1]", "", "z.i[1].re", 1, 5, 4, 132)
DeclareState("z.pin_p.reference.theta", "[rad|deg]", 0, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("z.pin_p.reference.der(theta)", "[rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("z.pin_n.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareVariable("z.pin_n.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,640)
DeclareVariable("z.pin_n.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,640)
DeclareAlias2("z.pin_n.iIm[1]", "", "z.i[1].im", -1, 5, 5, 132)
DeclareAlias2("z.pin_n.iRe[1]", "", "z.i[1].re", -1, 5, 4, 132)
DeclareAlias2("z.pin_n.reference.theta", "[rad|deg]", "z.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareParameter("z.z.re", "Real part of complex number", 3, 5.0, 0.0,0.0,0.0,0,560)
DeclareParameter("z.z.im", "Imaginary part of complex number", 4, 2.0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("v.v[1].re", "Real part of complex number", "z.pin_p.v[1].re", 1, 5,\
 7, 0)
DeclareAlias2("v.v[1].im", "Imaginary part of complex number", "z.pin_p.v[1].im", 1,\
 5, 8, 0)
DeclareAlias2("v.i[1].re", "Real part of complex number", "z.i[1].re", -1, 5, 4,\
 0)
DeclareAlias2("v.i[1].im", "Imaginary part of complex number", "z.i[1].im", -1, 5,\
 5, 0)
DeclareAlias2("v.omega", "[rad/s]", "z.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("v.pin_p.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareAlias2("v.pin_p.v[1].re", "Real part of complex number", "z.pin_p.v[1].re", 1,\
 5, 7, 0)
DeclareAlias2("v.pin_p.v[1].im", "Imaginary part of complex number", \
"z.pin_p.v[1].im", 1, 5, 8, 0)
DeclareAlias2("v.pin_p.iIm[1]", "", "z.i[1].im", -1, 5, 5, 132)
DeclareAlias2("v.pin_p.iRe[1]", "", "z.i[1].re", -1, 5, 4, 132)
DeclareVariable("v.pin_p.reference.theta", "[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("v.pin_p.reference.der(theta)", "[rad/s]", "z.pin_p.reference.der(theta)", 1,\
 6, 0, 0)
DeclareVariable("v.pin_n.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareVariable("v.pin_n.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("v.pin_n.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("v.pin_n.iIm[1]", "", "z.i[1].im", 1, 5, 5, 132)
DeclareAlias2("v.pin_n.iRe[1]", "", "z.i[1].re", 1, 5, 4, 132)
DeclareAlias2("v.pin_n.reference.theta", "[rad|deg]", "z.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareAlias2("v.theta", "[rad|deg]", "z.pin_p.reference.theta", 1, 1, 0, 0)
DeclareParameter("v.vMag[1]", "Voltage Magnitude", 5, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("v.vArg[1]", "Voltage angle", 6, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("ground1.pin.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareVariable("ground1.pin.v[1].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.iIm[1]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iRe[1]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("ground1.pin.reference.theta", "[rad|deg]", "z.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareAlias2("test_Load1.v[1].re", "Real part of complex number", \
"z.pin_n.v[1].re", 1, 5, 10, 64)
DeclareAlias2("test_Load1.v[1].im", "Imaginary part of complex number", \
"z.pin_n.v[1].im", 1, 5, 11, 64)
DeclareAlias2("test_Load1.i[1].re", "Real part of complex number", "z.i[1].re", 1,\
 5, 4, 0)
DeclareAlias2("test_Load1.i[1].im", "Imaginary part of complex number", \
"z.i[1].im", 1, 5, 5, 0)
DeclareAlias2("test_Load1.omega", "[rad/s]", "z.pin_p.reference.der(theta)", 1, 6,\
 0, 0)
DeclareVariable("test_Load1.pin_p.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareAlias2("test_Load1.pin_p.v[1].re", "Real part of complex number", \
"z.pin_n.v[1].re", 1, 5, 10, 0)
DeclareAlias2("test_Load1.pin_p.v[1].im", "Imaginary part of complex number", \
"z.pin_n.v[1].im", 1, 5, 11, 0)
DeclareAlias2("test_Load1.pin_p.iIm[1]", "", "z.i[1].im", 1, 5, 5, 132)
DeclareAlias2("test_Load1.pin_p.iRe[1]", "", "z.i[1].re", 1, 5, 4, 132)
DeclareAlias2("test_Load1.pin_p.reference.theta", "[rad|deg]", "z.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareAlias2("test_Load1.pin_p.reference.der(theta)", "[rad/s]", \
"z.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("test_Load1.pin_n.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareVariable("test_Load1.pin_n.v[1].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.pin_n.v[1].im", "Imaginary part of complex number", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("test_Load1.pin_n.iIm[1]", "", "z.i[1].im", -1, 5, 5, 132)
DeclareAlias2("test_Load1.pin_n.iRe[1]", "", "z.i[1].re", -1, 5, 4, 132)
DeclareAlias2("test_Load1.pin_n.reference.theta", "[rad|deg]", "z.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareParameter("test_Load1.sReal", "", 7, 50, 0.0,0.0,0.0,0,560)
DeclareParameter("test_Load1.sImag", "", 8, 10, 0.0,0.0,0.0,0,560)
DeclareParameter("test_Load1.iReal[1]", "", 9, 5, 0.0,0.0,0.0,0,560)
DeclareParameter("test_Load1.iImag[1]", "", 10, 3, 0.0,0.0,0.0,0,560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRememAcc_(DYNX(W_,5), 0.0, 1);
DoRememAcc_(DYNX(W_,4), 0.0, 0);
EndEqBlock
UpdateQEvaluate(1)
EndDataBlock
