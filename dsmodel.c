#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model HPF.Test.SinglePhase_Basic
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Sat Jun 15 22:46:05 2019

   */

#include <matrixop.h>
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  double  theta_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(double   theta_02) {
  struct DymStruc0 dummy_0;
  dummy_0.theta_0member = theta_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC RealArray    HPF_Types_Reference_equalityConstraint(struct 
  DymStruc0 reference10_0, struct DymStruc0 reference20_0);
/* Codes used in model */

/* Flattened Modelica model:

function HPF.Types.Reference.equalityConstraint
input HPF.Types.Reference reference1;
input HPF.Types.Reference reference2;
discrete output Real residue[0];

algorithm 
assert(abs(reference1.theta-reference2.theta) < 6.283185307179586E-06, "Reference angles should be equal!");
end HPF.Types.Reference.equalityConstraint;

  */
DYMOLA_STATIC RealArray    HPF_Types_Reference_equalityConstraint(struct 
  DymStruc0 reference10_0, struct DymStruc0 reference20_0) {
  PushContext("HPF.Types.Reference.equalityConstraint")
  {
    /* Declare outputs and temporaries */
    RealArray    residue0_0;
    MarkObject retmark_ = PushMark();
    residue0_0=RealTemporary( 1, 0);
    RePushMark(&retmark_);
    RealFillAssign( residue0_0, 0);
    /* Start of real code */
      AssertModelica(fabs(reference10_0.theta_0member-reference20_0.
        theta_0member) < 6.283185307179586E-06,"abs(reference1.theta-reference2.theta) < 6.283185307179586E-06",
         "Reference angles should be equal!");
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return residue0_0;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
#define NX_    1
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    81
#define NP_    17
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 1678507689
#define NHash2_ 30816331
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  3
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    104
#define SizePre_ 3
#define SizeEq_ 0
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 3
#define NrDymolaTimers_ 0
#define NWhen_ 3
#define NCheckIf_ 0
#define NGlobalHelp_ 222
#define NGlobalHelpI_ 36
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="HPF.Test.SinglePhase_Basic";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,0) = 3;
DYNX(W_,16) = 3;
DYNX(W_,17) = 3;
DYNX(W_,30) = 3;
DYNX(W_,31) = 3;
DYNX(W_,45) = 3;
DYNX(W_,46) = 3;
DYNX(W_,59) = 3;
DYNX(W_,61) = 3;
DYNX(W_,68) = 3;
DYNX(W_,70) = 0.0;
DYNX(W_,69) = 0.0;
DYNX(W_,72) = 0.0;
DYNX(W_,71) = 0.0;
DYNX(W_,74) = 0.0;
DYNX(W_,73) = 0.0;
DYNX(W_,19) = 0.0;
DYNX(W_,18) = 0.0;
DYNX(W_,21) = 0.0;
DYNX(W_,20) = 0.0;
DYNX(W_,23) = 0.0;
DYNX(W_,22) = 0.0;
DYNX(W_,48) = 0.0;
DYNX(W_,47) = 0.0;
DYNX(W_,50) = 0.0;
DYNX(W_,49) = 0.0;
DYNX(W_,52) = 0.0;
DYNX(W_,51) = 0.0;
DYNX(W_,63) = 0.0;
DYNX(W_,62) = 0.0;
DYNX(W_,65) = 0.0;
DYNX(W_,64) = 0.0;
DYNX(W_,67) = 0.0;
DYNX(W_,66) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
BoundParameterConstantSection
DYNX(DYNhelp,0) = cos(DYNX(DP_,8));
DYNX(W_,4) = DYNX(DP_,5)*DYNX(DYNhelp,0);
DYNX(DYNhelp,1) = sin(DYNX(DP_,8));
DYNX(W_,5) = DYNX(DP_,5)*DYNX(DYNhelp,1);
DYNX(DYNhelp,2) = cos(DYNX(DP_,9));
DYNX(W_,6) = DYNX(DP_,6)*DYNX(DYNhelp,2);
DYNX(DYNhelp,3) = sin(DYNX(DP_,9));
DYNX(W_,7) = DYNX(DP_,6)*DYNX(DYNhelp,3);
DYNX(DYNhelp,4) = cos(DYNX(DP_,10));
DYNX(W_,8) = DYNX(DP_,7)*DYNX(DYNhelp,4);
DYNX(DYNhelp,5) = sin(DYNX(DP_,10));
DYNX(W_,9) = DYNX(DP_,7)*DYNX(DYNhelp,5);

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[1] */
/* Introducing 13 common subexpressions used in 21 expressions */
/* Of the common subexpressions 13 are reals, 0 are integers, and 0
   are booleans. */
/* Automatic tearing of linear system of 10 simultaneous equations
gave a linear system of 4 equations for numerical solution.*/
{
  const char*const varnames_[]={"z2.i[1].re", "z2.i[1].im", "z1.i[1].im", 
    "z1.i[1].re"};
  const double nominal_[]={1, 1, 1, 1};
  DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,6), 64, DYNX(did_->helpvari_vec,0), 12);
  /* Parameter dependent Jacobian */
  if (NewParametersJac) SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    DYNX(DYNhelp,70) = DYNX(DP_,11)*DYNX(DP_,0);
    DYNX(DYNhelp,71) = DYNX(DP_,12)*DYNX(DP_,0);
    DYNX(DYNhelp,72) = (-1.0)*DYNX(DYNhelp,71);
    DYNX(DYNhelp,73) = DYNX(DP_,14)*DYNX(DP_,0);
    DYNX(DYNhelp,74) = DYNX(DP_,13)*DYNX(DP_,0);
    DYNX(DYNhelp,75) = DYNX(DYNhelp,70)+DYNX(DYNhelp,74);
    DYNX(DYNhelp,76) =  -DYNX(DP_,15)*DYNX(DP_,0);
    DYNX(DYNhelp,77) = DYNX(DP_,16)*DYNX(DP_,0);
    SetMatrixLeading(J, 1, 1, 4, DYNX(DYNhelp,70));
    SetMatrixLeading(J, 1, 2, 4, DYNX(DYNhelp,72));
    SetMatrixLeading(J, 1, 3, 4, DYNX(DYNhelp,72)-DYNX(DYNhelp,73));
    SetMatrixLeading(J, 1, 4, 4, DYNX(DYNhelp,75));
    SetMatrixLeading(J, 2, 1, 4, DYNX(DYNhelp,71));
    SetMatrixLeading(J, 2, 2, 4, DYNX(DYNhelp,70));
    SetMatrixLeading(J, 2, 3, 4, DYNX(DYNhelp,75));
    SetMatrixLeading(J, 2, 4, 4, DYNX(DYNhelp,73)+DYNX(DYNhelp,71));
    SetMatrixLeading(J, 3, 1, 4, DYNX(DYNhelp,76));
    SetMatrixLeading(J, 3, 2, 4, DYNX(DYNhelp,77));
    SetMatrixLeading(J, 3, 3, 4,  -DYNX(DYNhelp,73));
    SetMatrixLeading(J, 3, 4, 4, DYNX(DYNhelp,74));
    SetMatrixLeading(J, 4, 1, 4,  -DYNX(DYNhelp,77));
    SetMatrixLeading(J, 4, 2, 4, DYNX(DYNhelp,76));
    SetMatrixLeading(J, 4, 3, 4, DYNX(DYNhelp,74));
    SetMatrixLeading(J, 4, 4, 4, DYNX(DYNhelp,73));
  }
  SetVector(b, 1, DYNX(W_,4));
  SetVector(b, 2, DYNX(W_,5));
  SetVector(y, 1, 0);
  SetVector(y, 2, 0);
  SetVector(y, 3, 0);
  SetVector(y, 4, 0);
  SolveLinearSystemOfEquations(J, b, y, 1);
  DYNX(W_,53) = GetVector(y, 1);
  DYNX(W_,54) = GetVector(y, 2);
  DYNX(W_,40) = GetVector(y, 3);
  DYNX(W_,39) = GetVector(y, 4);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,33) = DYNX(DYNhelp,74)*DYNX(W_,40)+DYNX(DYNhelp,73)*DYNX(W_,39);
DYNX(W_,11) =  -(DYNX(W_,40)+DYNX(W_,54));
DYNX(W_,10) =  -(DYNX(W_,39)+DYNX(W_,53));
DYNX(W_,25) =  -(DYNX(DYNhelp,70)*DYNX(W_,11)+DYNX(DYNhelp,71)*DYNX(W_,10));
DYNX(W_,32) = DYNX(DYNhelp,74)*DYNX(W_,39)-DYNX(DYNhelp,73)*DYNX(W_,40);
DYNX(W_,24) = DYNX(DYNhelp,71)*DYNX(W_,11)-DYNX(DYNhelp,70)*DYNX(W_,10);
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: initialization.linear[2] */
/* Introducing 13 common subexpressions used in 21 expressions */
/* Of the common subexpressions 13 are reals, 0 are integers, and 0
   are booleans. */
/* Automatic tearing of linear system of 10 simultaneous equations
gave a linear system of 4 equations for numerical solution.*/
{
  const char*const varnames_[]={"z2.i[2].re", "z2.i[2].im", "z1.i[2].im", 
    "z1.i[2].re"};
  const double nominal_[]={1, 1, 1, 1};
  DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,78), 64, DYNX(did_->helpvari_vec,12), 12);
  /* Parameter dependent Jacobian */
  if (NewParametersJac) SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    DYNX(DYNhelp,142) = DYNX(DP_,11)*DYNX(DP_,1);
    DYNX(DYNhelp,143) = DYNX(DP_,12)*DYNX(DP_,1);
    DYNX(DYNhelp,144) = (-1.0)*DYNX(DYNhelp,143);
    DYNX(DYNhelp,145) = DYNX(DP_,14)*DYNX(DP_,1);
    DYNX(DYNhelp,146) = DYNX(DP_,13)*DYNX(DP_,1);
    DYNX(DYNhelp,147) = DYNX(DYNhelp,142)+DYNX(DYNhelp,146);
    DYNX(DYNhelp,148) =  -DYNX(DP_,15)*DYNX(DP_,1);
    DYNX(DYNhelp,149) = DYNX(DP_,16)*DYNX(DP_,1);
    SetMatrixLeading(J, 1, 1, 4, DYNX(DYNhelp,142));
    SetMatrixLeading(J, 1, 2, 4, DYNX(DYNhelp,144));
    SetMatrixLeading(J, 1, 3, 4, DYNX(DYNhelp,144)-DYNX(DYNhelp,145));
    SetMatrixLeading(J, 1, 4, 4, DYNX(DYNhelp,147));
    SetMatrixLeading(J, 2, 1, 4, DYNX(DYNhelp,143));
    SetMatrixLeading(J, 2, 2, 4, DYNX(DYNhelp,142));
    SetMatrixLeading(J, 2, 3, 4, DYNX(DYNhelp,147));
    SetMatrixLeading(J, 2, 4, 4, DYNX(DYNhelp,145)+DYNX(DYNhelp,143));
    SetMatrixLeading(J, 3, 1, 4, DYNX(DYNhelp,148));
    SetMatrixLeading(J, 3, 2, 4, DYNX(DYNhelp,149));
    SetMatrixLeading(J, 3, 3, 4,  -DYNX(DYNhelp,145));
    SetMatrixLeading(J, 3, 4, 4, DYNX(DYNhelp,146));
    SetMatrixLeading(J, 4, 1, 4,  -DYNX(DYNhelp,149));
    SetMatrixLeading(J, 4, 2, 4, DYNX(DYNhelp,148));
    SetMatrixLeading(J, 4, 3, 4, DYNX(DYNhelp,146));
    SetMatrixLeading(J, 4, 4, 4, DYNX(DYNhelp,145));
  }
  SetVector(b, 1, DYNX(W_,6));
  SetVector(b, 2, DYNX(W_,7));
  SetVector(y, 1, 0);
  SetVector(y, 2, 0);
  SetVector(y, 3, 0);
  SetVector(y, 4, 0);
  SolveLinearSystemOfEquations(J, b, y, 2);
  DYNX(W_,55) = GetVector(y, 1);
  DYNX(W_,56) = GetVector(y, 2);
  DYNX(W_,42) = GetVector(y, 3);
  DYNX(W_,41) = GetVector(y, 4);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,35) = DYNX(DYNhelp,146)*DYNX(W_,42)+DYNX(DYNhelp,145)*DYNX(W_,41);
DYNX(W_,13) =  -(DYNX(W_,42)+DYNX(W_,56));
DYNX(W_,12) =  -(DYNX(W_,41)+DYNX(W_,55));
DYNX(W_,27) =  -(DYNX(DYNhelp,142)*DYNX(W_,13)+DYNX(DYNhelp,143)*DYNX(W_,12));
DYNX(W_,34) = DYNX(DYNhelp,146)*DYNX(W_,41)-DYNX(DYNhelp,145)*DYNX(W_,42);
DYNX(W_,26) = DYNX(DYNhelp,143)*DYNX(W_,13)-DYNX(DYNhelp,142)*DYNX(W_,12);
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: initialization.linear[3] */
/* Introducing 13 common subexpressions used in 21 expressions */
/* Of the common subexpressions 13 are reals, 0 are integers, and 0
   are booleans. */
/* Automatic tearing of linear system of 10 simultaneous equations
gave a linear system of 4 equations for numerical solution.*/
{
  const char*const varnames_[]={"z2.i[3].re", "z2.i[3].im", "z1.i[3].im", 
    "z1.i[3].re"};
  const double nominal_[]={1, 1, 1, 1};
  DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,150), 64, DYNX(did_->helpvari_vec,24), 12);
  /* Parameter dependent Jacobian */
  if (NewParametersJac) SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    DYNX(DYNhelp,214) = DYNX(DP_,11)*DYNX(DP_,2);
    DYNX(DYNhelp,215) = DYNX(DP_,12)*DYNX(DP_,2);
    DYNX(DYNhelp,216) = (-1.0)*DYNX(DYNhelp,215);
    DYNX(DYNhelp,217) = DYNX(DP_,14)*DYNX(DP_,2);
    DYNX(DYNhelp,218) = DYNX(DP_,13)*DYNX(DP_,2);
    DYNX(DYNhelp,219) = DYNX(DYNhelp,214)+DYNX(DYNhelp,218);
    DYNX(DYNhelp,220) =  -DYNX(DP_,15)*DYNX(DP_,2);
    DYNX(DYNhelp,221) = DYNX(DP_,16)*DYNX(DP_,2);
    SetMatrixLeading(J, 1, 1, 4, DYNX(DYNhelp,214));
    SetMatrixLeading(J, 1, 2, 4, DYNX(DYNhelp,216));
    SetMatrixLeading(J, 1, 3, 4, DYNX(DYNhelp,216)-DYNX(DYNhelp,217));
    SetMatrixLeading(J, 1, 4, 4, DYNX(DYNhelp,219));
    SetMatrixLeading(J, 2, 1, 4, DYNX(DYNhelp,215));
    SetMatrixLeading(J, 2, 2, 4, DYNX(DYNhelp,214));
    SetMatrixLeading(J, 2, 3, 4, DYNX(DYNhelp,219));
    SetMatrixLeading(J, 2, 4, 4, DYNX(DYNhelp,217)+DYNX(DYNhelp,215));
    SetMatrixLeading(J, 3, 1, 4, DYNX(DYNhelp,220));
    SetMatrixLeading(J, 3, 2, 4, DYNX(DYNhelp,221));
    SetMatrixLeading(J, 3, 3, 4,  -DYNX(DYNhelp,217));
    SetMatrixLeading(J, 3, 4, 4, DYNX(DYNhelp,218));
    SetMatrixLeading(J, 4, 1, 4,  -DYNX(DYNhelp,221));
    SetMatrixLeading(J, 4, 2, 4, DYNX(DYNhelp,220));
    SetMatrixLeading(J, 4, 3, 4, DYNX(DYNhelp,218));
    SetMatrixLeading(J, 4, 4, 4, DYNX(DYNhelp,217));
  }
  SetVector(b, 1, DYNX(W_,8));
  SetVector(b, 2, DYNX(W_,9));
  SetVector(y, 1, 0);
  SetVector(y, 2, 0);
  SetVector(y, 3, 0);
  SetVector(y, 4, 0);
  SolveLinearSystemOfEquations(J, b, y, 3);
  DYNX(W_,57) = GetVector(y, 1);
  DYNX(W_,58) = GetVector(y, 2);
  DYNX(W_,44) = GetVector(y, 3);
  DYNX(W_,43) = GetVector(y, 4);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,37) = DYNX(DYNhelp,218)*DYNX(W_,44)+DYNX(DYNhelp,217)*DYNX(W_,43);
DYNX(W_,15) =  -(DYNX(W_,44)+DYNX(W_,58));
DYNX(W_,14) =  -(DYNX(W_,43)+DYNX(W_,57));
DYNX(W_,29) =  -(DYNX(DYNhelp,214)*DYNX(W_,15)+DYNX(DYNhelp,215)*DYNX(W_,14));
DYNX(W_,36) = DYNX(DYNhelp,218)*DYNX(W_,43)-DYNX(DYNhelp,217)*DYNX(W_,44);
DYNX(W_,28) = DYNX(DYNhelp,215)*DYNX(W_,15)-DYNX(DYNhelp,214)*DYNX(W_,14);
 /* End of Equation Block */ 

DYNX(W_,75) = DYNX(W_,11)+DYNX(W_,40)+DYNX(W_,54);
DYNX(W_,76) = DYNX(W_,13)+DYNX(W_,42)+DYNX(W_,56);
DYNX(W_,77) = DYNX(W_,15)+DYNX(W_,44)+DYNX(W_,58);
DYNX(W_,78) = DYNX(W_,10)+DYNX(W_,39)+DYNX(W_,53);
DYNX(W_,79) = DYNX(W_,12)+DYNX(W_,41)+DYNX(W_,55);
DYNX(W_,80) = DYNX(W_,14)+DYNX(W_,43)+DYNX(W_,57);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1) = true;
DYNX(W_,2) = false;
DYNX(W_,3) = false;
DYNX(W_,38) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,2);
DYNX(Aux_,1) = DYNX(W_,3);
DYNX(Aux_,2) = DYNX(W_,1);
InitialSection
InitialSection2
DYNX(W_,2) = DYNX(Aux_,0);
  DYNX(W_,1) = false;
DYNX(W_,3) = DYNX(Aux_,1);
InitialBoundSection
DYNX(Aux_,2) = DYNX(W_,1);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(F_,0) = 6.283185307179586*DYNX(DP_,4);

AcceptedSection1
DYNX(W_,38) = DYNX(X_,0);
DYNX(W_,60) = DYNX(X_,0);

RealFillAssign ((PushModelContext(1,"HPF.Types.Reference.equalityConstraint(\nz.pin_n.reference, \nz1.pin_p.reference)")
  HPF_Types_Reference_equalityConstraint(DymStruc0_construct(DYNX(W_,38)), 
  DymStruc0_construct(DYNX(X_,0)))), 0);
PopAllMarks();
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
RealFillAssign ((PushModelContext(1,"HPF.Types.Reference.equalityConstraint(\nz.pin_n.reference, \nz2.pin_p.reference)")
  HPF_Types_Reference_equalityConstraint(DymStruc0_construct(DYNX(W_,38)), 
  DymStruc0_construct(DYNX(W_,60)))), 0);
PopAllMarks();
AcceptedSection2
DYNX(W_,1) = PRE(DYNX(W_,1), 0);
DYNX(W_,2) = PRE(DYNX(W_,2), 1);
DYNX(W_,3) = PRE(DYNX(W_,3), 2);
  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.5,"0.5", 0), 0) 
    DYNX(W_,1) = true;
  endwhenModelica()
  endwhenBlock

  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.25,"0.25", 1), 1) 
    DYNX(W_,2) = true;
  endwhenModelica()
  endwhenBlock

  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.4,"0.4", 2), 2) 
    DYNX(W_,3) = true;
  endwhenModelica()
  endwhenBlock


DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("systemDef.hrms[1]", "Harmonics to simulate [:#(type=Integer)]",\
 0, 1, 0.0,0.0,0.0,0,564)
DeclareParameter("systemDef.hrms[2]", "Harmonics to simulate [:#(type=Integer)]",\
 1, 3, 0.0,0.0,0.0,0,564)
DeclareParameter("systemDef.hrms[3]", "Harmonics to simulate [:#(type=Integer)]",\
 2, 5, 0.0,0.0,0.0,0,564)
DeclareVariable("systemDef.numHrm", "Number of harmonics. (Automatically generated from hrms. Do not alter) [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareParameter("systemDef.numPh", "Number of phases [:#(type=Integer)]", 3, 3,\
 0.0,0.0,0.0,0,564)
DeclareParameter("systemDef.fFund", "Fundamental frequency", 4, 60, 0.0,0.0,0.0,\
0,560)
DeclareVariable("systemDef.modeSelect", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,\
0,642)
DeclareVariable("systemDef.event1", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("systemDef.event2", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("voltageSource1.v[1].re", "Real part of complex number", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.v[1].im", "Imaginary part of complex number", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.v[2].re", "Real part of complex number", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.v[2].im", "Imaginary part of complex number", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.v[3].re", "Real part of complex number", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.v[3].im", "Imaginary part of complex number", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.i[1].re", "Real part of complex number", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.i[1].im", "Imaginary part of complex number", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.i[2].re", "Real part of complex number", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.i[2].im", "Imaginary part of complex number", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.i[3].re", "Real part of complex number", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.i[3].im", "Imaginary part of complex number", 0,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("voltageSource1.omega", "[rad/s]", "z1.pin_p.reference.der(theta)", 1,\
 6, 0, 0)
DeclareVariable("voltageSource1.pin_p.h", "[:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareAlias2("voltageSource1.pin_p.v[1].re", "Real part of complex number", \
"voltageSource1.v[1].re", 1, 5, 4, 0)
DeclareAlias2("voltageSource1.pin_p.v[1].im", "Imaginary part of complex number",\
 "voltageSource1.v[1].im", 1, 5, 5, 0)
DeclareAlias2("voltageSource1.pin_p.v[2].re", "Real part of complex number", \
"voltageSource1.v[2].re", 1, 5, 6, 0)
DeclareAlias2("voltageSource1.pin_p.v[2].im", "Imaginary part of complex number",\
 "voltageSource1.v[2].im", 1, 5, 7, 0)
DeclareAlias2("voltageSource1.pin_p.v[3].re", "Real part of complex number", \
"voltageSource1.v[3].re", 1, 5, 8, 0)
DeclareAlias2("voltageSource1.pin_p.v[3].im", "Imaginary part of complex number",\
 "voltageSource1.v[3].im", 1, 5, 9, 0)
DeclareAlias2("voltageSource1.pin_p.iIm[1]", "", "voltageSource1.i[1].im", 1, 5,\
 11, 132)
DeclareAlias2("voltageSource1.pin_p.iIm[2]", "", "voltageSource1.i[2].im", 1, 5,\
 13, 132)
DeclareAlias2("voltageSource1.pin_p.iIm[3]", "", "voltageSource1.i[3].im", 1, 5,\
 15, 132)
DeclareAlias2("voltageSource1.pin_p.iRe[1]", "", "voltageSource1.i[1].re", 1, 5,\
 10, 132)
DeclareAlias2("voltageSource1.pin_p.iRe[2]", "", "voltageSource1.i[2].re", 1, 5,\
 12, 132)
DeclareAlias2("voltageSource1.pin_p.iRe[3]", "", "voltageSource1.i[3].re", 1, 5,\
 14, 132)
DeclareAlias2("voltageSource1.pin_p.reference.theta", "[rad|deg]", \
"z.pin_n.reference.theta", 1, 5, 38, 0)
DeclareAlias2("voltageSource1.pin_p.reference.der(theta)", "[rad/s]", \
"z1.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("voltageSource1.pin_n.h", "[:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareVariable("voltageSource1.pin_n.v[1].re", "Real part of complex number", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.pin_n.v[1].im", "Imaginary part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.pin_n.v[2].re", "Real part of complex number", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.pin_n.v[2].im", "Imaginary part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.pin_n.v[3].re", "Real part of complex number", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("voltageSource1.pin_n.v[3].im", "Imaginary part of complex number",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("voltageSource1.pin_n.iIm[1]", "", "voltageSource1.i[1].im", -1, 5,\
 11, 132)
DeclareAlias2("voltageSource1.pin_n.iIm[2]", "", "voltageSource1.i[2].im", -1, 5,\
 13, 132)
DeclareAlias2("voltageSource1.pin_n.iIm[3]", "", "voltageSource1.i[3].im", -1, 5,\
 15, 132)
DeclareAlias2("voltageSource1.pin_n.iRe[1]", "", "voltageSource1.i[1].re", -1, 5,\
 10, 132)
DeclareAlias2("voltageSource1.pin_n.iRe[2]", "", "voltageSource1.i[2].re", -1, 5,\
 12, 132)
DeclareAlias2("voltageSource1.pin_n.iRe[3]", "", "voltageSource1.i[3].re", -1, 5,\
 14, 132)
DeclareAlias2("voltageSource1.pin_n.reference.theta", "[rad|deg]", \
"z.pin_n.reference.theta", 1, 5, 38, 0)
DeclareAlias2("voltageSource1.theta", "[rad|deg]", "z.pin_n.reference.theta", 1,\
 5, 38, 0)
DeclareParameter("voltageSource1.vMag[1]", "Voltage Magnitude", 5, 100, 0.0,0.0,\
0.0,0,560)
DeclareParameter("voltageSource1.vMag[2]", "Voltage Magnitude", 6, 5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("voltageSource1.vMag[3]", "Voltage Magnitude", 7, 3, 0.0,0.0,\
0.0,0,560)
DeclareParameter("voltageSource1.vArg[1]", "Voltage angle", 8, 0.0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("voltageSource1.vArg[2]", "Voltage angle", 9, 0.5, 0.0,0.0,0.0,\
0,560)
DeclareParameter("voltageSource1.vArg[3]", "Voltage angle", 10, -0.25, 0.0,0.0,\
0.0,0,560)
DeclareVariable("z.v[1].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("z.v[1].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("z.v[2].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("z.v[2].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("z.v[3].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("z.v[3].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareAlias2("z.i[1].re", "Real part of complex number", "voltageSource1.i[1].re", -1,\
 5, 10, 0)
DeclareAlias2("z.i[1].im", "Imaginary part of complex number", "voltageSource1.i[1].im", -1,\
 5, 11, 0)
DeclareAlias2("z.i[2].re", "Real part of complex number", "voltageSource1.i[2].re", -1,\
 5, 12, 0)
DeclareAlias2("z.i[2].im", "Imaginary part of complex number", "voltageSource1.i[2].im", -1,\
 5, 13, 0)
DeclareAlias2("z.i[3].re", "Real part of complex number", "voltageSource1.i[3].re", -1,\
 5, 14, 0)
DeclareAlias2("z.i[3].im", "Imaginary part of complex number", "voltageSource1.i[3].im", -1,\
 5, 15, 0)
DeclareAlias2("z.omega", "[rad/s]", "z1.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("z.pin_p.h", "[:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareAlias2("z.pin_p.v[1].re", "Real part of complex number", "voltageSource1.v[1].re", 1,\
 5, 4, 0)
DeclareAlias2("z.pin_p.v[1].im", "Imaginary part of complex number", \
"voltageSource1.v[1].im", 1, 5, 5, 0)
DeclareAlias2("z.pin_p.v[2].re", "Real part of complex number", "voltageSource1.v[2].re", 1,\
 5, 6, 0)
DeclareAlias2("z.pin_p.v[2].im", "Imaginary part of complex number", \
"voltageSource1.v[2].im", 1, 5, 7, 0)
DeclareAlias2("z.pin_p.v[3].re", "Real part of complex number", "voltageSource1.v[3].re", 1,\
 5, 8, 0)
DeclareAlias2("z.pin_p.v[3].im", "Imaginary part of complex number", \
"voltageSource1.v[3].im", 1, 5, 9, 0)
DeclareAlias2("z.pin_p.iIm[1]", "", "voltageSource1.i[1].im", -1, 5, 11, 132)
DeclareAlias2("z.pin_p.iIm[2]", "", "voltageSource1.i[2].im", -1, 5, 13, 132)
DeclareAlias2("z.pin_p.iIm[3]", "", "voltageSource1.i[3].im", -1, 5, 15, 132)
DeclareAlias2("z.pin_p.iRe[1]", "", "voltageSource1.i[1].re", -1, 5, 10, 132)
DeclareAlias2("z.pin_p.iRe[2]", "", "voltageSource1.i[2].re", -1, 5, 12, 132)
DeclareAlias2("z.pin_p.iRe[3]", "", "voltageSource1.i[3].re", -1, 5, 14, 132)
DeclareAlias2("z.pin_p.reference.theta", "[rad|deg]", "z.pin_n.reference.theta", 1,\
 5, 38, 0)
DeclareAlias2("z.pin_p.reference.der(theta)", "[rad/s]", "z1.pin_p.reference.der(theta)", 1,\
 6, 0, 0)
DeclareVariable("z.pin_n.h", "[:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareVariable("z.pin_n.v[1].re", "Real part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("z.pin_n.v[1].im", "Imaginary part of complex number", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_n.v[2].re", "Real part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("z.pin_n.v[2].im", "Imaginary part of complex number", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_n.v[3].re", "Real part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("z.pin_n.v[3].im", "Imaginary part of complex number", 0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("z.pin_n.iIm[1]", "", "voltageSource1.i[1].im", 1, 5, 11, 132)
DeclareAlias2("z.pin_n.iIm[2]", "", "voltageSource1.i[2].im", 1, 5, 13, 132)
DeclareAlias2("z.pin_n.iIm[3]", "", "voltageSource1.i[3].im", 1, 5, 15, 132)
DeclareAlias2("z.pin_n.iRe[1]", "", "voltageSource1.i[1].re", 1, 5, 10, 132)
DeclareAlias2("z.pin_n.iRe[2]", "", "voltageSource1.i[2].re", 1, 5, 12, 132)
DeclareAlias2("z.pin_n.iRe[3]", "", "voltageSource1.i[3].re", 1, 5, 14, 132)
DeclareVariable("z.pin_n.reference.theta", "[rad|deg]", 0, 0.0,0.0,0.0,0,512)
DeclareParameter("z.z.re", "Real part of complex number", 11, 5.0, 0.0,0.0,0.0,0,560)
DeclareParameter("z.z.im", "Imaginary part of complex number", 12, 2.0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("z1.v[1].re", "Real part of complex number", "z.pin_n.v[1].re", 1,\
 5, 32, 0)
DeclareAlias2("z1.v[1].im", "Imaginary part of complex number", "z.pin_n.v[1].im", 1,\
 5, 33, 0)
DeclareAlias2("z1.v[2].re", "Real part of complex number", "z.pin_n.v[2].re", 1,\
 5, 34, 0)
DeclareAlias2("z1.v[2].im", "Imaginary part of complex number", "z.pin_n.v[2].im", 1,\
 5, 35, 0)
DeclareAlias2("z1.v[3].re", "Real part of complex number", "z.pin_n.v[3].re", 1,\
 5, 36, 0)
DeclareAlias2("z1.v[3].im", "Imaginary part of complex number", "z.pin_n.v[3].im", 1,\
 5, 37, 0)
DeclareVariable("z1.i[1].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("z1.i[1].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("z1.i[2].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("z1.i[2].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("z1.i[3].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("z1.i[3].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareAlias2("z1.omega", "[rad/s]", "z1.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("z1.pin_p.h", "[:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareAlias2("z1.pin_p.v[1].re", "Real part of complex number", \
"z.pin_n.v[1].re", 1, 5, 32, 0)
DeclareAlias2("z1.pin_p.v[1].im", "Imaginary part of complex number", \
"z.pin_n.v[1].im", 1, 5, 33, 0)
DeclareAlias2("z1.pin_p.v[2].re", "Real part of complex number", \
"z.pin_n.v[2].re", 1, 5, 34, 0)
DeclareAlias2("z1.pin_p.v[2].im", "Imaginary part of complex number", \
"z.pin_n.v[2].im", 1, 5, 35, 0)
DeclareAlias2("z1.pin_p.v[3].re", "Real part of complex number", \
"z.pin_n.v[3].re", 1, 5, 36, 0)
DeclareAlias2("z1.pin_p.v[3].im", "Imaginary part of complex number", \
"z.pin_n.v[3].im", 1, 5, 37, 0)
DeclareAlias2("z1.pin_p.iIm[1]", "", "z1.i[1].im", 1, 5, 40, 132)
DeclareAlias2("z1.pin_p.iIm[2]", "", "z1.i[2].im", 1, 5, 42, 132)
DeclareAlias2("z1.pin_p.iIm[3]", "", "z1.i[3].im", 1, 5, 44, 132)
DeclareAlias2("z1.pin_p.iRe[1]", "", "z1.i[1].re", 1, 5, 39, 132)
DeclareAlias2("z1.pin_p.iRe[2]", "", "z1.i[2].re", 1, 5, 41, 132)
DeclareAlias2("z1.pin_p.iRe[3]", "", "z1.i[3].re", 1, 5, 43, 132)
DeclareState("z1.pin_p.reference.theta", "[rad|deg]", 0, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("z1.pin_p.reference.der(theta)", "[rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("z1.pin_n.h", "[:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareVariable("z1.pin_n.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("z1.pin_n.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z1.pin_n.v[2].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("z1.pin_n.v[2].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z1.pin_n.v[3].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("z1.pin_n.v[3].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("z1.pin_n.iIm[1]", "", "z1.i[1].im", -1, 5, 40, 132)
DeclareAlias2("z1.pin_n.iIm[2]", "", "z1.i[2].im", -1, 5, 42, 132)
DeclareAlias2("z1.pin_n.iIm[3]", "", "z1.i[3].im", -1, 5, 44, 132)
DeclareAlias2("z1.pin_n.iRe[1]", "", "z1.i[1].re", -1, 5, 39, 132)
DeclareAlias2("z1.pin_n.iRe[2]", "", "z1.i[2].re", -1, 5, 41, 132)
DeclareAlias2("z1.pin_n.iRe[3]", "", "z1.i[3].re", -1, 5, 43, 132)
DeclareAlias2("z1.pin_n.reference.theta", "[rad|deg]", "z.pin_n.reference.theta", 1,\
 5, 38, 0)
DeclareParameter("z1.z.re", "Real part of complex number", 13, 2.0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("z1.z.im", "Imaginary part of complex number", 14, 2.0, \
0.0,0.0,0.0,0,560)
DeclareAlias2("z2.v[1].re", "Real part of complex number", "z.pin_n.v[1].re", 1,\
 5, 32, 0)
DeclareAlias2("z2.v[1].im", "Imaginary part of complex number", "z.pin_n.v[1].im", 1,\
 5, 33, 0)
DeclareAlias2("z2.v[2].re", "Real part of complex number", "z.pin_n.v[2].re", 1,\
 5, 34, 0)
DeclareAlias2("z2.v[2].im", "Imaginary part of complex number", "z.pin_n.v[2].im", 1,\
 5, 35, 0)
DeclareAlias2("z2.v[3].re", "Real part of complex number", "z.pin_n.v[3].re", 1,\
 5, 36, 0)
DeclareAlias2("z2.v[3].im", "Imaginary part of complex number", "z.pin_n.v[3].im", 1,\
 5, 37, 0)
DeclareVariable("z2.i[1].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("z2.i[1].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("z2.i[2].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("z2.i[2].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("z2.i[3].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("z2.i[3].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareAlias2("z2.omega", "[rad/s]", "z1.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("z2.pin_p.h", "[:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareAlias2("z2.pin_p.v[1].re", "Real part of complex number", \
"z.pin_n.v[1].re", 1, 5, 32, 0)
DeclareAlias2("z2.pin_p.v[1].im", "Imaginary part of complex number", \
"z.pin_n.v[1].im", 1, 5, 33, 0)
DeclareAlias2("z2.pin_p.v[2].re", "Real part of complex number", \
"z.pin_n.v[2].re", 1, 5, 34, 0)
DeclareAlias2("z2.pin_p.v[2].im", "Imaginary part of complex number", \
"z.pin_n.v[2].im", 1, 5, 35, 0)
DeclareAlias2("z2.pin_p.v[3].re", "Real part of complex number", \
"z.pin_n.v[3].re", 1, 5, 36, 0)
DeclareAlias2("z2.pin_p.v[3].im", "Imaginary part of complex number", \
"z.pin_n.v[3].im", 1, 5, 37, 0)
DeclareAlias2("z2.pin_p.iIm[1]", "", "z2.i[1].im", 1, 5, 54, 132)
DeclareAlias2("z2.pin_p.iIm[2]", "", "z2.i[2].im", 1, 5, 56, 132)
DeclareAlias2("z2.pin_p.iIm[3]", "", "z2.i[3].im", 1, 5, 58, 132)
DeclareAlias2("z2.pin_p.iRe[1]", "", "z2.i[1].re", 1, 5, 53, 132)
DeclareAlias2("z2.pin_p.iRe[2]", "", "z2.i[2].re", 1, 5, 55, 132)
DeclareAlias2("z2.pin_p.iRe[3]", "", "z2.i[3].re", 1, 5, 57, 132)
DeclareVariable("z2.pin_p.reference.theta", "[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("z2.pin_p.reference.der(theta)", "[rad/s]", "z1.pin_p.reference.der(theta)", 1,\
 6, 0, 0)
DeclareVariable("z2.pin_n.h", "[:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareVariable("z2.pin_n.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("z2.pin_n.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z2.pin_n.v[2].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("z2.pin_n.v[2].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z2.pin_n.v[3].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("z2.pin_n.v[3].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("z2.pin_n.iIm[1]", "", "z2.i[1].im", -1, 5, 54, 132)
DeclareAlias2("z2.pin_n.iIm[2]", "", "z2.i[2].im", -1, 5, 56, 132)
DeclareAlias2("z2.pin_n.iIm[3]", "", "z2.i[3].im", -1, 5, 58, 132)
DeclareAlias2("z2.pin_n.iRe[1]", "", "z2.i[1].re", -1, 5, 53, 132)
DeclareAlias2("z2.pin_n.iRe[2]", "", "z2.i[2].re", -1, 5, 55, 132)
DeclareAlias2("z2.pin_n.iRe[3]", "", "z2.i[3].re", -1, 5, 57, 132)
DeclareAlias2("z2.pin_n.reference.theta", "[rad|deg]", "z.pin_n.reference.theta", 1,\
 5, 38, 0)
DeclareParameter("z2.z.re", "Real part of complex number", 15, 3.0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("z2.z.im", "Imaginary part of complex number", 16, 2.0, \
0.0,0.0,0.0,0,560)
DeclareVariable("ground1.pin.h", "[:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareVariable("ground1.pin.v[1].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[2].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[2].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[3].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[3].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.iIm[1]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iIm[2]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iIm[3]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iRe[1]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iRe[2]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("ground1.pin.iRe[3]", "", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("ground1.pin.reference.theta", "[rad|deg]", "z.pin_n.reference.theta", 1,\
 5, 38, 0)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
pre(DYNX(W_,2),"systemDef.event1", false, 1);
pre(DYNX(W_,3),"systemDef.event2", false, 2);
pre(DYNX(W_,1),"systemDef.modeSelect", true, 0);
EndPreBlock
UpdateQEvaluate(3)
EndDataBlock

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionEnd()
