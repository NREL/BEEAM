#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model HPF.Test.SinglePhase_HarmonicLoad
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Mon Jun 17 11:13:17 2019

   */

#include <matrixop.h>
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc1;
struct DymStruc0 {
  double  theta_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(double   theta_02) {
  struct DymStruc0 dummy_0;
  dummy_0.theta_0member = theta_02;
  return dummy_0;
}
struct DymStruc1 {
  double  re_0member;
  double  im_0member;
};
DYMOLA_STATIC struct DymStruc1 DymStruc1_construct(double   im_02, double   
  re_02) {
  struct DymStruc1 dummy_0;
  dummy_0.im_0member = im_02;
  dummy_0.re_0member = re_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC struct DymStruc1  HPF_SinglePhase_NonlinearLoads_DataIO_readNodeVoltage
  (const char*  name0_0);
DYMOLA_STATIC void HPF_SinglePhase_NonlinearLoads_DataIO_writeNodeVoltage(
  struct DymStruc1 data0_0, const char*  name0_0);
DYMOLA_STATIC RealArray    HPF_Types_Reference_equalityConstraint(struct 
  DymStruc0 reference10_0, struct DymStruc0 reference20_0);
DYMOLA_STATIC RealArray    Modelica_Utilities_Streams_readRealMatrix_M(
  const char*  fileName0_0, const char*  matrixName0_0, int  nrow0_0, int  
  ncol0_0, int  verboseRead0_0);
DYMOLA_STATIC int   Modelica_Utilities_Streams_writeRealMatrix_M(const char*  
  fileName0_0, const char*  matrixName0_0, RealArray   matrix0_0, int  append0_0,
   const char*  format0_0);
/* Codes used in model */

/* Flattened Modelica model:

function HPF.SinglePhase.NonlinearLoads.DataIO.readNodeVoltage
input String name;
output Complex v;
protected 
discrete Real readMatrix[2, 1];
public 
algorithm 
readMatrix := Modelica.Utilities.Streams.readRealMatrix(name+".mat", "data", 2, 1, true);
v.re := readMatrix[1, 1];
v.im := readMatrix[2, 1];
end HPF.SinglePhase.NonlinearLoads.DataIO.readNodeVoltage;

  */
DYMOLA_STATIC struct DymStruc1  HPF_SinglePhase_NonlinearLoads_DataIO_readNodeVoltage
  (const char*  name0_0) {
  char*retSMark_=GetStringMark();
  PushContext("HPF.SinglePhase.NonlinearLoads.DataIO.readNodeVoltage")
  {
    /* Declare outputs and temporaries */
    struct DymStruc1  v0_0;
    RealArray    readMatrix0_0;
    MarkObject retmark_ = PushMark();
    v0_0.re_0member=0;
    v0_0.im_0member=0;
    readMatrix0_0=RealTemporary( 2, 2, 1);
    PushMark();
    RealFillAssign( readMatrix0_0, 0);
    /* Start of real code */
      RealAssign (readMatrix0_0, Modelica_Utilities_Streams_readRealMatrix_M(
        StringAdd(name0_0,".mat"), "data", 2, 1, true));
      Release();
      v0_0.re_0member = RealMatrixElement( readMatrix0_0, (SizeType)(1), 
        (SizeType)(1));
      v0_0.im_0member = RealMatrixElement( readMatrix0_0, (SizeType)(2), 
        (SizeType)(1));
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return v0_0;
  }}

/* Flattened Modelica model:

function HPF.SinglePhase.NonlinearLoads.DataIO.writeNodeVoltage
input Complex data;
input String name;
protected 
discrete Real dataMatrix[2, 1](start = {{data.re}, {data.im}});
public 
algorithm 
Modelica.Utilities.Streams.writeRealMatrix(name+".mat", "data", dataMatrix, false, "4");
end HPF.SinglePhase.NonlinearLoads.DataIO.writeNodeVoltage;

  */
DYMOLA_STATIC void HPF_SinglePhase_NonlinearLoads_DataIO_writeNodeVoltage(
  struct DymStruc1 data0_0, const char*  name0_0) {
  char*retSMark_=GetStringMark();
  PushContext("HPF.SinglePhase.NonlinearLoads.DataIO.writeNodeVoltage")
  {
    /* Declare outputs and temporaries */
    RealArray    dataMatrix0_0;
    MarkObject retmark_ = PushMark();
    dataMatrix0_0=RealTemporary( 2, 2, 1);
    PushMark();
    RealAssign (dataMatrix0_0, RealArrayArray ( 2, RealScalarArray ( 1, data0_0.
      re_0member), RealScalarArray ( 1, data0_0.im_0member)));
    Release();
    /* Start of real code */
      Modelica_Utilities_Streams_writeRealMatrix_M(StringAdd(name0_0,".mat"), 
        "data", dataMatrix0_0, false, "4");
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function HPF.Types.Reference.equalityConstraint
input HPF.Types.Reference reference1;
input HPF.Types.Reference reference2;
discrete output Real residue[0];

algorithm 
assert(abs(reference1.theta-reference2.theta) < 6.283185307179586E-06, "Reference angles should be equal!");
end HPF.Types.Reference.equalityConstraint;

  */
DYMOLA_STATIC RealArray    HPF_Types_Reference_equalityConstraint(struct 
  DymStruc0 reference10_0, struct DymStruc0 reference20_0) {
  PushContext("HPF.Types.Reference.equalityConstraint")
  {
    /* Declare outputs and temporaries */
    RealArray    residue0_0;
    MarkObject retmark_ = PushMark();
    residue0_0=RealTemporary( 1, 0);
    RePushMark(&retmark_);
    RealFillAssign( residue0_0, 0);
    /* Start of real code */
      AssertModelica(fabs(reference10_0.theta_0member-reference20_0.
        theta_0member) < 6.283185307179586E-06,"abs(reference1.theta-reference2.theta) < 6.283185307179586E-06",
         "Reference angles should be equal!");
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return residue0_0;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Streams.readRealMatrix
input String fileName "File where external data is stored" annotation (Dialog(loadSelector(filter="MATLAB MAT files (*.mat)", caption="Open MATLAB MAT file")));
input String matrixName "Name / identifier of the 2D Real array on the file";
input Integer nrow "Number of rows of the 2D Real array";
input Integer ncol "Number of columns of the 2D Real array";
input Boolean verboseRead(start = true) "= true: Print info message; = false: No info message";
discrete output Real matrix[nrow, ncol] "2D Real array";

external "C" ModelicaIO_readRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), verboseRead);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Utilities.Streams.readRealMatrix;

  */
extern void (ModelicaIO_readRealMatrix)(const char* , const char* , double  *, 
  size_t, size_t, int );
DYMOLA_STATIC RealArray    Modelica_Utilities_Streams_readRealMatrix_M(
  const char*  fileName0_0, const char*  matrixName0_0, int  nrow0_0, int  
  ncol0_0, int  verboseRead0_0) {
  PushContext("Modelica.Utilities.Streams.readRealMatrix")
  {
    /* Declare outputs and temporaries */
    RealArray    matrix0_0;
    MarkObject retmark_ = PushMark();
    matrix0_0=RealTemporary( 2, nrow0_0, ncol0_0);
    RePushMark(&retmark_);
    RealFillAssign( matrix0_0, 0);
    /* Start of real code */
    {
      (ModelicaIO_readRealMatrix)(fileName0_0, matrixName0_0, matrix0_0.data, 
        matrix0_0.dims[1-1], matrix0_0.dims[2-1], verboseRead0_0);
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return matrix0_0;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Streams.writeRealMatrix
input String fileName "File where external data is to be stored" annotation (Dialog(saveSelector(filter="MATLAB MAT files (*.mat)", caption="Save MATLAB MAT file")));
input String matrixName "Name / identifier of the 2D Real array on the file";
discrete input Real matrix[:, :] "2D Real array";
input Boolean append(start = false) "Append values to file";
input String format(start = "4") "MATLAB MAT file version: \"4\" -> v4, \"6\" -> v6, \"7\" -> v7" annotation (choices(choice="4" "MATLAB v4 MAT file", choice="6" "MATLAB v6 MAT file", choice="7" "MATLAB v7 MAT file"));
output Boolean success "true if successful";

external "C" success = ModelicaIO_writeRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), append, format);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Utilities.Streams.writeRealMatrix;

  */
extern int (ModelicaIO_writeRealMatrix)(const char* , const char* , double 
   const *, size_t, size_t, int , const char* );
DYMOLA_STATIC int   Modelica_Utilities_Streams_writeRealMatrix_M(const char*  
  fileName0_0, const char*  matrixName0_0, RealArray   matrix0_0, int  append0_0,
   const char*  format0_0) {
  PushContext("Modelica.Utilities.Streams.writeRealMatrix")
  {
    /* Declare outputs and temporaries */
    int   success0_0;
    success0_0=0;
    /* Start of real code */
    {
      success0_0 = (ModelicaIO_writeRealMatrix)(fileName0_0, matrixName0_0, 
        matrix0_0.data, matrix0_0.dims[1-1], matrix0_0.dims[2-1], append0_0, 
        format0_0);
      }
    /* Output section */
    PopContext()
    return success0_0;
  }}
/* DSblock C-code: */

#define NX_    1
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    46
#define NP_    15
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -916023081
#define NHash2_ -1641527463
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  3
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    55
#define SizePre_ 5
#define SizeEq_ 4
#define SizeDelay_ 0
#define QNLmax_ 1
#define MAXAux 7
#define NrDymolaTimers_ 0
#define NWhen_ 5
#define NCheckIf_ 0
#define NGlobalHelp_ 113
#define NGlobalHelpI_ 26
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="HPF.Test.SinglePhase_HarmonicLoad";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,0) = 1;
DYNX(W_,8) = 1;
DYNX(W_,9) = 1;
DYNX(W_,13) = 1;
DYNX(W_,22) = 1;
DYNX(W_,23) = 1;
DYNX(W_,30) = 1;
DYNX(W_,31) = 1;
DYNX(W_,37) = 1;
DYNX(W_,38) = 1;
DYNX(W_,41) = 1;
DYNX(W_,43) = 1;
DYNX(W_,15) = 0.0;
DYNX(W_,14) = 0.0;
DYNX(W_,25) = 0.0;
DYNX(W_,24) = 0.0;
DYNX(W_,11) = 0.0;
DYNX(W_,10) = 0.0;
DYNX(W_,45) = 0.0;
DYNX(W_,44) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
BoundParameterConstantSection
DYNX(DYNhelp,0) = cos(DYNX(DP_,4));
DYNX(W_,4) = DYNX(DP_,3)*DYNX(DYNhelp,0);
DYNX(DYNhelp,1) = sin(DYNX(DP_,4));
DYNX(W_,5) = DYNX(DP_,3)*DYNX(DYNhelp,1);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1) = true;
DYNX(W_,2) = false;
DYNX(W_,3) = false;
DYNX(W_,6) = 0;
DYNX(W_,7) = 0;
DYNX(W_,12) = 0;
DYNX(W_,18) = 0;
DYNX(W_,19) = 0;
DYNX(W_,20) = 0;
DYNX(W_,21) = 0;
DYNX(W_,26) = 0;
DYNX(W_,27) = 0;
DYNX(W_,28) = 0;
DYNX(W_,29) = 0;
DYNX(W_,32) = 0;
DYNX(W_,33) = 0;
DYNX(W_,35) = 0;
DYNX(W_,36) = 0;
DYNX(W_,39) = 0;
DYNX(W_,40) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,2);
DYNX(Aux_,1) = DYNX(W_,3);
DYNX(Aux_,2) = DYNX(W_,1);
DYNX(Aux_,3) = DYNX(W_,27);
DYNX(Aux_,4) = DYNX(W_,26);
InitialSection
InitialSection2
DYNX(W_,26) = DYNX(Aux_,4);
DYNX(W_,27) = DYNX(Aux_,3);
DYNX(X_,0) = DYNX(W_,12);
DYNX(W_,2) = DYNX(Aux_,0);
  DYNX(W_,1) = false;
DYNX(W_,3) = DYNX(Aux_,1);
InitialBoundSection
DYNX(Aux_,2) = DYNX(W_,1);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(F_,0) = 6.283185307179586*DYNX(DP_,2);

AcceptedSection1
DYNX(W_,34) = DYNX(X_,0);
DYNX(W_,42) = DYNX(X_,0);

RealFillAssign ((PushModelContext(1,"HPF.Types.Reference.equalityConstraint(\nz.pin_n.reference, \nz1.pin_p.reference)")
  HPF_Types_Reference_equalityConstraint(DymStruc0_construct(DYNX(W_,34)), 
  DymStruc0_construct(DYNX(X_,0)))), 0);
PopAllMarks();
RealFillAssign ((PushModelContext(1,"HPF.Types.Reference.equalityConstraint(\nz.pin_n.reference, \nz2.pin_p.reference)")
  HPF_Types_Reference_equalityConstraint(DymStruc0_construct(DYNX(W_,34)), 
  DymStruc0_construct(DYNX(W_,42)))), 0);
PopAllMarks();
AcceptedSection2
DYNX(W_,12) = DYNX(X_,0);
DYNX(W_,1) = PRE(DYNX(W_,1), 0);
DYNX(W_,2) = PRE(DYNX(W_,2), 1);
DYNX(W_,3) = PRE(DYNX(W_,3), 2);
  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.5,"0.5", 0), 0) 
    DYNX(W_,1) = true;
  endwhenModelica()
  endwhenBlock

  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.25,"0.25", 1), 1) 
    DYNX(W_,2) = true;
  endwhenModelica()
  endwhenBlock

  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.4,"0.4", 2), 2) 
    DYNX(W_,3) = true;
  endwhenModelica()
  endwhenBlock


{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 7 common subexpressions used in 7 expressions */
/* Of the common subexpressions 6 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"z2.i[1].re", "z2.i[1].im", "test_Load1.i[1].im", 
  "test_Load1.i[1].re"};
const double nominal_[]={1, 1, 1, 1};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 4, 0, 1, 1, -2, 3, 
  DYNX(DYNhelp,2), 104, DYNX(did_->helpvari_vec,0), 26);
NonLinearSystemSave(DYNX(W_,2), 0);
NonLinearSystemSave(DYNX(W_,3), 1);
NonLinearSystemSave(DYNX(W_,1), 2);
SetInitVectorNH(x__, 1, DYNX(W_,39), Remember_(DYNX(W_,39), 0));
SetInitVectorNH(x__, 2, DYNX(W_,40), Remember_(DYNX(W_,40), 1));
SetInitVectorNH(x__, 3, DYNX(W_,21), Remember_(DYNX(W_,21), 2));
SetInitVectorNH(x__, 4, DYNX(W_,20), Remember_(DYNX(W_,20), 3));
Residues;
  DYNX(W_,7) =  -(DYNX(W_,21)+DYNX(W_,40));
  DYNX(W_,6) =  -(DYNX(W_,20)+DYNX(W_,39));
  DYNX(DYNhelp,106) = DYNX(DP_,9)*DYNX(DP_,0);
  DYNX(DYNhelp,107) = DYNX(DP_,10)*DYNX(DP_,0);
  DYNX(W_,29) =  -(DYNX(DYNhelp,106)*DYNX(W_,7)+DYNX(DYNhelp,107)*DYNX(W_,6));
  DYNX(DYNhelp,108) = DYNX(DP_,13)*DYNX(DP_,0);
  DYNX(DYNhelp,109) = DYNX(DP_,14)*DYNX(DP_,0);
  DYNX(W_,33) = DYNX(DYNhelp,108)*DYNX(W_,40)+DYNX(DYNhelp,109)*DYNX(W_,39);
  DYNX(DYNhelp,110) = DYNX(DP_,11)*DYNX(DP_,0);
  DYNX(DYNhelp,111) = DYNX(DP_,12)*DYNX(DP_,0);
  DYNX(W_,36) = DYNX(DYNhelp,110)*DYNX(W_,21)+DYNX(DYNhelp,111)*DYNX(W_,20);
  DYNX(W_,35) = DYNX(DYNhelp,110)*DYNX(W_,20)-DYNX(DYNhelp,111)*DYNX(W_,21);
  DYNX(W_,32) = DYNX(DYNhelp,108)*DYNX(W_,39)-DYNX(DYNhelp,109)*DYNX(W_,40);
  DYNX(W_,28) = DYNX(DYNhelp,107)*DYNX(W_,7)-DYNX(DYNhelp,106)*DYNX(W_,6);
  DYNX(W_,18) = DYNX(W_,32)-DYNX(W_,35);
  DYNX(W_,19) = DYNX(W_,33)-DYNX(W_,36);
    DYNX(Aux_,5) = PRE(DYNX(W_,26), 3);
    DYNX(Aux_,6) = PRE(DYNX(W_,27), 4);
    beginwhenBlock
    whenModelica(( DYNX(W_,2) != PRE(DYNX(W_,2), 1) ), 3) 
      (PushModelContext(1,"HPF.SinglePhase.NonlinearLoads.DataIO.writeNodeVoltage(\ntest_Load1.v[1], \n\"testLoad\")")
        HPF_SinglePhase_NonlinearLoads_DataIO_writeNodeVoltage(DymStruc1_construct(
        DYNX(W_,19), DYNX(W_,18)), "testLoad"));
      PopModelContext();
    endwhenModelica()
    endwhenBlock

    beginwhenBlock
    whenModelica(( DYNX(W_,3) != PRE(DYNX(W_,3), 2) ), 4) 
      {
        struct DymStruc1 dummy_DymStruc1;
        dummy_DymStruc1 = (PushModelContext(1,"HPF.SinglePhase.NonlinearLoads.DataIO.readNodeVoltage(\"testLoad\")")
          HPF_SinglePhase_NonlinearLoads_DataIO_readNodeVoltage("testLoad"));
        DYNX(Aux_,6) = dummy_DymStruc1.im_0member;
        DYNX(Aux_,5) = dummy_DymStruc1.re_0member;
      PopModelContext();
      }
    endwhenModelica()
    endwhenBlock

  DYNX(W_,26) = DYNX(Aux_,5);
  DYNX(W_,27) = DYNX(Aux_,6);
DYNX(DYNhelp,112) = DYNX(W_,1) == false;
SetVector(residue__, 1, IF DYNX(DYNhelp,112) THEN DYNX(DP_,5)-DYNX(W_,18)*
  DYNX(W_,20) ELSE DYNX(W_,20)+0.5*DYNX(DP_,7)*DYNX(W_,26));
SetVector(residue__, 2, IF DYNX(DYNhelp,112) THEN DYNX(DP_,6)+DYNX(W_,19)*
  DYNX(W_,21) ELSE DYNX(W_,21)+0.5*DYNX(DP_,8)*DYNX(W_,27));
SetVector(residue__, 3, DYNX(W_,28)-DYNX(W_,4)+DYNX(W_,32));
SetVector(residue__, 4, DYNX(W_,29)-DYNX(W_,5)+DYNX(W_,33));

{ /* No analytic Jacobian available*/
SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 1, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,39) = GetVector(x__, 1);
DYNX(W_,40) = GetVector(x__, 2);
DYNX(W_,21) = GetVector(x__, 3);
DYNX(W_,20) = GetVector(x__, 4);
EndNonLinearSystemOfEquationsNH(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,16) = DYNX(W_,21)+DYNX(W_,7)+DYNX(W_,40);
DYNX(W_,17) = DYNX(W_,20)+DYNX(W_,6)+DYNX(W_,39);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("systemDef.hrms[1]", "Harmonics to simulate [:#(type=Integer)]",\
 0, 1, 0.0,0.0,0.0,0,564)
DeclareVariable("systemDef.numHrm", "Number of harmonics. (Automatically generated from hrms. Do not alter) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareParameter("systemDef.numPh", "Number of phases [:#(type=Integer)]", 1, 3,\
 0.0,0.0,0.0,0,564)
DeclareParameter("systemDef.fFund", "Fundamental frequency", 2, 60, 0.0,0.0,0.0,\
0,560)
DeclareVariable("systemDef.modeSelect", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,\
0,642)
DeclareVariable("systemDef.event1", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("systemDef.event2", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("v.v[1].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("v.v[1].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("v.i[1].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,640)
DeclareVariable("v.i[1].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,640)
DeclareAlias2("v.omega", "[rad/s]", "z1.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("v.pin_p.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareAlias2("v.pin_p.v[1].re", "Real part of complex number", "v.v[1].re", 1, 5,\
 4, 0)
DeclareAlias2("v.pin_p.v[1].im", "Imaginary part of complex number", "v.v[1].im", 1,\
 5, 5, 0)
DeclareAlias2("v.pin_p.iIm[1]", "", "v.i[1].im", 1, 5, 7, 132)
DeclareAlias2("v.pin_p.iRe[1]", "", "v.i[1].re", 1, 5, 6, 132)
DeclareAlias2("v.pin_p.reference.theta", "[rad|deg]", "v.theta", 1, 5, 12, 0)
DeclareAlias2("v.pin_p.reference.der(theta)", "[rad/s]", "z1.pin_p.reference.der(theta)", 1,\
 6, 0, 0)
DeclareVariable("v.pin_n.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareVariable("v.pin_n.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("v.pin_n.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("v.pin_n.iIm[1]", "", "v.i[1].im", -1, 5, 7, 132)
DeclareAlias2("v.pin_n.iRe[1]", "", "v.i[1].re", -1, 5, 6, 132)
DeclareAlias2("v.pin_n.reference.theta", "[rad|deg]", "v.theta", 1, 5, 12, 0)
DeclareVariable("v.theta", "[rad|deg]", 0, 0.0,0.0,0.0,0,528)
DeclareParameter("v.vMag[1]", "Voltage Magnitude", 3, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("v.vArg[1]", "Voltage angle", 4, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("ground1.pin.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareVariable("ground1.pin.v[1].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.iIm[1]", "", 0.0, 0.0,0.0,0.0,0,904)
DeclareVariable("ground1.pin.iRe[1]", "", 0.0, 0.0,0.0,0.0,0,904)
DeclareAlias2("ground1.pin.reference.theta", "[rad|deg]", "v.theta", 1, 5, 12, 0)
DeclareVariable("test_Load1.v[1].re", "Real part of complex number", 0, 0.0,0.0,\
0.0,0,640)
DeclareVariable("test_Load1.v[1].im", "Imaginary part of complex number", 0, \
0.0,0.0,0.0,0,640)
DeclareVariable("test_Load1.i[1].re", "Real part of complex number", 0, 0.0,0.0,\
0.0,0,704)
DeclareVariable("test_Load1.i[1].im", "Imaginary part of complex number", 0, \
0.0,0.0,0.0,0,704)
DeclareAlias2("test_Load1.omega", "[rad/s]", "z1.pin_p.reference.der(theta)", 1,\
 6, 0, 0)
DeclareVariable("test_Load1.pin_p.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareAlias2("test_Load1.pin_p.v[1].re", "Real part of complex number", \
"test_Load1.v[1].re", 1, 5, 18, 64)
DeclareAlias2("test_Load1.pin_p.v[1].im", "Imaginary part of complex number", \
"test_Load1.v[1].im", 1, 5, 19, 64)
DeclareAlias2("test_Load1.pin_p.iIm[1]", "", "test_Load1.i[1].im", 1, 5, 21, 132)
DeclareAlias2("test_Load1.pin_p.iRe[1]", "", "test_Load1.i[1].re", 1, 5, 20, 132)
DeclareAlias2("test_Load1.pin_p.reference.theta", "[rad|deg]", "v.theta", 1, 5, 12,\
 0)
DeclareAlias2("test_Load1.pin_p.reference.der(theta)", "[rad/s]", \
"z1.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("test_Load1.pin_n.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareVariable("test_Load1.pin_n.v[1].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.pin_n.v[1].im", "Imaginary part of complex number", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("test_Load1.pin_n.iIm[1]", "", "test_Load1.i[1].im", -1, 5, 21, 132)
DeclareAlias2("test_Load1.pin_n.iRe[1]", "", "test_Load1.i[1].re", -1, 5, 20, 132)
DeclareAlias2("test_Load1.pin_n.reference.theta", "[rad|deg]", "v.theta", 1, 5, 12,\
 0)
DeclareParameter("test_Load1.sReal", "", 5, 150, 0.0,0.0,0.0,0,560)
DeclareParameter("test_Load1.sImag", "", 6, 33, 0.0,0.0,0.0,0,560)
DeclareParameter("test_Load1.iReal[1]", "", 7, 5, 0.0,0.0,0.0,0,560)
DeclareParameter("test_Load1.iImag[1]", "", 8, 3, 0.0,0.0,0.0,0,560)
DeclareVariable("test_Load1.vPre.re", "Real part of complex number", 0, 0.0,0.0,\
0.0,0,656)
DeclareVariable("test_Load1.vPre.im", "Imaginary part of complex number", 0, \
0.0,0.0,0.0,0,656)
DeclareVariable("z.v[1].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,640)
DeclareVariable("z.v[1].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,640)
DeclareAlias2("z.i[1].re", "Real part of complex number", "v.i[1].re", -1, 5, 6,\
 0)
DeclareAlias2("z.i[1].im", "Imaginary part of complex number", "v.i[1].im", -1, 5,\
 7, 0)
DeclareAlias2("z.omega", "[rad/s]", "z1.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("z.pin_p.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareAlias2("z.pin_p.v[1].re", "Real part of complex number", "v.v[1].re", 1, 5,\
 4, 0)
DeclareAlias2("z.pin_p.v[1].im", "Imaginary part of complex number", "v.v[1].im", 1,\
 5, 5, 0)
DeclareAlias2("z.pin_p.iIm[1]", "", "v.i[1].im", -1, 5, 7, 132)
DeclareAlias2("z.pin_p.iRe[1]", "", "v.i[1].re", -1, 5, 6, 132)
DeclareAlias2("z.pin_p.reference.theta", "[rad|deg]", "v.theta", 1, 5, 12, 0)
DeclareAlias2("z.pin_p.reference.der(theta)", "[rad/s]", "z1.pin_p.reference.der(theta)", 1,\
 6, 0, 0)
DeclareVariable("z.pin_n.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareVariable("z.pin_n.v[1].re", "Real part of complex number", 0, 0.0,0.0,0.0,\
0,640)
DeclareVariable("z.pin_n.v[1].im", "Imaginary part of complex number", 0, \
0.0,0.0,0.0,0,640)
DeclareAlias2("z.pin_n.iIm[1]", "", "v.i[1].im", 1, 5, 7, 132)
DeclareAlias2("z.pin_n.iRe[1]", "", "v.i[1].re", 1, 5, 6, 132)
DeclareVariable("z.pin_n.reference.theta", "[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("z.z.re", "Real part of complex number", 9, 5.0, 0.0,0.0,0.0,0,560)
DeclareParameter("z.z.im", "Imaginary part of complex number", 10, 2.0, 0.0,0.0,\
0.0,0,560)
DeclareVariable("z1.v[1].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,640)
DeclareVariable("z1.v[1].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,640)
DeclareAlias2("z1.i[1].re", "Real part of complex number", "test_Load1.i[1].re", 1,\
 5, 20, 0)
DeclareAlias2("z1.i[1].im", "Imaginary part of complex number", "test_Load1.i[1].im", 1,\
 5, 21, 0)
DeclareAlias2("z1.omega", "[rad/s]", "z1.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("z1.pin_p.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareAlias2("z1.pin_p.v[1].re", "Real part of complex number", \
"z.pin_n.v[1].re", 1, 5, 32, 0)
DeclareAlias2("z1.pin_p.v[1].im", "Imaginary part of complex number", \
"z.pin_n.v[1].im", 1, 5, 33, 0)
DeclareAlias2("z1.pin_p.iIm[1]", "", "test_Load1.i[1].im", 1, 5, 21, 132)
DeclareAlias2("z1.pin_p.iRe[1]", "", "test_Load1.i[1].re", 1, 5, 20, 132)
DeclareState("z1.pin_p.reference.theta", "[rad|deg]", 0, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("z1.pin_p.reference.der(theta)", "[rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("z1.pin_n.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareAlias2("z1.pin_n.v[1].re", "Real part of complex number", \
"test_Load1.v[1].re", 1, 5, 18, 0)
DeclareAlias2("z1.pin_n.v[1].im", "Imaginary part of complex number", \
"test_Load1.v[1].im", 1, 5, 19, 0)
DeclareAlias2("z1.pin_n.iIm[1]", "", "test_Load1.i[1].im", -1, 5, 21, 132)
DeclareAlias2("z1.pin_n.iRe[1]", "", "test_Load1.i[1].re", -1, 5, 20, 132)
DeclareAlias2("z1.pin_n.reference.theta", "[rad|deg]", "v.theta", 1, 5, 12, 0)
DeclareParameter("z1.z.re", "Real part of complex number", 11, 10.0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("z1.z.im", "Imaginary part of complex number", 12, 5.0, \
0.0,0.0,0.0,0,560)
DeclareAlias2("z2.v[1].re", "Real part of complex number", "z.pin_n.v[1].re", 1,\
 5, 32, 64)
DeclareAlias2("z2.v[1].im", "Imaginary part of complex number", "z.pin_n.v[1].im", 1,\
 5, 33, 64)
DeclareVariable("z2.i[1].re", "Real part of complex number", 0, 0.0,0.0,0.0,0,704)
DeclareVariable("z2.i[1].im", "Imaginary part of complex number", 0, 0.0,0.0,0.0,\
0,704)
DeclareAlias2("z2.omega", "[rad/s]", "z1.pin_p.reference.der(theta)", 1, 6, 0, 0)
DeclareVariable("z2.pin_p.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareAlias2("z2.pin_p.v[1].re", "Real part of complex number", \
"z.pin_n.v[1].re", 1, 5, 32, 0)
DeclareAlias2("z2.pin_p.v[1].im", "Imaginary part of complex number", \
"z.pin_n.v[1].im", 1, 5, 33, 0)
DeclareAlias2("z2.pin_p.iIm[1]", "", "z2.i[1].im", 1, 5, 40, 132)
DeclareAlias2("z2.pin_p.iRe[1]", "", "z2.i[1].re", 1, 5, 39, 132)
DeclareVariable("z2.pin_p.reference.theta", "[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("z2.pin_p.reference.der(theta)", "[rad/s]", "z1.pin_p.reference.der(theta)", 1,\
 6, 0, 0)
DeclareVariable("z2.pin_n.h", "[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,525)
DeclareVariable("z2.pin_n.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("z2.pin_n.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("z2.pin_n.iIm[1]", "", "z2.i[1].im", -1, 5, 40, 132)
DeclareAlias2("z2.pin_n.iRe[1]", "", "z2.i[1].re", -1, 5, 39, 132)
DeclareAlias2("z2.pin_n.reference.theta", "[rad|deg]", "v.theta", 1, 5, 12, 0)
DeclareParameter("z2.z.re", "Real part of complex number", 13, 2.0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("z2.z.im", "Imaginary part of complex number", 14, 1.0, \
0.0,0.0,0.0,0,560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
pre(DYNX(W_,2),"systemDef.event1", false, 1);
pre(DYNX(W_,3),"systemDef.event2", false, 2);
pre(DYNX(W_,1),"systemDef.modeSelect", true, 0);
pre(DYNX(W_,27),"test_Load1.vPre.im", 0, 4);
pre(DYNX(W_,26),"test_Load1.vPre.re", 0, 3);
EndPreBlock
StartEqBlock
DoRememAcc_(DYNX(W_,21), 0, 2);
DoRememAcc_(DYNX(W_,20), 0, 3);
DoRememAcc_(DYNX(W_,40), 0, 1);
DoRememAcc_(DYNX(W_,39), 0, 0);
EndEqBlock
UpdateQEvaluate(5)
EndDataBlock
