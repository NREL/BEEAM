#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model HPF.Test.SinglePhase_HarmonicLoad
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Mon Jun 24 13:37:45 2019

  Evaluate = true;
 */

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays0[4]={100.0, 5.0, 0.0, 0.5};
static double DymArrays1[10]={-150.0, 20.0, 5.0, 2.0, 0.25, 0.5, -150.0, 0.0, 
  20.0, 0.0};
#endif
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc1;
struct DymStruc0 {
  double  theta_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(double   theta_02) {
  struct DymStruc0 dummy_0;
  dummy_0.theta_0member = theta_02;
  return dummy_0;
}
struct DymStruc1 {
  double  re_0member;
  double  im_0member;
};
DYMOLA_STATIC struct DymStruc1 DymStruc1_construct(double   im_02, double   
  re_02) {
  struct DymStruc1 dummy_0;
  dummy_0.im_0member = im_02;
  dummy_0.re_0member = re_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC struct DymStruc1  HPF_SinglePhase_NonlinearLoads_DataIO_readNodeVoltage
  (const char*  name0_0);
DYMOLA_STATIC void HPF_SinglePhase_NonlinearLoads_DataIO_writeNodeVoltage(
  struct DymStruc1 data0_0, const char*  name0_0);
DYMOLA_STATIC RealArray    HPF_Types_Reference_equalityConstraint(struct 
  DymStruc0 reference10_0, struct DymStruc0 reference20_0);
DYMOLA_STATIC double   Modelica_Math_atan3(double  u10_0, double  u20_0, double 
   y00_0);
DYMOLA_STATIC RealArray    Modelica_Utilities_Streams_readRealMatrix_M(
  const char*  fileName0_0, const char*  matrixName0_0, int  nrow0_0, int  
  ncol0_0, int  verboseRead0_0);
DYMOLA_STATIC int   Modelica_Utilities_Streams_writeRealMatrix_M(const char*  
  fileName0_0, const char*  matrixName0_0, RealArray   matrix0_0, int  append0_0,
   const char*  format0_0);
/* Codes used in model */

/* Flattened Modelica model:

function HPF.SinglePhase.NonlinearLoads.DataIO.readNodeVoltage
input String name;
output Complex v;
protected 
discrete Real readMatrix[2, 1];
public 
algorithm 
readMatrix := Modelica.Utilities.Streams.readRealMatrix(name+".mat", "data", 2, 1, true);
v.re := readMatrix[1, 1];
v.im := readMatrix[2, 1];
end HPF.SinglePhase.NonlinearLoads.DataIO.readNodeVoltage;

  */
DYMOLA_STATIC struct DymStruc1  HPF_SinglePhase_NonlinearLoads_DataIO_readNodeVoltage
  (const char*  name0_0) {
  char*retSMark_=GetStringMark();
  PushContext("HPF.SinglePhase.NonlinearLoads.DataIO.readNodeVoltage")
  {
    /* Declare outputs and temporaries */
    struct DymStruc1  v0_0;
    RealArray    readMatrix0_0;
    MarkObject retmark_ = PushMark();
    v0_0.re_0member=0;
    v0_0.im_0member=0;
    readMatrix0_0=RealTemporary( 2, 2, 1);
    PushMark();
    RealFillAssign( readMatrix0_0, 0);
    /* Start of real code */
      RealAssign (readMatrix0_0, Modelica_Utilities_Streams_readRealMatrix_M(
        StringAdd(name0_0,".mat"), "data", 2, 1, true));
      Release();
      v0_0.re_0member = RealMatrixElement( readMatrix0_0, (SizeType)(1), 
        (SizeType)(1));
      v0_0.im_0member = RealMatrixElement( readMatrix0_0, (SizeType)(2), 
        (SizeType)(1));
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return v0_0;
  }}

/* Flattened Modelica model:

function HPF.SinglePhase.NonlinearLoads.DataIO.writeNodeVoltage
input Complex data;
input String name;
protected 
discrete Real dataMatrix[2, 1](start = {{data.re}, {data.im}});
public 
algorithm 
Modelica.Utilities.Streams.writeRealMatrix(name+".mat", "data", dataMatrix, false, "4");
end HPF.SinglePhase.NonlinearLoads.DataIO.writeNodeVoltage;

  */
DYMOLA_STATIC void HPF_SinglePhase_NonlinearLoads_DataIO_writeNodeVoltage(
  struct DymStruc1 data0_0, const char*  name0_0) {
  char*retSMark_=GetStringMark();
  PushContext("HPF.SinglePhase.NonlinearLoads.DataIO.writeNodeVoltage")
  {
    /* Declare outputs and temporaries */
    RealArray    dataMatrix0_0;
    MarkObject retmark_ = PushMark();
    dataMatrix0_0=RealTemporary( 2, 2, 1);
    PushMark();
    RealAssign (dataMatrix0_0, RealArrayArray ( 2, RealScalarArray ( 1, data0_0.
      re_0member), RealScalarArray ( 1, data0_0.im_0member)));
    Release();
    /* Start of real code */
      Modelica_Utilities_Streams_writeRealMatrix_M(StringAdd(name0_0,".mat"), 
        "data", dataMatrix0_0, false, "4");
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function HPF.Types.Reference.equalityConstraint
input HPF.Types.Reference reference1;
input HPF.Types.Reference reference2;
discrete output Real residue[0];

algorithm 
assert(abs(reference1.theta-reference2.theta) < 6.283185307179586E-06, "Reference angles should be equal!");
end HPF.Types.Reference.equalityConstraint;

  */
DYMOLA_STATIC RealArray    HPF_Types_Reference_equalityConstraint(struct 
  DymStruc0 reference10_0, struct DymStruc0 reference20_0) {
  PushContext("HPF.Types.Reference.equalityConstraint")
  {
    /* Declare outputs and temporaries */
    RealArray    residue0_0;
    MarkObject retmark_ = PushMark();
    residue0_0=RealTemporary( 1, 0);
    RePushMark(&retmark_);
    RealFillAssign( residue0_0, 0);
    /* Start of real code */
      AssertModelica(fabs(reference10_0.theta_0member-reference20_0.
        theta_0member) < 6.283185307179586E-06,"abs(reference1.theta-reference2.theta) < 6.283185307179586E-06",
         "Reference angles should be equal!");
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return residue0_0;
  }}

/* Flattened Modelica model:

function Modelica.Math.atan3
discrete input Real u1;
discrete input Real u2;
discrete input Real y0(start = 0, unit = "rad", displayUnit = "deg") "y shall be in the range: -pi < y-y0 <= pi";
discrete output Real y(unit = "rad", displayUnit = "deg");
protected 
constant Real pi2 = 6.283185307179586;
discrete Real w;
public 
algorithm 
w := atan2(u1, u2);
if (y0 == 0) then 
y := w;
else
y := w+pi2*integer((3.141592653589793+y0-w)/pi2);
end if;
end Modelica.Math.atan3;

  */
DYMOLA_STATIC double   Modelica_Math_atan3(double  u10_0, double  u20_0, double 
   y00_0) {
  PushContext("Modelica.Math.atan3")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   pi20_0;
    double   w0_0;
    y0_0=0;
    pi20_0 = 6.283185307179586;
    w0_0=0;
    /* Start of real code */
      w0_0 = atan2(u10_0, u20_0);
      if (y00_0 == 0) {
        y0_0 = w0_0;
      }
      else{
        y0_0 = w0_0+pi20_0*real2integer(divGuarded(3.141592653589793+y00_0-w0_0,
          "3.141592653589793+y0-w",pi20_0,"pi2"));
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Streams.readRealMatrix
input String fileName "File where external data is stored" annotation (Dialog(loadSelector(filter="MATLAB MAT files (*.mat)", caption="Open MATLAB MAT file")));
input String matrixName "Name / identifier of the 2D Real array on the file";
input Integer nrow "Number of rows of the 2D Real array";
input Integer ncol "Number of columns of the 2D Real array";
input Boolean verboseRead(start = true) "= true: Print info message; = false: No info message";
discrete output Real matrix[nrow, ncol] "2D Real array";

external "C" ModelicaIO_readRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), verboseRead);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Utilities.Streams.readRealMatrix;

  */
extern void (ModelicaIO_readRealMatrix)(const char* , const char* , double  *, 
  size_t, size_t, int );
DYMOLA_STATIC RealArray    Modelica_Utilities_Streams_readRealMatrix_M(
  const char*  fileName0_0, const char*  matrixName0_0, int  nrow0_0, int  
  ncol0_0, int  verboseRead0_0) {
  PushContext("Modelica.Utilities.Streams.readRealMatrix")
  {
    /* Declare outputs and temporaries */
    RealArray    matrix0_0;
    MarkObject retmark_ = PushMark();
    matrix0_0=RealTemporary( 2, nrow0_0, ncol0_0);
    RePushMark(&retmark_);
    RealFillAssign( matrix0_0, 0);
    /* Start of real code */
    {
      (ModelicaIO_readRealMatrix)(fileName0_0, matrixName0_0, matrix0_0.data, 
        matrix0_0.dims[1-1], matrix0_0.dims[2-1], verboseRead0_0);
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return matrix0_0;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Streams.writeRealMatrix
input String fileName "File where external data is to be stored" annotation (Dialog(saveSelector(filter="MATLAB MAT files (*.mat)", caption="Save MATLAB MAT file")));
input String matrixName "Name / identifier of the 2D Real array on the file";
discrete input Real matrix[:, :] "2D Real array";
input Boolean append(start = false) "Append values to file";
input String format(start = "4") "MATLAB MAT file version: \"4\" -> v4, \"6\" -> v6, \"7\" -> v7" annotation (choices(choice="4" "MATLAB v4 MAT file", choice="6" "MATLAB v6 MAT file", choice="7" "MATLAB v7 MAT file"));
output Boolean success "true if successful";

external "C" success = ModelicaIO_writeRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), append, format);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Utilities.Streams.writeRealMatrix;

  */
extern int (ModelicaIO_writeRealMatrix)(const char* , const char* , double 
   const *, size_t, size_t, int , const char* );
DYMOLA_STATIC int   Modelica_Utilities_Streams_writeRealMatrix_M(const char*  
  fileName0_0, const char*  matrixName0_0, RealArray   matrix0_0, int  append0_0,
   const char*  format0_0) {
  PushContext("Modelica.Utilities.Streams.writeRealMatrix")
  {
    /* Declare outputs and temporaries */
    int   success0_0;
    success0_0=0;
    /* Start of real code */
    {
      success0_0 = (ModelicaIO_writeRealMatrix)(fileName0_0, matrixName0_0, 
        matrix0_0.data, matrix0_0.dims[1-1], matrix0_0.dims[2-1], append0_0, 
        format0_0);
      }
    /* Output section */
    PopContext()
    return success0_0;
  }}
/* DSblock C-code: */

#define NX_    1
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    111
#define NP_    0
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 649954002
#define NHash2_ -2018518881
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  3
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    58
#define SizePre_ 5
#define SizeEq_ 6
#define SizeDelay_ 0
#define QNLmax_ 2
#define MAXAux 5
#define NrDymolaTimers_ 0
#define NWhen_ 5
#define NCheckIf_ 0
#define NGlobalHelp_ 164
#define NGlobalHelpI_ 50
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="HPF.Test.SinglePhase_HarmonicLoad";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,2) = 2;
DYNX(W_,17) = 2;
DYNX(W_,22) = 2;
DYNX(W_,32) = 2;
DYNX(W_,45) = 2;
DYNX(W_,52) = 2;
DYNX(W_,66) = 2;
DYNX(W_,69) = 2;
DYNX(W_,87) = 2;
DYNX(W_,90) = 2;
DYNX(W_,0) = 1;
DYNX(W_,1) = 3;
DYNX(W_,3) = 3;
DYNX(W_,4) = 60;
memcpy(&DYNX(W_,28), &DymArrays0, sizeof(double)*4);
DYNX(W_,55) = 5.0;
DYNX(W_,56) = 2.0;
DYNX(W_,74) = 2.0;
DYNX(W_,75) = 1.0;
memcpy(&DYNX(W_,95), &DymArrays1, sizeof(double)*10);
DYNX(W_,19) = 0.0;
DYNX(W_,18) = 100.0;
DYNX(W_,21) = 2.397127693021015;
DYNX(W_,20) = 4.387912809451864;
DYNX(W_,89) = 376.99111843077515;
DYNX(W_,51) = 376.99111843077515;
DYNX(W_,68) = 376.99111843077515;
DYNX(W_,34) = 0.0;
DYNX(W_,33) = 0.0;
DYNX(W_,36) = 0.0;
DYNX(W_,35) = 0.0;
DYNX(W_,86) = 376.99111843077515;
DYNX(W_,92) = 0.0;
DYNX(W_,91) = 0.0;
DYNX(W_,94) = 0.0;
DYNX(W_,93) = 0.0;
DYNX(W_,106) = 20.0;
DYNX(W_,105) = -150.0;
DYNX(W_,108) = 0.0;
DYNX(W_,107) = 0.0;
DYNX(W_,16) = 376.99111843077515;
DYNX(W_,24) = 0.0;
DYNX(W_,23) = 0.0;
DYNX(W_,26) = 0.0;
DYNX(W_,25) = 0.0;
DYNX(W_,9) = 0.0;
DYNX(W_,8) = 100.0;
DYNX(W_,11) = 2.397127693021015;
DYNX(W_,10) = 4.387912809451864;
DYNX(W_,44) = 376.99111843077515;
DYNX(W_,47) = 0.0;
DYNX(W_,46) = 100.0;
DYNX(W_,49) = 2.397127693021015;
DYNX(W_,48) = 4.387912809451864;
DYNX(W_,65) = 376.99111843077515;
DYNX(W_,71) = 0.0;
DYNX(W_,70) = 0.0;
DYNX(W_,73) = 0.0;
DYNX(W_,72) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,5) = true;
DYNX(W_,6) = false;
DYNX(W_,7) = false;
DYNX(W_,12) = 0;
DYNX(W_,13) = 0;
DYNX(W_,14) = 0;
DYNX(W_,15) = 0;
DYNX(W_,27) = 0;
DYNX(W_,41) = 0;
DYNX(W_,42) = 0;
DYNX(W_,43) = 0;
DYNX(W_,53) = 0;
DYNX(W_,54) = 0;
DYNX(W_,61) = 0;
DYNX(W_,62) = 0;
DYNX(W_,63) = 0;
DYNX(W_,64) = 0;
DYNX(W_,80) = 0;
DYNX(W_,81) = 0;
DYNX(W_,82) = 0;
DYNX(W_,83) = 0;
DYNX(W_,84) = 0;
DYNX(W_,85) = 0;
DYNX(W_,109) = 0;
DYNX(W_,110) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,6);
DYNX(Aux_,1) = DYNX(W_,7);
DYNX(Aux_,2) = DYNX(W_,5);
DYNX(Aux_,3) = DYNX(W_,110);
DYNX(Aux_,4) = DYNX(W_,109);
InitialSection
InitialSection2
DYNX(F_,0) = 376.99111843077515;
DYNX(W_,109) = DYNX(Aux_,4);
DYNX(W_,110) = DYNX(Aux_,3);
DYNX(X_,0) = DYNX(W_,27);
DYNX(W_,6) = DYNX(Aux_,0);
  DYNX(W_,5) = false;
DYNX(W_,7) = DYNX(Aux_,1);
InitialBoundSection
DYNX(Aux_,2) = DYNX(W_,5);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(F_,0) = 376.99111843077515;

AcceptedSection1
DYNX(W_,88) = DYNX(X_,0);
DYNX(W_,67) = DYNX(X_,0);
DYNX(W_,50) = DYNX(X_,0);

RealFillAssign ((PushModelContext(1,"HPF.Types.Reference.equalityConstraint(\ntest_Load1.pin_p.reference, \nz2.pin_p.reference)")
  HPF_Types_Reference_equalityConstraint(DymStruc0_construct(DYNX(W_,88)), 
  DymStruc0_construct(DYNX(W_,67)))), 0);
PopAllMarks();
RealFillAssign ((PushModelContext(1,"HPF.Types.Reference.equalityConstraint(\nv.pin_p.reference, \nz.pin_p.reference)")
  HPF_Types_Reference_equalityConstraint(DymStruc0_construct(DYNX(X_,0)), 
  DymStruc0_construct(DYNX(W_,50)))), 0);
PopAllMarks();
AcceptedSection2
DYNX(W_,27) = DYNX(X_,0);
DYNX(W_,5) = PRE(DYNX(W_,5), 0);
DYNX(W_,6) = PRE(DYNX(W_,6), 1);
DYNX(W_,7) = PRE(DYNX(W_,7), 2);
  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.5,"0.5", 0), 0) 
    DYNX(W_,5) = true;
  endwhenModelica()
  endwhenBlock

  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.25,"0.25", 1), 1) 
    DYNX(W_,6) = true;
  endwhenModelica()
  endwhenBlock

  beginwhenBlock
  whenModelica(GreaterMinor(DYNTime,"time", 0.4,"0.4", 2), 2) 
    DYNX(W_,7) = true;
  endwhenModelica()
  endwhenBlock


{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 20 common subexpressions used in 13 expressions */
/* Of the common subexpressions 19 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"z2.i[1].re", "v.i[1].re", "z.v[1].re"};
const double nominal_[]={1.0, 1.0, 1.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 3, 0, 0, 1, -2, 1, 
  DYNX(DYNhelp,0), 76, DYNX(did_->helpvari_vec,0), 25);
NonLinearSystemSave(DYNX(W_,5), 0);
SetInitVectorNH(x__, 1, DYNX(W_,61), Remember_(DYNX(W_,61), 0));
SetInitVectorNH(x__, 2, DYNX(W_,12), Remember_(DYNX(W_,12), 1));
SetInitVectorNH(x__, 3, DYNX(W_,41), Remember_(DYNX(W_,41), 2));
Residues;
  DYNX(W_,13) = 0.5*(DYNX(W_,41)+5.0*DYNX(W_,12));
  DYNX(W_,81) = 2.0*DYNX(W_,12)+5.0*DYNX(W_,13);
  DYNX(W_,62) = (-0.5)*(DYNX(W_,61)-DYNX(W_,81));
  DYNX(W_,82) =  -(DYNX(W_,12)+DYNX(W_,61));
  DYNX(W_,80) = 2.0*DYNX(W_,61)-DYNX(W_,62);
  DYNX(W_,83) =  -(DYNX(W_,13)+DYNX(W_,62));
DYNX(DYNhelp,76) = DYNX(W_,5) == false;
SetVector(residue__, 1, DYNX(W_,41)+DYNX(W_,80)-100.0);
SetVector(residue__, 2, IF DYNX(DYNhelp,76) THEN (-150.0)-DYNX(W_,80)*
  DYNX(W_,82) ELSE DYNX(W_,82)-5);
SetVector(residue__, 3, IF DYNX(DYNhelp,76) THEN 20.0+DYNX(W_,81)*DYNX(W_,83)
   ELSE DYNX(W_,83)-0.25);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,77) = IF DYNX(DYNhelp,76) THEN  -DYNX(W_,82) ELSE 0.0;
DYNX(DYNhelp,78) = IF DYNX(DYNhelp,76) THEN  -DYNX(W_,80) ELSE 1.0;
DYNX(DYNhelp,79) = IF DYNX(DYNhelp,76) THEN DYNX(W_,81) ELSE 1.0;
DYNX(DYNhelp,80) = 0.5*DYNX(DYNhelp,79);
DYNX(DYNhelp,81) = (IF DYNX(DYNhelp,76) THEN DYNX(W_,83) ELSE 0.0)-
  DYNX(DYNhelp,80);
DYNX(DYNhelp,82) = 5.0*DYNX(DYNhelp,81)-DYNX(DYNhelp,79);
SetMatrixLeading(Jacobian__, 1, 1, 3, 2.5);
SetMatrixLeading(Jacobian__, 1, 2, 3, -7.25);
SetMatrixLeading(Jacobian__, 1, 3, 3, -0.25);
SetMatrixLeading(Jacobian__, 2, 1, 3, 0.5*DYNX(DYNhelp,77)-DYNX(DYNhelp,78)+2.0*
  DYNX(DYNhelp,77));
SetMatrixLeading(Jacobian__, 2, 2, 3, (-7.25)*DYNX(DYNhelp,77)-DYNX(DYNhelp,78));
SetMatrixLeading(Jacobian__, 2, 3, 3, (-1.25)*DYNX(DYNhelp,77));
SetMatrixLeading(Jacobian__, 3, 1, 3, DYNX(DYNhelp,80));
SetMatrixLeading(Jacobian__, 3, 2, 3, 2.5*DYNX(DYNhelp,82)+2.0*DYNX(DYNhelp,81));
SetMatrixLeading(Jacobian__, 3, 3, 3, 0.5*DYNX(DYNhelp,82));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 1, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,61) = GetVector(x__, 1);
DYNX(W_,12) = GetVector(x__, 2);
DYNX(W_,41) = GetVector(x__, 3);
EndNonLinearSystemOfEquationsNH(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,109) = PRE(DYNX(W_,109), 3);
DYNX(W_,110) = PRE(DYNX(W_,110), 4);
  beginwhenBlock
  whenModelica(( DYNX(W_,6) != PRE(DYNX(W_,6), 1) ), 3) 
    (PushModelContext(1,"HPF.SinglePhase.NonlinearLoads.DataIO.writeNodeVoltage(\ntest_Load1.v[1], \n\"testLoad\")")
      HPF_SinglePhase_NonlinearLoads_DataIO_writeNodeVoltage(DymStruc1_construct(
      DYNX(W_,81), DYNX(W_,80)), "testLoad"));
    PopModelContext();
  endwhenModelica()
  endwhenBlock

  beginwhenBlock
  whenModelica(( DYNX(W_,7) != PRE(DYNX(W_,7), 2) ), 4) 
    {
      struct DymStruc1 dummy_DymStruc1;
      dummy_DymStruc1 = (PushModelContext(1,"HPF.SinglePhase.NonlinearLoads.DataIO.readNodeVoltage(\"testLoad\")")
        HPF_SinglePhase_NonlinearLoads_DataIO_readNodeVoltage("testLoad"));
      DYNX(W_,110) = dummy_DymStruc1.im_0member;
      DYNX(W_,109) = dummy_DymStruc1.re_0member;
    PopModelContext();
    }
  endwhenModelica()
  endwhenBlock


{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[2] */
/* Introducing 16 common subexpressions used in 10 expressions */
/* Of the common subexpressions 15 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"z2.i[2].re", "v.i[2].re", "z2.i[2].im"};
const double nominal_[]={1.0, 1.0, 1.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 3, 0, 0, 2, -2, 1, 
  DYNX(DYNhelp,83), 76, DYNX(did_->helpvari_vec,25), 25);
NonLinearSystemSave(DYNX(W_,5), 0);
SetInitVectorNH(x__, 1, DYNX(W_,63), Remember_(DYNX(W_,63), 3));
SetInitVectorNH(x__, 2, DYNX(W_,14), Remember_(DYNX(W_,14), 4));
SetInitVectorNH(x__, 3, DYNX(W_,64), Remember_(DYNX(W_,64), 5));
Residues;
  DYNX(W_,84) =  -(DYNX(W_,14)+DYNX(W_,63));
  DYNX(W_,53) = 2.0*DYNX(W_,63)-3.0*DYNX(W_,64);
  DYNX(W_,42) = 4.387912809451864-DYNX(W_,53);
  DYNX(W_,15) = 0.16666666666666666*(DYNX(W_,42)+5.0*DYNX(W_,14));
  DYNX(W_,43) = (-5.0)*DYNX(W_,15)-6.0*DYNX(W_,14);
  DYNX(W_,85) =  -(DYNX(W_,15)+DYNX(W_,64));
  DYNX(W_,54) = 2.0*DYNX(W_,64)+3.0*DYNX(W_,63);
DYNX(DYNhelp,159) = DYNX(W_,5) == false;
SetVector(residue__, 1, DYNX(W_,43)+DYNX(W_,54)-2.397127693021015);
SetVector(residue__, 2, IF DYNX(DYNhelp,159) THEN  -DYNX(W_,53)*DYNX(W_,84)
   ELSE DYNX(W_,84)-2);
SetVector(residue__, 3, IF DYNX(DYNhelp,159) THEN DYNX(W_,54)*DYNX(W_,85) ELSE 
  DYNX(W_,85)-0.5);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,160) = IF DYNX(DYNhelp,159) THEN  -DYNX(W_,84) ELSE 0.0;
DYNX(DYNhelp,161) = IF DYNX(DYNhelp,159) THEN  -DYNX(W_,53) ELSE 1.0;
DYNX(DYNhelp,162) = IF DYNX(DYNhelp,159) THEN DYNX(W_,54) ELSE 1.0;
DYNX(DYNhelp,163) = IF DYNX(DYNhelp,159) THEN DYNX(W_,85) ELSE 0.0;
SetMatrixLeading(Jacobian__, 1, 1, 3, 4.666666666666666);
SetMatrixLeading(Jacobian__, 1, 2, 3, -10.166666666666666);
SetMatrixLeading(Jacobian__, 1, 3, 3, -0.5);
SetMatrixLeading(Jacobian__, 2, 1, 3, 2.0*DYNX(DYNhelp,160)-DYNX(DYNhelp,161));
SetMatrixLeading(Jacobian__, 2, 2, 3, (-1.0)*DYNX(DYNhelp,161));
SetMatrixLeading(Jacobian__, 2, 3, 3, (-3.0)*DYNX(DYNhelp,160));
SetMatrixLeading(Jacobian__, 3, 1, 3, 0.3333333333333333*DYNX(DYNhelp,162)+3.0*
  DYNX(DYNhelp,163));
SetMatrixLeading(Jacobian__, 3, 2, 3, (-0.8333333333333333)*DYNX(DYNhelp,162));
SetMatrixLeading(Jacobian__, 3, 3, 3, 2.0*DYNX(DYNhelp,163)-1.5*DYNX(DYNhelp,162));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 2, 
  "Tag: simulation.nonlinear[2]");
DYNX(W_,63) = GetVector(x__, 1);
DYNX(W_,14) = GetVector(x__, 2);
DYNX(W_,64) = GetVector(x__, 3);
EndNonLinearSystemOfEquationsNH(residue__, x__, 2);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,37) = DYNX(W_,83)+DYNX(W_,13)+DYNX(W_,62);
DYNX(W_,38) = DYNX(W_,85)+DYNX(W_,15)+DYNX(W_,64);
DYNX(W_,39) = DYNX(W_,82)+DYNX(W_,12)+DYNX(W_,61);
DYNX(W_,40) = DYNX(W_,84)+DYNX(W_,14)+DYNX(W_,63);
DYNX(W_,57) = powGuarded(sqr(DYNX(W_,41))+sqr(DYNX(W_,81)),"z.v[1].re^2+test_Load1.v[1].im^2",
  0.5,"0.5");
DYNX(W_,58) = (PushModelContext(1,"Modelica.Math.atan3( -test_Load1.v[1].im, z.v[1].re, 0)")
  Modelica_Math_atan3( -DYNX(W_,81), DYNX(W_,41), 0));
PopModelContext();
DYNX(W_,59) = powGuarded(sqr(DYNX(W_,12))+sqr(DYNX(W_,13)),"v.i[1].re^2+v.i[1].im^2",
  0.5,"0.5");
DYNX(W_,60) = (PushModelContext(1,"Modelica.Math.atan3( -v.i[1].im,  -v.i[1].re, 0)")
  Modelica_Math_atan3( -DYNX(W_,13),  -DYNX(W_,12), 0));
PopModelContext();
DYNX(W_,76) = powGuarded(sqr(DYNX(W_,80))+sqr(DYNX(W_,81)),"test_Load1.v[1].re^2+test_Load1.v[1].im^2",
  0.5,"0.5");
DYNX(W_,77) = (PushModelContext(1,"Modelica.Math.atan3(test_Load1.v[1].im, test_Load1.v[1].re, 0)")
  Modelica_Math_atan3(DYNX(W_,81), DYNX(W_,80), 0));
PopModelContext();
DYNX(W_,78) = powGuarded(sqr(DYNX(W_,61))+sqr(DYNX(W_,62)),"z2.i[1].re^2+z2.i[1].im^2",
  0.5,"0.5");
DYNX(W_,79) = (PushModelContext(1,"Modelica.Math.atan3(z2.i[1].im, z2.i[1].re, 0)")
  Modelica_Math_atan3(DYNX(W_,62), DYNX(W_,61), 0));
PopModelContext();

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("systemDef.hrms[1]", "Harmonics to simulate [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("systemDef.hrms[2]", "Harmonics to simulate [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("systemDef.numHrm", "Number of harmonics. (Automatically generated from hrms. Do not alter) [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("systemDef.numPh", "Number of phases [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("systemDef.fFund", "Fundamental frequency", 60, 0.0,0.0,0.0,0,513)
DeclareVariable("systemDef.modeSelect", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,\
0,642)
DeclareVariable("systemDef.event1", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("systemDef.event2", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("v.v[1].re", "Real part of complex number", 100.0, 0.0,0.0,1.0,0,513)
DeclareVariable("v.v[1].im", "Imaginary part of complex number", 0.0, 0.0,0.0,\
1.0,0,513)
DeclareVariable("v.v[2].re", "Real part of complex number", 4.387912809451864, \
0.0,0.0,1.0,0,513)
DeclareVariable("v.v[2].im", "Imaginary part of complex number", \
2.397127693021015, 0.0,0.0,1.0,0,513)
DeclareVariable("v.i[1].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareVariable("v.i[1].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("v.i[2].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareVariable("v.i[2].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("v.omega", "[rad/s]", 376.99111843077515, 0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_p.h", "Numbder of harmonics [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,525)
DeclareVariable("v.pin_p.v[1].re", "Real part of complex number", 100.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_p.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_p.v[2].re", "Real part of complex number", \
4.387912809451864, 0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_p.v[2].im", "Imaginary part of complex number", \
2.397127693021015, 0.0,0.0,0.0,0,513)
DeclareAlias2("v.pin_p.iIm[1]", "", "v.i[1].im", 1, 5, 13, 132)
DeclareAlias2("v.pin_p.iIm[2]", "", "v.i[2].im", 1, 5, 15, 132)
DeclareAlias2("v.pin_p.iRe[1]", "", "v.i[1].re", 1, 5, 12, 132)
DeclareAlias2("v.pin_p.iRe[2]", "", "v.i[2].re", 1, 5, 14, 132)
DeclareState("v.pin_p.reference.theta", "[rad|deg]", 0, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("v.pin_p.reference.der(theta)", "[rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("v.pin_n.h", "Numbder of harmonics [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,525)
DeclareVariable("v.pin_n.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("v.pin_n.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("v.pin_n.v[2].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("v.pin_n.v[2].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("v.pin_n.iIm[1]", "", "v.i[1].im", -1, 5, 13, 132)
DeclareAlias2("v.pin_n.iIm[2]", "", "v.i[2].im", -1, 5, 15, 132)
DeclareAlias2("v.pin_n.iRe[1]", "", "v.i[1].re", -1, 5, 12, 132)
DeclareAlias2("v.pin_n.iRe[2]", "", "v.i[2].re", -1, 5, 14, 132)
DeclareAlias2("v.pin_n.reference.theta", "[rad|deg]", "v.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareVariable("v.theta", "[rad|deg]", 0, 0.0,0.0,0.0,0,528)
DeclareVariable("v.vMag[1]", "Voltage Magnitude", 100, 0.0,0.0,0.0,0,513)
DeclareVariable("v.vMag[2]", "Voltage Magnitude", 5, 0.0,0.0,0.0,0,513)
DeclareVariable("v.vArg[1]", "Voltage angle", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("v.vArg[2]", "Voltage angle", 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.h", "Numbder of harmonics [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,525)
DeclareVariable("ground1.pin.v[1].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[2].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.v[2].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("ground1.pin.iIm[1]", "", 0.0, 0.0,0.0,0.0,0,904)
DeclareVariable("ground1.pin.iIm[2]", "", 0.0, 0.0,0.0,0.0,0,904)
DeclareVariable("ground1.pin.iRe[1]", "", 0.0, 0.0,0.0,0.0,0,904)
DeclareVariable("ground1.pin.iRe[2]", "", 0.0, 0.0,0.0,0.0,0,904)
DeclareAlias2("ground1.pin.reference.theta", "[rad|deg]", "v.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareVariable("z.v[1].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareAlias2("z.v[1].im", "Imaginary part of complex number", "test_Load1.v[1].im", -1,\
 5, 81, 64)
DeclareVariable("z.v[2].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,640)
DeclareVariable("z.v[2].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareAlias2("z.i[1].re", "Real part of complex number", "v.i[1].re", -1, 5, 12,\
 0)
DeclareAlias2("z.i[1].im", "Imaginary part of complex number", "v.i[1].im", -1, 5,\
 13, 0)
DeclareAlias2("z.i[2].re", "Real part of complex number", "v.i[2].re", -1, 5, 14,\
 0)
DeclareAlias2("z.i[2].im", "Imaginary part of complex number", "v.i[2].im", -1, 5,\
 15, 0)
DeclareVariable("z.omega", "[rad/s]", 376.99111843077515, 0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_p.h", "Numbder of harmonics [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,525)
DeclareVariable("z.pin_p.v[1].re", "Real part of complex number", 100.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_p.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_p.v[2].re", "Real part of complex number", \
4.387912809451864, 0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_p.v[2].im", "Imaginary part of complex number", \
2.397127693021015, 0.0,0.0,0.0,0,513)
DeclareAlias2("z.pin_p.iIm[1]", "", "v.i[1].im", -1, 5, 13, 132)
DeclareAlias2("z.pin_p.iIm[2]", "", "v.i[2].im", -1, 5, 15, 132)
DeclareAlias2("z.pin_p.iRe[1]", "", "v.i[1].re", -1, 5, 12, 132)
DeclareAlias2("z.pin_p.iRe[2]", "", "v.i[2].re", -1, 5, 14, 132)
DeclareVariable("z.pin_p.reference.theta", "[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("z.pin_p.reference.der(theta)", "[rad/s]", 376.99111843077515, \
0.0,0.0,0.0,0,513)
DeclareVariable("z.pin_n.h", "Numbder of harmonics [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,525)
DeclareAlias2("z.pin_n.v[1].re", "Real part of complex number", "test_Load1.v[1].re", 1,\
 5, 80, 64)
DeclareAlias2("z.pin_n.v[1].im", "Imaginary part of complex number", \
"test_Load1.v[1].im", 1, 5, 81, 64)
DeclareVariable("z.pin_n.v[2].re", "Real part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("z.pin_n.v[2].im", "Imaginary part of complex number", 0, \
0.0,0.0,1.0,0,640)
DeclareAlias2("z.pin_n.iIm[1]", "", "v.i[1].im", 1, 5, 13, 132)
DeclareAlias2("z.pin_n.iIm[2]", "", "v.i[2].im", 1, 5, 15, 132)
DeclareAlias2("z.pin_n.iRe[1]", "", "v.i[1].re", 1, 5, 12, 132)
DeclareAlias2("z.pin_n.iRe[2]", "", "v.i[2].re", 1, 5, 14, 132)
DeclareAlias2("z.pin_n.reference.theta", "[rad|deg]", "v.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareVariable("z.z.re", "Real part of complex number", 5.0, 0.0,0.0,0.0,0,513)
DeclareVariable("z.z.im", "Imaginary part of complex number", 2.0, 0.0,0.0,0.0,0,513)
DeclareVariable("z.vFundAbs", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("z.vFundArg", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("z.iFundAbs", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("z.iFundArg", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("z2.v[1].re", "Real part of complex number", "test_Load1.v[1].re", 1,\
 5, 80, 64)
DeclareAlias2("z2.v[1].im", "Imaginary part of complex number", "test_Load1.v[1].im", 1,\
 5, 81, 64)
DeclareAlias2("z2.v[2].re", "Real part of complex number", "z.pin_n.v[2].re", 1,\
 5, 53, 64)
DeclareAlias2("z2.v[2].im", "Imaginary part of complex number", "z.pin_n.v[2].im", 1,\
 5, 54, 64)
DeclareVariable("z2.i[1].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareVariable("z2.i[1].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,640)
DeclareVariable("z2.i[2].re", "Real part of complex number", 0, 0.0,0.0,1.0,0,704)
DeclareVariable("z2.i[2].im", "Imaginary part of complex number", 0, 0.0,0.0,1.0,\
0,704)
DeclareVariable("z2.omega", "[rad/s]", 376.99111843077515, 0.0,0.0,0.0,0,513)
DeclareVariable("z2.pin_p.h", "Numbder of harmonics [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,525)
DeclareAlias2("z2.pin_p.v[1].re", "Real part of complex number", \
"test_Load1.v[1].re", 1, 5, 80, 0)
DeclareAlias2("z2.pin_p.v[1].im", "Imaginary part of complex number", \
"test_Load1.v[1].im", 1, 5, 81, 0)
DeclareAlias2("z2.pin_p.v[2].re", "Real part of complex number", \
"z.pin_n.v[2].re", 1, 5, 53, 0)
DeclareAlias2("z2.pin_p.v[2].im", "Imaginary part of complex number", \
"z.pin_n.v[2].im", 1, 5, 54, 0)
DeclareAlias2("z2.pin_p.iIm[1]", "", "z2.i[1].im", 1, 5, 62, 132)
DeclareAlias2("z2.pin_p.iIm[2]", "", "z2.i[2].im", 1, 5, 64, 132)
DeclareAlias2("z2.pin_p.iRe[1]", "", "z2.i[1].re", 1, 5, 61, 132)
DeclareAlias2("z2.pin_p.iRe[2]", "", "z2.i[2].re", 1, 5, 63, 132)
DeclareVariable("z2.pin_p.reference.theta", "[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("z2.pin_p.reference.der(theta)", "[rad/s]", 376.99111843077515, \
0.0,0.0,0.0,0,513)
DeclareVariable("z2.pin_n.h", "Numbder of harmonics [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,525)
DeclareVariable("z2.pin_n.v[1].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("z2.pin_n.v[1].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("z2.pin_n.v[2].re", "Real part of complex number", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("z2.pin_n.v[2].im", "Imaginary part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("z2.pin_n.iIm[1]", "", "z2.i[1].im", -1, 5, 62, 132)
DeclareAlias2("z2.pin_n.iIm[2]", "", "z2.i[2].im", -1, 5, 64, 132)
DeclareAlias2("z2.pin_n.iRe[1]", "", "z2.i[1].re", -1, 5, 61, 132)
DeclareAlias2("z2.pin_n.iRe[2]", "", "z2.i[2].re", -1, 5, 63, 132)
DeclareAlias2("z2.pin_n.reference.theta", "[rad|deg]", "v.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareVariable("z2.z.re", "Real part of complex number", 2.0, 0.0,0.0,0.0,0,513)
DeclareVariable("z2.z.im", "Imaginary part of complex number", 1.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("z2.vFundAbs", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("z2.vFundArg", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("z2.iFundAbs", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("z2.iFundArg", "", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("test_Load1.v[1].re", "Real part of complex number", 0, 0.0,0.0,\
1.0,0,640)
DeclareVariable("test_Load1.v[1].im", "Imaginary part of complex number", 0, \
0.0,0.0,1.0,0,640)
DeclareAlias2("test_Load1.v[2].re", "Real part of complex number", \
"z.pin_n.v[2].re", 1, 5, 53, 64)
DeclareAlias2("test_Load1.v[2].im", "Imaginary part of complex number", \
"z.pin_n.v[2].im", 1, 5, 54, 64)
DeclareVariable("test_Load1.i[1].re", "Real part of complex number", 0, 0.0,0.0,\
1.0,0,640)
DeclareVariable("test_Load1.i[1].im", "Imaginary part of complex number", 0, \
0.0,0.0,1.0,0,640)
DeclareVariable("test_Load1.i[2].re", "Real part of complex number", 0, 0.0,0.0,\
1.0,0,640)
DeclareVariable("test_Load1.i[2].im", "Imaginary part of complex number", 0, \
0.0,0.0,1.0,0,640)
DeclareVariable("test_Load1.omega", "[rad/s]", 376.99111843077515, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.pin_p.h", "Numbder of harmonics [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,525)
DeclareAlias2("test_Load1.pin_p.v[1].re", "Real part of complex number", \
"test_Load1.v[1].re", 1, 5, 80, 0)
DeclareAlias2("test_Load1.pin_p.v[1].im", "Imaginary part of complex number", \
"test_Load1.v[1].im", 1, 5, 81, 0)
DeclareAlias2("test_Load1.pin_p.v[2].re", "Real part of complex number", \
"z.pin_n.v[2].re", 1, 5, 53, 0)
DeclareAlias2("test_Load1.pin_p.v[2].im", "Imaginary part of complex number", \
"z.pin_n.v[2].im", 1, 5, 54, 0)
DeclareAlias2("test_Load1.pin_p.iIm[1]", "", "test_Load1.i[1].im", 1, 5, 83, 132)
DeclareAlias2("test_Load1.pin_p.iIm[2]", "", "test_Load1.i[2].im", 1, 5, 85, 132)
DeclareAlias2("test_Load1.pin_p.iRe[1]", "", "test_Load1.i[1].re", 1, 5, 82, 132)
DeclareAlias2("test_Load1.pin_p.iRe[2]", "", "test_Load1.i[2].re", 1, 5, 84, 132)
DeclareVariable("test_Load1.pin_p.reference.theta", "[rad|deg]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("test_Load1.pin_p.reference.der(theta)", "[rad/s]", \
376.99111843077515, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.pin_n.h", "Numbder of harmonics [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,525)
DeclareVariable("test_Load1.pin_n.v[1].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.pin_n.v[1].im", "Imaginary part of complex number", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.pin_n.v[2].re", "Real part of complex number", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.pin_n.v[2].im", "Imaginary part of complex number", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("test_Load1.pin_n.iIm[1]", "", "test_Load1.i[1].im", -1, 5, 83, 132)
DeclareAlias2("test_Load1.pin_n.iIm[2]", "", "test_Load1.i[2].im", -1, 5, 85, 132)
DeclareAlias2("test_Load1.pin_n.iRe[1]", "", "test_Load1.i[1].re", -1, 5, 82, 132)
DeclareAlias2("test_Load1.pin_n.iRe[2]", "", "test_Load1.i[2].re", -1, 5, 84, 132)
DeclareAlias2("test_Load1.pin_n.reference.theta", "[rad|deg]", "v.pin_p.reference.theta", 1,\
 1, 0, 0)
DeclareVariable("test_Load1.sReal", "IMPORTANT: set real power to -ve", -150, \
0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.sImag", "", 20, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.iReal[1]", "", 5, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.iReal[2]", "", 2, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.iImag[1]", "", 0.25, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.iImag[2]", "", 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.sVectRe[1]", "", -150, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.sVectRe[2]", "", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.sVectIm[1]", "", 20, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.sVectIm[2]", "", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("test_Load1.testVect[1].re", "Real part of complex number", \
-150.0, 0.0,0.0,1.0,0,513)
DeclareVariable("test_Load1.testVect[1].im", "Imaginary part of complex number",\
 20.0, 0.0,0.0,1.0,0,513)
DeclareVariable("test_Load1.testVect[2].re", "Real part of complex number", 0.0,\
 0.0,0.0,1.0,0,513)
DeclareVariable("test_Load1.testVect[2].im", "Imaginary part of complex number",\
 0.0, 0.0,0.0,1.0,0,513)
DeclareVariable("test_Load1.vPre.re", "Real part of complex number", 0, 0.0,0.0,\
0.0,0,656)
DeclareVariable("test_Load1.vPre.im", "Imaginary part of complex number", 0, \
0.0,0.0,0.0,0,656)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
pre(DYNX(W_,6),"systemDef.event1", false, 1);
pre(DYNX(W_,7),"systemDef.event2", false, 2);
pre(DYNX(W_,5),"systemDef.modeSelect", true, 0);
pre(DYNX(W_,110),"test_Load1.vPre.im", 0, 4);
pre(DYNX(W_,109),"test_Load1.vPre.re", 0, 3);
EndPreBlock
StartEqBlock
DoRememAcc_(DYNX(W_,12), 0, 1);
DoRememAcc_(DYNX(W_,14), 0, 4);
DoRememAcc_(DYNX(W_,41), 0, 2);
DoRememAcc_(DYNX(W_,61), 0, 0);
DoRememAcc_(DYNX(W_,64), 0, 5);
DoRememAcc_(DYNX(W_,63), 0, 3);
EndEqBlock
UpdateQEvaluate(5)
EndDataBlock
