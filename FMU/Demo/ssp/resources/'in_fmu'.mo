within ;
model 'in_fmu'
  "Automatically generated from EnergyPlus input file in.idf"
// Model automatically generated by Dymola from FMI model description
extends fmuIcon;
public
  parameter Real _Q_start = 0
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _Q_old;
public
  Modelica.Blocks.Interfaces.RealInput Q(start = _Q_start)
                                                          "IDF line 1033"
  annotation (Placement(transformation(extent={{-124,-20},{-84,20}})));
  Modelica.Blocks.Interfaces.RealOutput electric_demand
                                                       "IDF line 1028"
  annotation (Placement(transformation(extent={{100,30},{140,70}})));
  Modelica.Blocks.Interfaces.RealOutput district_heating
                                                        "IDF line 1039"
  annotation (Placement(transformation(extent={{100,-20},{140,20}})));
  Modelica.Blocks.Interfaces.RealOutput district_cooling
                                                        "IDF line 1044"
  annotation (Placement(transformation(extent={{100,-70},{140,-30}})));
public
  parameter String fmi_instanceName="'in_fmu'"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  parameter Boolean fmi_pullInputsForInitialization=true
  "Set to false when using the FMU in feedback connections"
  annotation (Dialog(tab="FMI", group="Inputs for initialization"));
  parameter Boolean fmi_InputTime=false
  "Time point of input used when calling doStep."
  annotation (Evaluate=true,Dialog(tab="FMI", group="Input Handling"),choices(choice= false "StepEnd", choice= true "StepStart"));
  parameter Boolean fmi_UsePreOnInputSignals=true
  annotation (Evaluate=true,Dialog(tab="FMI", group="Input Handling"));
  parameter Real fmi_StartTime = 0
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_StopTime = 1
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_NumberOfSteps = 500
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_CommunicationStepSize=(fmi_StopTime-fmi_StartTime)/fmi_NumberOfSteps
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Integer stepSizeScaleFactor = 1 "Number of doSteps called between two CommunicationStepSize"
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Boolean fmi_forceShutDownAtStopTime=false
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter String fmi_fmuLocation="file:///"+ModelicaServices.ExternalReferences.loadResource("modelica://'in_fmu'/Resources/Library/FMU/in")
  annotation (Dialog(tab="FMI", group="Instantiation"));
protected
fmi_Functions.fmiModel fmi;
Boolean fmi_StepOK;
parameter Real fmi_Initialized(fixed=false);
parameter Real fmi_AParamsAndStart(fixed=false);
parameter Real fmi_initInput0(start=0,fixed=false);
package fmi_Functions
  class fmiModel
  extends ExternalObject;
    function constructor "Initialize FMI model"
      extends Modelica.Icons.Function;
      input String instanceName;
      input Boolean loggingOn;
        input String fmuLocation;
      output fmiModel fmi;
      external"C" fmi = in_fmiInstantiateModel2(instanceName, loggingOn, fmuLocation)
      annotation(Header="
#ifndef in_Instantiate_C
#define in_Instantiate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
#ifndef in_MYSTRCMP_C
#define in_MYSTRCMP_C 1
int inmystrcmp(const void *_a, const void *_b) {
  char *a = _a;
  char *const *b = _b;
  return strcmp(a, *b);
}
#endif
void inLogger(fmiComponent c, fmiString instanceName, fmiStatus status,
	 fmiString category, fmiString message, ...) {
  char msg[4096];
  char buf[4096];
  int len;
  va_list ap;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len <4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmiFatal:
      ModelicaMessage(\"[fmiFatal]: \");
      break;
    case fmiError:
      ModelicaMessage(\"[fmiError]: \");
      break;
    case fmiDiscard:
      ModelicaMessage(\"[fmiDiscard]: \");
      break;
    case fmiWarning:
      ModelicaMessage(\"[fmiWarning]: \");
      break;
    case fmiOK:
      ModelicaMessage(\"[fmiOK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * in_fmiInstantiateModel2(const char*instanceName, fmiBoolean loggingOn, const char* fmuLocation) {
  static fmiCoSimCallbackFunctions funcs = {&inLogger, &calloc, &free, NULL};
  struct dy_Extended* res;

  res = calloc(1, sizeof(struct dy_Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibraryW(L\"in.dll\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (in.dll) failed!\");
      return 0;
    }
    if(!(res->dyFmiInstantiateSlave=(fmiInstantiateSlaveFunc)GetProcAddress(res->hInst,\"in_fmiInstantiateSlave\"))){
      ModelicaError(\"GetProcAddress failed for fmiInstantiateSlave!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiInstantiateSlave\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiFreeSlaveInstance=(fmiFreeSlaveInstanceFunc)GetProcAddress(res->hInst,\"in_fmiFreeSlaveInstance\"))){
      ModelicaError(\"GetProcAddress failed for fmiFreeSlaveInstance!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiFreeSlaveInstance\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiInitializeSlave=(fmiInitializeSlaveFunc)GetProcAddress(res->hInst,\"in_fmiInitializeSlave\"))){
      ModelicaError(\"GetProcAddress failed for fmiInitializeSlave!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiInitializeSlave\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiResetSlave=(fmiResetSlaveFunc)GetProcAddress(res->hInst,\"in_fmiResetSlave\"))){
      ModelicaError(\"GetProcAddress failed for fmiResetSlave!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiResetSlave\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiDoStep=(fmiDoStepFunc)GetProcAddress(res->hInst,\"in_fmiDoStep\"))){
      ModelicaError(\"GetProcAddress failed for fmiDoStep!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiDoStep\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiTerminateSlave=(fmiTerminateSlaveFunc)GetProcAddress(res->hInst,\"in_fmiTerminateSlave\"))){
      ModelicaError(\"GetProcAddress failed for fmiTerminateSlave!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiTerminateSlave\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmiSetRealFunc)GetProcAddress(res->hInst,\"in_fmiSetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmiGetRealFunc)GetProcAddress(res->hInst,\"in_fmiGetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmiSetIntegerFunc)GetProcAddress(res->hInst,\"in_fmiSetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmiGetIntegerFunc)GetProcAddress(res->hInst,\"in_fmiGetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmiSetBooleanFunc)GetProcAddress(res->hInst,\"in_fmiSetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmiGetBooleanFunc)GetProcAddress(res->hInst,\"in_fmiGetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmiSetStringFunc)GetProcAddress(res->hInst,\"in_fmiSetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmiGetStringFunc)GetProcAddress(res->hInst,\"in_fmiGetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetString!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmiSetDebugLoggingFunc)GetProcAddress(res->hInst,\"in_fmiSetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetDebugLogging!\");
      return 0;
    }
    res->m=res->dyFmiInstantiateSlave(instanceName, \"d1f5acfb5aa92f664da725f8e677d9a8\", fmuLocation, \"application/x-dymolakernel\", 0, fmiFalse, fmiFalse, funcs, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateSlave failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;}
  }
  return res;
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in");
    end constructor;

    function destructor "Release storage of FMI model"
      extends Modelica.Icons.Function;
      input fmiModel fmi;
      external"C"
                 in_fmiFreeModelInstance2(fmi);
      annotation (Header="
#ifndef in_Free_C
#define in_Free_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void in_fmiFreeModelInstance2(void*m) {
  struct dy_Extended*a=m;
  if (a) {
    a->dyFmiTerminateSlave(a->m);
    a->dyFmiFreeSlaveInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in");
    end destructor;
  end fmiModel;

    function fmiInitializeSlave
      input fmiModel fmi;
      input Real tStart;
      input Boolean forceShutDownAtTStop;
       input Real tStop;
      input Real preAvailable;
      output Real postAvailable=preAvailable;
      external"C" in_fmiInitializeSlave2(fmi, tStart, forceShutDownAtTStop, tStop);
      annotation (Header="
#ifndef in_InitializeSlave_C
#define in_InitializeSlave_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double in_fmiInitializeSlave2(void*m, fmiReal tStart, fmiBoolean forceShutDownAtTStop, fmiReal tStop) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiInitializeSlave(a->m, tStart, forceShutDownAtTStop, tStop);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"InitializeSlave failed\");
  return 1e37;
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in");
    end fmiInitializeSlave;

    function fmiDoStep
     input fmiModel fmi;
     input Real currentTime;
     input Real stepSize;
     output Boolean stepOK;
     external"C" stepOK= in_fmiDoStep2(fmi, currentTime, stepSize);
     annotation (Header="
#ifndef in_DoStep_C
#define in_DoStep_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double in_fmiDoStep2(void*m, double currentTime, double stepSize) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiDoStep(a->m, currentTime, stepSize, fmiTrue);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"DoStep failed\");
  return 1.0;
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in");
    end fmiDoStep;

    function fmiResetSlave
      input fmiModel fmi;
      output Boolean resetOK;
      external"C" resetOK = in_fmiResetSlave2(fmi);
      annotation (Header="
#ifndef in_ResetSlave_C
#define in_ResetSlave_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double in_fmiResetSlave2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiResetSlave(a->m);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"resetSlave failed\");
    return 1.0;
  }
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in");
    end fmiResetSlave;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      output Real dummy= 1;
      external"C"
                 in_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef in_SetReal_C
#define in_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void in_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealParam
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
    protected
      Real oldVals[size(refs, 1)];
      external"C"
                 in_fmiSetRealParam2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
        annotation (Header="
#ifndef in_SetRealParam_C
#define in_SetRealParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void in_fmiSetRealParam2(void*m, const int*refs, size_t nrefs, const double*vals, double*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetReal(a->m, refs, nrefs, oldVals);
      for(i=0; i<nrefs;++i){
        if( abs(vals[i]-oldVals[i])> 5e-16){
          ModelicaError(\"SetRealParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealParam;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      input Real dummy;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}, dummy));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      input Real preAvailable;
      external"C" in_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef in_GetReal_C
#define in_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void in_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetReal failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in");
    end fmiGetReal;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      input Integer dummy;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}, dummy));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" in_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef in_GetInteger_C
#define in_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void in_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in");
    end fmiGetInteger;

    function fmiSetInteger
    input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
      output Real dummy= 1;
      external"C" in_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef in_SetInteger_C
#define in_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void in_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiSetIntegerParam
    input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" in_fmiSetIntegerParam2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
        annotation (Header="
#ifndef in_SetIntegerParam_C
#define in_SetIntegerParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void in_fmiSetIntegerParam2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i=0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      for(i = 0; i< nrefs; ++i){
        if(vals[i]!=oldVals[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetIntegerParam;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      input Integer dummy;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}, dummy));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" in_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef in_GetBoolean_C
#define in_GetBoolean_C 1
#include \"FMI/fmiImport.h\"
void in_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(vals));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetBoolean failed\");
  for(i=nr-1;i>=0;i--) vals[i]=((fmiBoolean*)(vals))[i];
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in");
    end fmiGetBoolean;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
      output Real dummy2= 1;
    protected
      Boolean dummy[size(refs, 1)];
      external"C" in_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy);
        annotation (Header="
#ifndef in_SetBoolean_C
#define in_SetBoolean_C 1
#include \"FMI/fmiImport.h\"
void in_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals,int*dummy) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetBooleanParam
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" in_fmiSetBooleanParam2(
      fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals);
        annotation (Header="
#ifndef in_SetBooleanParam_C
#define in_SetBooleanParam_C 1
#include \"FMI/fmiImport.h\"
void in_fmiSetBooleanParam2(void*m, const int* refs, size_t nr, const int* vals,int*dummy,int*oldVals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
    }else{
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(oldVals));
      for(i=nr-1;i>=0;i--){
        oldVals[i]=((fmiBoolean*)(oldVals))[i];
        if(oldVals[i]!=dummy[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBooleanParam;

    function fmiGetString
      input fmiModel fmi;
      input Integer refs[:];
      output String vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" in_fmiGetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef in_GetString_C
#define in_GetString_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void in_fmiGetString2(void*m, const int*refs, size_t nrefs, fmiString* vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"StringInteger failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in");
    end fmiGetString;

    function fmiSetString
    input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" in_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef in_SetString_C
#define in_SetString_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void in_fmiSetString2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function fmiSetStringParam
    input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" in_fmiSetStringParam2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef in_SetStringParam_C
#define in_SetStringParam_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void in_fmiSetStringParam2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif", Library="in", LibraryDirectory="modelica://'in_fmu'/Resources/Library/FMU/in/binaries", __Dymola_CriticalRegion="in",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetStringParam;

    function noHysteresis
      input Real x;
      output Real y;
    algorithm
      y:=x+(if (x < 0) then -1 else 1);
    end noHysteresis;
end fmi_Functions;
equation
  when initial() then
    fmi = fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn, fmi_fmuLocation);
  end when;
algorithm
  when {initial(), sample(fmi_StartTime, fmi_CommunicationStepSize)} then
    if time>=fmi_CommunicationStepSize +fmi_StartTime then
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {1}, {_Q_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(fmi, {1}, {pre(Q)});
      else
        fmi_Functions.fmiSetReal(fmi, {1}, {Q});
      end if;
    end if;
      for stepSizeIndex in 1:stepSizeScaleFactor loop
        fmi_StepOK :=fmi_Functions.fmiDoStep(
          fmi,
          time + (stepSizeIndex - 1 - stepSizeScaleFactor)*
            fmi_CommunicationStepSize/stepSizeScaleFactor,
          fmi_CommunicationStepSize/stepSizeScaleFactor);
      end for;
    end if;
    _Q_old := Q;
  electric_demand :=fmi_Functions.fmiGetRealScalar(
      fmi,
      100001,
      1);
  district_heating :=fmi_Functions.fmiGetRealScalar(
      fmi,
      100002,
      1);
  district_cooling :=fmi_Functions.fmiGetRealScalar(
      fmi,
      100003,
      1);
  end when;
initial algorithm
  fmi_AParamsAndStart:=1;
 // 0 Real parameters
 // 0 Real start values
 // 0 Integer parameters
 // 0 Integer start values
 // 0 Boolean parameters
 // 0 Boolean start values
 // 0 Enumeration parameters
 // 0 Enumeration start values
 // 0 String parameters
initial equation
if fmi_pullInputsForInitialization then fmi_initInput0 = fmi_Functions.fmiSetReal(fmi, {1}, {pre(Q)}); else fmi_initInput0 = fmi_Functions.fmiSetReal(fmi, {1}, {_Q_start}); end if;
  fmi_Initialized = fmi_Functions.fmiInitializeSlave(fmi, fmi_StartTime, fmi_forceShutDownAtStopTime, fmi_StopTime,fmi_AParamsAndStart+ fmi_initInput0);
  annotation (__Dymola_FMUImportVersion="Dymola 2019",    Icon(graphics={
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 1.0 CS")}),
Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 1.0</li>
<li>modelName = in.idf</li>
<li>generationTool = idf-to-fmu-export-prep-win.exe</li>
<li>generationDateAndTime = 2019-12-20T20:20:44Z</li>
</ul>
<p><br><b>Co-Simulation Attributes</b></p>
<ul>
<li>canHandleVariableCommunicationStepSize = false</li>
<li>canHandleEvents = false</li>
<li>canRejectSteps = false</li>
<li>canInterpolateInputs = false</li>
<li>maxOutputDerivativeOrder = 0</li>
<li>canRunAsynchronuously = false</li>
<li>canSignalEvents = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = false</li>
<li>canNotUseMemoryManagementFunctions = true</li>
</ul>
</html>"));
end 'in_fmu';
